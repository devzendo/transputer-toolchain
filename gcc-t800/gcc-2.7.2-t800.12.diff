diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/Makefile.in gcc-2.7.2-t800.12/Makefile.in
*** gcc-2.7.2/Makefile.in	Sun Nov 26 22:44:06 1995
--- gcc-2.7.2-t800.12/Makefile.in	Fri Feb  9 14:38:08 1996
***************
*** 517,521 ****
   rtl.o print-rtl.o rtlanal.o emit-rtl.o real.o \
   dbxout.o sdbout.o dwarfout.o xcoffout.o \
!  integrate.o jump.o cse.o loop.o unroll.o flow.o stupid.o combine.o \
   regclass.o local-alloc.o global.o reload.o reload1.o caller-save.o \
   insn-peep.o reorg.o sched.o final.o recog.o reg-stack.o \
--- 517,521 ----
   rtl.o print-rtl.o rtlanal.o emit-rtl.o real.o \
   dbxout.o sdbout.o dwarfout.o xcoffout.o \
!  integrate.o jump.o cse.o loop.o unroll.o exotic.o flow.o stupid.o combine.o \
   regclass.o local-alloc.o global.o reload.o reload1.o caller-save.o \
   insn-peep.o reorg.o sched.o final.o recog.o reg-stack.o \
***************
*** 662,666 ****
  libgcc1-test: libgcc1-test.o native $(GCC_PARTS)
  	@echo "Testing libgcc1.  Ignore linker warning messages."
! 	$(GCC_FOR_TARGET) $(GCC_CFLAGS) libgcc1-test.o -o libgcc1-test \
  	  -nostartfiles -nostdlib `$(GCC_FOR_TARGET) --print-libgcc-file-name`
  libgcc1-test.o: libgcc1-test.c native xgcc
--- 662,666 ----
  libgcc1-test: libgcc1-test.o native $(GCC_PARTS)
  	@echo "Testing libgcc1.  Ignore linker warning messages."
! 	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(LIBGCC1_LDFLAGS) libgcc1-test.o -o libgcc1-test \
  	  -nostartfiles -nostdlib `$(GCC_FOR_TARGET) --print-libgcc-file-name`
  libgcc1-test.o: libgcc1-test.c native xgcc
***************
*** 1215,1218 ****
--- 1215,1219 ----
  unroll.o : unroll.c $(CONFIG_H) $(RTL_H) insn-config.h insn-codes.h \
     integrate.h regs.h flags.h expr.h loop.h
+ exotic.o : exotic.c $(CONFIG_H) $(RTL_H) insn-config.h recog.h
  flow.o : flow.c $(CONFIG_H) $(RTL_H) flags.h insn-config.h \
     basic-block.h regs.h hard-reg-set.h output.h
***************
*** 1414,1418 ****
  $(MD_FILE): $(MD_DEPS)
  	rm -f $@
! 	$(MD_CPP) $(MD_CPPFLAGS) $(md_file) | sed 's/^# /; /g' > tmp-$@
  	mv tmp-$@ $@
  
--- 1415,1419 ----
  $(MD_FILE): $(MD_DEPS)
  	rm -f $@
! 	$(MD_CPP) $(MD_CPPFLAGS) $(MD_PRE_CPP) | sed 's/^# /; /g' > tmp-$@
  	mv tmp-$@ $@
  
***************
*** 2268,2271 ****
--- 2269,2291 ----
  	rmdir temp
  
+ # Make tags table including symbols from machine-dependent files for
+ # the machine currently configured.
+ fullTAGS: force
+ 	if [ `pwd` = `cd $(srcdir); pwd` ]; then			\
+ 	  machdeps="$(tm_file) $(out_file)";				\
+ 	else								\
+ 	  machdeps="";							\
+ 	  machdeps="$$machdeps "`pwd`/$(tm_file);			\
+ 	  machdeps="$$machdeps "`pwd`/*.h;				\
+ 	  machdeps="$$machdeps "`pwd`/$(out_file);			\
+ 	  machdeps="$$machdeps "`pwd`/*.c;				\
+ 	fi;								\
+ 	cd $(srcdir);							\
+ 	mkdir temp;							\
+ 	mv -f c-parse.[ch] objc-parse.c cexp.c =*.[chy] temp;		\
+ 	etags *.y *.h *.c $$machdeps;			 		\
+ 	mv temp/* .;							\
+ 	rmdir temp
+ 
  # Create the distribution tar file.
  #dist: gcc-$(version).tar.gz
***************
*** 2273,2277 ****
  
  gcc.xtar.gz: gcc.xtar
! 	gzip --best < gcc.xtar > tmp-gcc.xtar.gz
  	mv tmp-gcc.xtar.gz gcc.xtar.gz
  
--- 2293,2298 ----
  
  gcc.xtar.gz: gcc.xtar
! 	cd $(srcdir);							\
! 	gzip --best < gcc.xtar > tmp-gcc.xtar.gz;			\
  	mv tmp-gcc.xtar.gz gcc.xtar.gz
  
***************
*** 2282,2285 ****
--- 2303,2307 ----
  gcc.xtar: distdir
  # Make the distribution.
+ 	cd $(srcdir); \
  	tar -chf gcc.xtar gcc-$(version)
  
***************
*** 2289,2315 ****
    $(srcdir)/objc-parse.y $(srcdir)/c-parse.c $(srcdir)/objc-parse.c \
    $(srcdir)/cexp.c
! 	@if grep -s "for version ${mainversion}" gcc.texi > /dev/null; \
  	then true; \
  	else echo "You must update the version number in \`gcc.texi'"; sleep 10;\
  	fi
  # Update the version number in README
! 	awk '$$1 " " $$2 " " $$3 == "This directory contains" \
  		{ $$6 = version; print $$0 } \
  	     $$1 " " $$2 " " $$3 != "This directory contains"' \
  	  version=$(version) README > tmp.README
! 	mv tmp.README README
! 	-rm -rf gcc-$(version) tmp	
  # Put all the files in a temporary subdirectory
  # which has the name that we want to have in the tar file.
! 	mkdir tmp
! 	mkdir tmp/config
! 	mkdir tmp/ginclude
! 	mkdir tmp/objc
! 	for file in *[0-9a-zA-Z+]; do \
  	  ln $$file tmp > /dev/null 2>&1 || cp $$file tmp; \
  	done
! 	cd config; \
  	for file in *[0-9a-zA-Z+]; do \
! 	  if test -d $$file && test "$$file" != RCS; then \
  	    mkdir ../tmp/config/$$file; \
  	    cd $$file; \
--- 2311,2339 ----
    $(srcdir)/objc-parse.y $(srcdir)/c-parse.c $(srcdir)/objc-parse.c \
    $(srcdir)/cexp.c
! 	@if grep -s "for version ${mainversion}" $(srcdir)/gcc.texi > /dev/null; \
  	then true; \
  	else echo "You must update the version number in \`gcc.texi'"; sleep 10;\
  	fi
  # Update the version number in README
! 	cd $(srcdir); \
!         awk '$$1 " " $$2 " " $$3 == "This directory contains" \
  		{ $$6 = version; print $$0 } \
  	     $$1 " " $$2 " " $$3 != "This directory contains"' \
  	  version=$(version) README > tmp.README
! 	cd $(srcdir); mv tmp.README README
! 	-cd $(srcdir); rm -rf gcc-$(version) tmp	
  # Put all the files in a temporary subdirectory
  # which has the name that we want to have in the tar file.
! 	cd $(srcdir); mkdir tmp
! 	cd $(srcdir); mkdir tmp/config
! 	cd $(srcdir); mkdir tmp/ginclude
! 	cd $(srcdir); mkdir tmp/objc
! 	cd $(srcdir); \
!         for file in *[0-9a-zA-Z+]; do \
  	  ln $$file tmp > /dev/null 2>&1 || cp $$file tmp; \
  	done
! 	cd $(srcdir)/config; \
  	for file in *[0-9a-zA-Z+]; do \
! 	  if test -d $$file && test "$$file" != RCS && test "$$file" != CVS; then \
  	    mkdir ../tmp/config/$$file; \
  	    cd $$file; \
***************
*** 2324,2345 ****
  	  fi; \
  	done
! 	cd ginclude; \
  	for file in *[0-9a-zA-Z+]; do \
  	  ln $$file ../tmp/ginclude >/dev/null 2>&1 \
  	   || cp $$file ../tmp/ginclude; \
  	done
! 	cd objc; \
  	for file in *[0-9a-zA-Z+]; do \
  	  ln $$file ../tmp/objc >/dev/null 2>&1 || cp $$file ../tmp/objc; \
  	done
! 	ln .gdbinit tmp
  
  # Finish making `distdir', after the languages have done their thing.
  distdir-finish:
! 	mv tmp gcc-$(version)
  # Get rid of everything we don't want in the distribution.  We'd want
  # this to use Makefile.in, but it doesn't have the `lang.foo' targets
  # expanded.
! 	cd gcc-$(version); make extraclean
  
  distdir: distdir-start lang.distdir distdir-finish
--- 2348,2371 ----
  	  fi; \
  	done
! 	cd $(srcdir)/ginclude; \
  	for file in *[0-9a-zA-Z+]; do \
  	  ln $$file ../tmp/ginclude >/dev/null 2>&1 \
  	   || cp $$file ../tmp/ginclude; \
  	done
! 	cd $(srcdir)/objc; \
  	for file in *[0-9a-zA-Z+]; do \
  	  ln $$file ../tmp/objc >/dev/null 2>&1 || cp $$file ../tmp/objc; \
  	done
! 	cd $(srcdir); ln .gdbinit tmp
  
  # Finish making `distdir', after the languages have done their thing.
  distdir-finish:
! 	cd $(srcdir); mv tmp gcc-$(version)
  # Get rid of everything we don't want in the distribution.  We'd want
  # this to use Makefile.in, but it doesn't have the `lang.foo' targets
  # expanded.
! 	ln Makefile $(srcdir)/gcc-$(version) >/dev/null 2>&1 \
! 	    || cp Makefile $(srcdir)/gcc-$(version)
! 	cd $(srcdir)/gcc-$(version); make extraclean
  
  distdir: distdir-start lang.distdir distdir-finish
***************
*** 2349,2355 ****
  # The -P option assumes this is GNU diff.
  diff:
  	diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h \
  	  -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c \
! 	  -x TAGS \
  	  -x "gcc.??" -x "gcc.??s" -x gcc.aux -x "gcc.info*" \
  	  -x "cpp.??" -x "cpp.??s" -x cpp.aux -x "cpp.info*" \
--- 2375,2382 ----
  # The -P option assumes this is GNU diff.
  diff:
+ 	cd $(srcdir); \
  	diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h \
  	  -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c \
! 	  -x TAGS -x TAGS-c -x TAGS-h \
  	  -x "gcc.??" -x "gcc.??s" -x gcc.aux -x "gcc.info*" \
  	  -x "cpp.??" -x "cpp.??s" -x cpp.aux -x "cpp.info*" \
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/README gcc-2.7.2-t800.12/README
*** gcc-2.7.2/README	Sun Nov 26 22:55:29 1995
--- gcc-2.7.2-t800.12/README	Mon Apr 28 17:07:45 1997
***************
*** 1,3 ****
! This directory contains the version 2.7.2 release of the GNU C
  compiler.  It includes all of the support for compiling C++ and
  Objective C, including a run-time library for Objective C.
--- 1,3 ----
! This directory contains the version 2.7.2-t800.12 release of the GNU C
  compiler.  It includes all of the support for compiling C++ and
  Objective C, including a run-time library for Objective C.
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/README.T800 gcc-2.7.2-t800.12/README.T800
*** gcc-2.7.2/README.T800	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/README.T800	Mon Apr 28 17:05:51 1997
***************
*** 0 ****
--- 1,342 ----
+ Transputer backend overview
+ ---------------------------
+ 
+ Transputer backend is not part of GCC distribution yet; instead, it is
+ available as a patch against the "official" GCC 2.7.2 distribution
+ (gcc-2.7.2.tar.gz).
+ 
+ It allows one to build a cross compiler that runs on a host capable of
+ running GCC in general and produces transputer assembly language output.
+ 
+ 
+ Features and peculiarities
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
+  * SUPPORTED: code generation for most (all?) 32-bit transputers
+    (t800, t805, t425, t9000, t450)
+ 
+  * SUPPORTED: asm_operands.
+ 
+  * SUPPORTED: floating point instructions.  However, no attempt is
+    made to optimize ALU and FPU operation overlapping.
+ 
+  * UNSUPPORTED: debugging info output.  Just not ripe enough for now.
+ 
+  * UNSUPPORTED: nested functions (GNU extension to C).  You can work
+    around this limitation by using a preprocessor macro instead.
+ 
+  * if you want code quality to be any decent, compile with -O.  That's
+    because reload pass cannot do well for transputer without register
+    life info.
+ 
+ 
+ Run-time models supported
+ ~~~~~~~~~~~~~~~~~~~~~~~~~
+  There are currently two of them.  The first (generic) one is a
+ home-made model, hardly corresponding to any other model in existence.
+ In this model, no static chain is passed in function call; instead,
+ global data are addressed relative to program counter (Iptr).  First
+ three words of function arguments are passed on integer register
+ stack.  The benefits of this model are compact function prologues and
+ cheap function calls; on the other hand, it leaves no way to implement
+ a stack expansion scheme.
+ 
+ The binary tools (assembler, linker, etc.) for use with this model are
+ now available.  Check <http://www.botik.ru/~sizif/ttools/>, or
+ <ftp://ftp.botik.ru/pub/local/ttools>.  Some libraries are available
+ too -- thanks to Roman Pozlevich <roma@botik.ru>
+ 
+ The second model (Expert) is compatible with the one used by ACE
+ Expert compilers in the Parix OS.  The description of the model can be
+ found in the Parix documentation.
+ 
+ The two models are very different, and hopefully solve most problems
+ that might arise when porting GCC to other transputer-based platforms.
+ 
+ 
+ Transputer-specific compiler options
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ -mt800, -mt805, -mt425, -mt9000, -mt450
+ 
+    Run-time selection of target CPU type.  Default is the processor
+    type you give to configure when building the compiler.
+ 
+ -mfpu, -mno-fpu
+ -mfpentry, -mno-fpentry
+ -mfpge, -mno-fpge
+ -mpop, -mno-pop
+ -mgtu, -mno-gtu
+ -msixteen, -mno-sixteen
+ -mxtend, -mno-xtend
+ -mslmul, -mno-slmul
+ 
+    Switches that enable/disable use of certain CPU capabilities.  Each
+    of the -mtNNN target CPU selection options actually works by setting
+    certain combination of these.  Hope you don't want to fiddle with
+    them; but if you do, search config/t800.h for their meaning.
+ 
+ -mshort16, -mshort32
+ 
+    Size for the "short int" type in bits.  Default is 16 on transputers
+    that have support for 16-bit memory access (ls/ss), 32 on transputers
+    that don't have it.  Specifying -mshort16 in the latter case results in
+    implementation of halfword stores using shift and byte store instructions.
+ 
+ 
+ Random examples of inline assembly usage
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+   get_timer ()
+   {
+       int tmp;
+       asm volatile
+           ("ldtimer"
+ 	   : "=a" (tmp)
+ 	   : /* no inputs */ );
+       return tmp;
+   }
+ 
+ This asm takes no inputs, and pushes one word of result onto the
+ integer reg-stack, according to the `a' constraint.
+ 
+ Constraint letters meaning:
+ 
+  a,b,c	Areg,Breg,Creg respectively
+  t,v,u	FAreg, FBreg, FCreg respectively
+  P	popped input constraint modifier.
+ 
+ 
+ Example 2.
+ 
+   void
+   outword (unsigned word, unsigned chan)
+   {
+     asm volatile
+ 	("outword"
+          : /* no outputs */
+          : "bP" (chan), "aP" (word)
+          : "Areg", "Breg", "Creg", "FAreg", "FBreg", "FCreg", "Wreg[0]");
+   }
+ 
+ This asm consumes two inputs which come in Areg and Breg.  The
+ modifier constraint `P' indicates that the input is popped off the
+ stack by the asm.  The clobber section indicates that the asm clobbers
+ all stack registers.
+ 
+ "Wreg[0]" in the clobber section indicates that this asm destroys the
+ value of the word at the top of workspace.  Note that "Wreg[0]" is
+ just an identifier; you cannot write, say, "Wreg[1]" here.
+ 
+ Note that popping constraint is not a substitute for a clobber; thus,
+ following asm would not reflect the fact that all registers are
+ clobbered by this asm (and so is incorrect):
+ 
+   void
+   outword (unsigned word, unsigned chan)
+   {
+     asm volatile
+ 	("outword"
+          : /* no outputs */
+          : "bP" (chan), "aP" (word)
+          : "Creg", "FAreg", "FBreg", "FCreg", "Wreg[0]");
+   }
+ 
+ 
+ Example 3.
+ 
+   float
+   square_root (float x)
+   {
+     register float tmp;
+ 
+     asm ("fpusqrtfirst\n\t"
+          "fpusqrtstep\n\t"
+          "fpusqrtstep\n\t"
+          "fpusqrtlast"
+          : "=t" (tmp)
+          : "tP" (x)
+          : "FBreg", "FCreg");
+ 
+     return tmp;
+   }
+ 
+ This asm pops its input off floating reg-stack, and pushes the result
+ back onto the floating reg-stack.
+ 
+ 
+ Example 4, from real life
+ 
+   static inline int
+   lit_load_in_byte (void)
+   {
+       int tmp = 0;
+       extern int boot_link_in;
+   
+       asm volatile
+           ("in"
+            : /* no outputs */
+            : "cP" (&tmp),
+              "bP" (boot_link_in),
+              "aP" (1)
+            : "Areg", "Breg", "Creg", "FAreg", "FBreg", "FCreg", "memory");
+   
+       return tmp;
+   }
+ 
+ Here the asm inputs a byte from a link whose address is stored in
+ `boot_link_in'.  Note that this asm has no explicit outputs, but puts
+ its result into memory (the `tmp' variable) as a side-effect.  You
+ have to explicitly tell the compiler that the asm modifies memory;
+ that's what the "memory" in the clobber section of the asm is for.
+ Without it, the optimiser would rightfully optimize this function to
+ always return 0.
+ 
+ Note that the order of input operands in asms matters: supplying the
+ operands in reverse order (Creg, Breg, Areg), as in the above asm,
+ tends to give better code.
+ 
+ 
+ 
+ 
+ One more example, making use of local temporary variable
+ (from Roman Pozlevich, <roma@botik.ru>):
+ 
+ int *alt (int* first, ...) {
+     int *res, **ptr;
+ 
+     __asm__ __volatile__ (
+ 	"  alt                           \n\t"
+ 	"  ldlp %w2; stl %w1             \n\t" 
+         "0:                              \n\t"
+         "  ldl %w1; ldnl 0; cj 1f        \n\t"
+         "  ldl %w1; ldnl 0; ldc 1; enbc  \n\t"
+         "  ldl %w1; ldnlp 1; stl %w1     \n\t"
+         "  ldc 0; cj 0b                  \n\t"
+         "1:                              \n\t"
+         "  altwt                         \n\t"
+ 	"  ldlp %w2; stl %w1             \n\t" 
+         "0:                              \n\t"
+         "  ldl %w1; ldnl 0; cj 1f        \n\t"
+         "  ldl %w1; ldnl 0; dup; ldc 1; rev; disc \n\t"
+ 	"  eqc 0; cj 1f                  \n\t"
+         "  ldl %w1; ldnlp 1; stl %w1     \n\t"
+         "  ldc 0; cj 0b                  \n\t"
+         "1:                              \n\t"
+ 	"  ldl 0                         \n\t"
+ 
+ 	: "=a" (res)
+ 	: "m" (ptr), "m" (first)
+ 	: "Breg", "Creg", "FAreg", "FBreg", "FCreg", "Wreg[0]"
+     );
+ 
+     return res;
+ }
+ 
+ You most likely don't want to understand what this code is doing, but
+ note the use of "m" constraint for local variables, and the use of
+ "%wN" to obtain stack offset in words for Nth operand of the asm.
+ 
+ 
+ Where to get T800 patches
+ ~~~~~~~~~~~~~~~~~~~~~~~~~
+  The most recent version is always at
+ 
+   ftp://ftp.botik.ru/pub/local/gcc-t800/gcc-2.7.2
+ 
+ The port as a diff against gcc-2.7.2 is in the file
+ gcc-2.7.2-t800.NNN.dif.gz, where NNN is the alpha release number.
+ You most probably want to pick the largest numbered one.
+ 
+ patchNNN.gz contains patches from alpha release MMM to alpha release
+ NNN, where MMM=NNN-1.  changesNNN contain a short overview of the
+ changes.
+ 
+ You can also find gcc-t800 at the mirror in UK:
+ 
+   ftp://unix.hensa.ac.uk/pub/parallel/transputer/software/compilers/gcc/pereslavl/
+   http://www.hensa.ac.uk/parallel/transputer/software/compilers/gcc/pereslavl/
+ 
+ 
+ Feedback
+ ~~~~~~~~
+  Please e-mail bug reports to me at <sizif@botik.ru>.
+ 
+  DO NOT send any bug reports for gcc-t800 to the GNU bug-gcc list
+ where GCC bugs normally go; gcc-t800 is not yet an official part of
+ GCC.
+ 
+  There is a (mostly inactive) mailing list for gcc-t800:
+ <gcc-t800@botik.ru>.  If you want to subscribe to the list, send
+ e-mail with a line like this:
+ 
+   subscribe <YOUR-INTERNET-ADDRESS>
+ 
+ to <gcc-t800-request@botik.ru>.
+ 
+ 
+ Installation
+ ~~~~~~~~~~~~
+  (1) Apply T800 patches to the stock GCC distribution:
+ 
+ 	cd gcc-2.7.2
+ 	gzip -dc gcc-2.7.2-t800.12.dif.gz | patch -p1
+ 
+  (2) Configure the sources for the target of your choice.
+ 
+      Example 1: configure for `generic' model.  This is what you need
+         if you are going to use gcc-t800 with TTOOLS.
+ 
+ 	./configure --target=t800
+ 
+         Note: this chooses t800 as the default CPU type.  You can
+         however use the compiler thus built for other cpu types
+         by running `gcc -mt425', for example.
+ 
+      Example 2: configure for `expert' model
+ 
+ 	./configure --target=t800-parix
+ 	
+      Example 3: configure for `expert' model, install in a private
+                 directory rather than in /usr/local
+   
+ 	./configure --target=t800-parix --prefix=$(HOME)/usr
+ 
+  (3) If you are impatient and want to try it out quickly, do
+ 
+ 	make LANGUAGES=c CC=gcc cc1
+ 	cc1 -O pself.c
+ 	more pself.s
+ 
+  (4) Follow the normal procedure for building and installing a cross
+      compiler, described in INSTALL.  In short, the following might work:
+ 
+ 	<make sure transputer as,ld,ar are installed in PREFIX/t800/bin>
+ 	make LANGUAGES=c CC=gcc
+ 	make install
+ 
+      While making, you will see warnings about `-g' and `-g1' options
+      being unsupported by the compiler -- indeed, debugging info
+      output is not yet supported.  Ignore the warnings.
+ 
+ 
+ Acknowledgements
+ ~~~~~~~~~~~~~~~~
+  FSF people provided the World with the GNU C Compiler.
+ 
+  Sergei Abramov enabled me to work on this port.
+ 
+  Kriton Kyrimis of High Performance Computing Laboratory, Athens,
+  inspired the port to Parix/GCel, and helped to work on it.
+ 
+  This work was in part supported by INTAS--International Association
+  for the promotion of cooperation with scientists from the independent
+  states of the former Soviet Union; grant # INTAS-93-0972
+ 
+  Dave Beckett <D.J.Beckett@ukc.ac.uk> easies life to the downloaders
+  of the package by mirroring gcc-t800 and TTOOLS at unix.hensa.ac.uk.
+  
+ 
+  Thanks to all.
+ 
+ 
+ 
+ 
+ $Revision: 1.17 $
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/caller-save.c gcc-2.7.2-t800.12/caller-save.c
*** gcc-2.7.2/caller-save.c	Tue Jun 20 00:29:46 1995
--- gcc-2.7.2-t800.12/caller-save.c	Mon Jan 22 11:36:20 1996
***************
*** 764,768 ****
--- 764,788 ----
    insn = emit_insn_before (pat, insn);
    PUT_MODE (insn, insn_mode);
+ 
+ #if 1
+ 
+   /* I don't understand the comment at this function's start regarding
+      the necessity of this code setting.  But what I see is that insn
+      generated here pops up with incorrect code (t800: stnl while the
+      pattern suggests stl) later in reg-stack pass.  The code turns
+      out incorrect because init_caller_save builds a trial insn
+      pattern on a lowest numbered register from BASE_REG_CLASS (==
+      Areg), which matches stnl.  Whereas the actual insn built using
+      regno_save_mem saves to (MEM (PLUS (REG Wreg) (CONST_INT))),
+      which should match stl.
+ 
+      I don't know what would be the right (machine-independent) way to
+      fix this.  The simplest move is not to set INSN_CODE here,
+      allowing the insn to be recognized in the regular way.  If the
+      recognition ever fails, we'll see why and what to do about it.  */
+ 
+ #else
    INSN_CODE (insn) = code;
+ #endif
  
    /* Tell our callers how many extra registers we saved/restored */
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/calls.c gcc-2.7.2-t800.12/calls.c
*** gcc-2.7.2/calls.c	Fri Oct 27 04:53:24 1995
--- gcc-2.7.2-t800.12/calls.c	Mon Jan 22 11:36:21 1996
***************
*** 995,998 ****
--- 995,1041 ----
  #endif
  
+ #ifdef FUNCTION_ARG_PRESCAN
+   /* On some machines (T800, for one) FUNCTION_ARG needs info on all
+      the arguments, not only on the ones so far.  Run through the
+      arguments calling a machine-dependent macro to collect all
+      the necessary information and store it in CUMULATIVE_ARGS.  */
+ 
+   for (p = actparms, argpos = 0; p; p = TREE_CHAIN (p), argpos++)
+     {
+       tree type = TREE_TYPE (TREE_VALUE (p));
+       enum machine_mode mode;
+       tree tree_value = TREE_VALUE (p);
+ 
+       /* Replace erroneous argument with constant zero.  */
+       if (type == error_mark_node || TYPE_SIZE (type) == 0)
+ 	tree_value = integer_zero_node, type = integer_type_node;
+ 
+       mode = TYPE_MODE (type);
+ 
+ #ifdef FUNCTION_ARG_PASS_BY_REFERENCE
+       /* See if this argument should be passed by invisible reference.  */
+       if (FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, mode, type,
+                                           argpos < n_named_args))
+         mode = Pmode;
+ #endif
+ 
+ #ifdef PROMOTE_FUNCTION_ARGS
+       /* Compute the mode in which the arg is actually to be extended to.  */
+       if (TREE_CODE (type) == INTEGER_TYPE || TREE_CODE (type) == ENUMERAL_TYPE
+ 	  || TREE_CODE (type) == BOOLEAN_TYPE || TREE_CODE (type) == CHAR_TYPE
+ 	  || TREE_CODE (type) == REAL_TYPE || TREE_CODE (type) == POINTER_TYPE
+ 	  || TREE_CODE (type) == OFFSET_TYPE)
+ 	{
+ 	  int unsignedp = TREE_UNSIGNED (type);
+ 	  PROMOTE_MODE (mode, unsignedp, type);
+ 	}
+ #endif
+ 
+       FUNCTION_ARG_PRESCAN (args_so_far, mode, type, argpos < n_named_args);
+     }
+ 
+     RESET_CUMULATIVE_ARGS (args_so_far, funtype, NULL_RTX);
+ #endif /* FUNCTION_ARG_PRESCAN */
+ 
    /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */
    for (p = actparms, argpos = 0; p; p = TREE_CHAIN (p), i += inc, argpos++)
***************
*** 2258,2262 ****
    CUMULATIVE_ARGS args_so_far;
    struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;
! 	       struct args_size offset; struct args_size size; };
    struct arg *argvec;
    int old_inhibit_defer_pop = inhibit_defer_pop;
--- 2301,2305 ----
    CUMULATIVE_ARGS args_so_far;
    struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;
! 	       struct args_size offset; struct args_size size; rtx save_area; };
    struct arg *argvec;
    int old_inhibit_defer_pop = inhibit_defer_pop;
***************
*** 2265,2268 ****
--- 2308,2316 ----
    int current_call_is_indirect = 0;
  
+ #ifdef ACCUMULATE_OUTGOING_ARGS
+   int initial_highest_arg_in_use = highest_outgoing_arg_in_use;
+   char *initial_stack_usage_map = stack_usage_map;
+ #endif
+ 
    VA_START (p, nargs);
  
***************
*** 2372,2378 ****
--- 2420,2429 ----
  	 restore the arg slot.  */
  
+ #if 0 /* Had to add the code mentioned because functions like _cmpdi2
+          take more arguments than can be put in registers on T800.  */
        if (argvec[count].reg == 0 || argvec[count].partial != 0)
  	abort ();
  #endif
+ #endif
  
        FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree)0, 1);
***************
*** 2402,2405 ****
--- 2453,2483 ----
  
  #ifdef ACCUMULATE_OUTGOING_ARGS
+   {
+     int needed = args_size.constant;
+ 
+ #if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)
+       /* Since we will be writing into the entire argument area, the
+ 	 map must be allocated for its entire size, not just the part that
+ 	 is the responsibility of the caller.  */
+       needed += REG_PARM_STACK_SPACE (NULL_TREE);
+ #endif
+ 
+ #ifdef ARGS_GROW_DOWNWARD
+       highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,
+ 					 needed + 1);
+ #else
+       highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use, needed);
+ #endif
+       stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);
+ 
+       if (initial_highest_arg_in_use)
+ 	bcopy (initial_stack_usage_map, stack_usage_map,
+ 	       initial_highest_arg_in_use);
+ 
+       if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)
+ 	bzero (&stack_usage_map[initial_highest_arg_in_use],
+ 	       highest_outgoing_arg_in_use - initial_highest_arg_in_use);
+   }
+ 
    args_size.constant = 0;
  #endif
***************
*** 2419,2422 ****
--- 2497,2507 ----
  #endif
  
+ #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)
+   /* The argument list is the property of the called routine and it
+      may clobber it.  If the fixed area has been used for previous
+      parameters, we must save and restore it.  */
+   abort ();
+ #endif
+ 
  #ifdef PUSH_ARGS_REVERSED
    inc = -1;
***************
*** 2436,2439 ****
--- 2521,2571 ----
        int partial = argvec[argnum].partial;
  
+ #ifdef ACCUMULATE_OUTGOING_ARGS
+       /* If this is being stored into a pre-allocated, fixed-size, stack area,
+          save any previous data at that location.  */
+       argvec[argnum].save_area = NULL_RTX;
+       if (argblock && ! (reg != 0 && partial == 0))
+         {
+ #ifdef ARGS_GROW_DOWNWARD
+           /* offset is negative, but we want to index stack_usage_map */
+           /* with positive values. */
+           int upper_bound = -argvec[count].offset.constant + 1;
+           int lower_bound = upper_bound - argvec[count].size.constant;
+ #else
+           int lower_bound = argvec[count].offset.constant;
+           int upper_bound = lower_bound + argvec[count].size.constant;
+ #endif
+           int i;
+ 
+           for (i = lower_bound; i < upper_bound; i++)
+             if (stack_usage_map[i]
+ #ifdef REG_PARM_STACK_SPACE
+               /* Don't store things in the fixed argument area at this point;
+                  it has already been saved.  */
+                 && i > reg_parm_stack_space
+ #endif
+ 	      )
+ 	      break;
+ 
+           if (i != upper_bound)
+ 	    {
+ 	      /* We need to make a save area.  See what mode we can make it.  */
+ 	      enum machine_mode save_mode
+ 	        = mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,
+                                  MODE_INT, 1);
+ 	      rtx stack_area = gen_rtx (MEM, save_mode,
+                 memory_address (save_mode,
+                   plus_constant (argblock, argvec[argnum].offset.constant)));
+ 
+ 	      if (save_mode == BLKmode)
+ 	        abort ();
+ 	      else
+ 	        {
+ 	          argvec[argnum].save_area = gen_reg_rtx (save_mode);
+ 	          emit_move_insn (argvec[argnum].save_area, stack_area);
+ 	        }
+ 	    }
+         }
+ #endif
        if (! (reg != 0 && partial == 0))
  	emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,
***************
*** 2481,2485 ****
    for (count = 0; count < nargs; count++)
      if (argvec[count].reg != 0)
!        use_reg (&call_fusage, argvec[count].reg);
  
    /* Don't allow popping to be deferred, since then
--- 2613,2620 ----
    for (count = 0; count < nargs; count++)
      if (argvec[count].reg != 0)
!       if (argvec[count].partial == 0)
!         use_reg (&call_fusage, argvec[count].reg);
!       else
!         use_regs (&call_fusage, REGNO (argvec[count].reg), argvec[count].partial);
  
    /* Don't allow popping to be deferred, since then
***************
*** 2501,2504 ****
--- 2636,2658 ----
    /* Now restore inhibit_defer_pop to its actual original value.  */
    OK_DEFER_POP;
+ 
+ #ifdef ACCUMULATE_OUTGOING_ARGS
+   /* If we saved any argument areas, restore them.  */
+   for (count = 0; count < nargs; count++)
+     if (argvec[count].save_area)
+       {
+         enum machine_mode save_mode = GET_MODE (argvec[count].save_area);
+         rtx stack_area = gen_rtx (MEM, save_mode, memory_address (save_mode,
+            plus_constant (argblock, argvec[count].offset.constant)));
+ 
+         if (save_mode != BLKmode)
+           emit_move_insn (stack_area, argvec[count].save_area);
+         else
+           abort ();
+       }
+ 
+   highest_outgoing_arg_in_use = initial_highest_arg_in_use;
+   stack_usage_map = initial_stack_usage_map;
+ #endif
  }
  
***************
*** 2534,2538 ****
    CUMULATIVE_ARGS args_so_far;
    struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;
! 	       struct args_size offset; struct args_size size; };
    struct arg *argvec;
    int old_inhibit_defer_pop = inhibit_defer_pop;
--- 2688,2692 ----
    CUMULATIVE_ARGS args_so_far;
    struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;
! 	       struct args_size offset; struct args_size size; rtx save_area; };
    struct arg *argvec;
    int old_inhibit_defer_pop = inhibit_defer_pop;
***************
*** 2545,2548 ****
--- 2699,2707 ----
    int is_const;
  
+ #ifdef ACCUMULATE_OUTGOING_ARGS
+   int initial_highest_arg_in_use = highest_outgoing_arg_in_use;
+   char *initial_stack_usage_map = stack_usage_map;
+ #endif
+ 
    VA_START (p, nargs);
  
***************
*** 2722,2728 ****
--- 2881,2890 ----
  	 restore the arg slot.  */
  
+ #if 0 /* Had to add the code mentioned because functions like _cmpdi2
+          take more arguments then can be put in registers on T800.  */
        if (argvec[count].reg == 0 || argvec[count].partial != 0)
  	abort ();
  #endif
+ #endif
  
        FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree)0, 1);
***************
*** 2752,2755 ****
--- 2914,2944 ----
  
  #ifdef ACCUMULATE_OUTGOING_ARGS
+   {
+     int needed = args_size.constant;
+ 
+ #if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)
+       /* Since we will be writing into the entire argument area, the
+ 	 map must be allocated for its entire size, not just the part that
+ 	 is the responsibility of the caller.  */
+       needed += REG_PARM_STACK_SPACE (NULL_TREE);
+ #endif
+ 
+ #ifdef ARGS_GROW_DOWNWARD
+       highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,
+ 					 needed + 1);
+ #else
+       highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use, needed);
+ #endif
+       stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);
+ 
+       if (initial_highest_arg_in_use)
+ 	bcopy (initial_stack_usage_map, stack_usage_map,
+ 	       initial_highest_arg_in_use);
+ 
+       if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)
+ 	bzero (&stack_usage_map[initial_highest_arg_in_use],
+ 	       highest_outgoing_arg_in_use - initial_highest_arg_in_use);
+   }
+ 
    args_size.constant = 0;
  #endif
***************
*** 2769,2772 ****
--- 2958,2968 ----
  #endif
  
+ #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)
+   /* The argument list is the property of the called routine and it
+      may clobber it.  If the fixed area has been used for previous
+      parameters, we must save and restore it.  */
+   abort ();
+ #endif
+ 
  #ifdef PUSH_ARGS_REVERSED
    inc = -1;
***************
*** 2786,2789 ****
--- 2982,3032 ----
        int partial = argvec[argnum].partial;
  
+ #ifdef ACCUMULATE_OUTGOING_ARGS
+       /* If this is being stored into a pre-allocated, fixed-size, stack area,
+          save any previous data at that location.  */
+       argvec[argnum].save_area = NULL_RTX;
+       if (argblock && ! (reg != 0 && partial == 0))
+         {
+ #ifdef ARGS_GROW_DOWNWARD
+           /* offset is negative, but we want to index stack_usage_map */
+           /* with positive values. */
+           int upper_bound = -argvec[count].offset.constant + 1;
+           int lower_bound = upper_bound - argvec[count].size.constant;
+ #else
+           int lower_bound = argvec[count].offset.constant;
+           int upper_bound = lower_bound + argvec[count].size.constant;
+ #endif
+           int i;
+ 
+           for (i = lower_bound; i < upper_bound; i++)
+             if (stack_usage_map[i]
+ #ifdef REG_PARM_STACK_SPACE
+               /* Don't store things in the fixed argument area at this point;
+                  it has already been saved.  */
+                 && i > reg_parm_stack_space
+ #endif
+ 	      )
+ 	      break;
+ 
+           if (i != upper_bound)
+ 	    {
+ 	      /* We need to make a save area.  See what mode we can make it.  */
+ 	      enum machine_mode save_mode
+ 	        = mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,
+                                  MODE_INT, 1);
+ 	      rtx stack_area = gen_rtx (MEM, save_mode,
+                 memory_address (save_mode,
+                   plus_constant (argblock, argvec[argnum].offset.constant)));
+ 
+ 	      if (save_mode == BLKmode)
+ 	        abort ();
+ 	      else
+ 	        {
+ 	          argvec[argnum].save_area = gen_reg_rtx (save_mode);
+ 	          emit_move_insn (argvec[argnum].save_area, stack_area);
+ 	        }
+ 	    }
+         }
+ #endif
        if (! (reg != 0 && partial == 0))
  	emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,
***************
*** 2833,2837 ****
    for (count = 0; count < nargs; count++)
      if (argvec[count].reg != 0)
!        use_reg (&call_fusage, argvec[count].reg);
  
    /* Pass the function the address in which to return a structure value.  */
--- 3076,3083 ----
    for (count = 0; count < nargs; count++)
      if (argvec[count].reg != 0)
!       if (argvec[count].partial == 0)
!         use_reg (&call_fusage, argvec[count].reg);
!       else
!         use_regs (&call_fusage, REGNO (argvec[count].reg), argvec[count].partial);
  
    /* Pass the function the address in which to return a structure value.  */
***************
*** 2880,2885 ****
--- 3126,3171 ----
  	emit_move_insn (value, hard_libcall_value (outmode));
        else
+ #ifndef ACCUMULATE_OUTGOING_ARGS
  	value = hard_libcall_value (outmode);
+ #else
+         {
+ 	  /* If we are going to restore saved arguments areas, we
+ 	     should copy the hard value reg to a pseudo before
+ 	     emitting any restoration insns.  Because no insn (save
+ 	     stack adjustment) should come between call insn and the
+ 	     insn which uses the call value -- this is important for
+ 	     code computing avoid_return_reg in reload1.c (at least). */
+ 
+ 	  for (count = 0; count < nargs; count++)
+ 	    if (argvec[count].save_area)
+ 	      {
+ 		value = gen_reg_rtx (outmode);
+ 		emit_move_insn (value, hard_libcall_value (outmode));
+ 		break;
+ 	      }
+ 	  if (value == 0)
+ 	    value = hard_libcall_value (outmode);
+ 	}
+ #endif
      }
+ 
+ #ifdef ACCUMULATE_OUTGOING_ARGS
+   /* If we saved any argument areas, restore them.  */
+   for (count = 0; count < nargs; count++)
+     if (argvec[count].save_area)
+       {
+         enum machine_mode save_mode = GET_MODE (argvec[count].save_area);
+         rtx stack_area = gen_rtx (MEM, save_mode, memory_address (save_mode,
+            plus_constant (argblock, argvec[count].offset.constant)));
+ 
+         if (save_mode != BLKmode)
+           emit_move_insn (stack_area, argvec[count].save_area);
+         else
+           abort ();
+       }
+ 
+   highest_outgoing_arg_in_use = initial_highest_arg_in_use;
+   stack_usage_map = initial_stack_usage_map;
+ #endif
  
    return value;
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/combine.c gcc-2.7.2-t800.12/combine.c
*** gcc-2.7.2/combine.c	Sun Nov 26 22:31:48 1995
--- gcc-2.7.2-t800.12/combine.c	Mon Jan 22 11:36:22 1996
***************
*** 102,105 ****
--- 102,110 ----
  #define gen_lowpart dont_use_gen_lowpart_you_dummy
  
+ #ifndef ABSENT_INSN_CODE
+ #define ABSENT_INSN_CODE(CODE)  ((CODE) == CODE_FOR_nothing)
+ #endif
+ 
+ 
  /* Number of attempts to combine instructions in this function.  */
  
***************
*** 9645,9654 ****
    if (mode != VOIDmode && GET_MODE_CLASS (mode) == MODE_INT
        && GET_MODE_SIZE (mode) < UNITS_PER_WORD
!       && cmp_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)
      for (tmode = GET_MODE_WIDER_MODE (mode);
  	 (tmode != VOIDmode
  	  && GET_MODE_BITSIZE (tmode) <= HOST_BITS_PER_WIDE_INT);
  	 tmode = GET_MODE_WIDER_MODE (tmode))
!       if (cmp_optab->handlers[(int) tmode].insn_code != CODE_FOR_nothing)
  	{
  	  /* If the only nonzero bits in OP0 and OP1 are those in the
--- 9650,9659 ----
    if (mode != VOIDmode && GET_MODE_CLASS (mode) == MODE_INT
        && GET_MODE_SIZE (mode) < UNITS_PER_WORD
!       && ABSENT_INSN_CODE (cmp_optab->handlers[(int) mode].insn_code))
      for (tmode = GET_MODE_WIDER_MODE (mode);
  	 (tmode != VOIDmode
  	  && GET_MODE_BITSIZE (tmode) <= HOST_BITS_PER_WIDE_INT);
  	 tmode = GET_MODE_WIDER_MODE (tmode))
!       if (! ABSENT_INSN_CODE (cmp_optab->handlers[(int) tmode].insn_code))
  	{
  	  /* If the only nonzero bits in OP0 and OP1 are those in the
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/config/t800/expert.h gcc-2.7.2-t800.12/config/t800/expert.h
*** gcc-2.7.2/config/t800/expert.h	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/config/t800/expert.h	Sat Nov 23 12:50:09 1996
***************
*** 0 ****
--- 1,1473 ----
+ /* Definitions of target machine for GNU compiler for INMOS transputer,
+    ACE EXPERT Transputer Runtime Model.
+    Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
+ 
+    Written by Yury Shevchuk <sizif@botik.ru>
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ 
+ /* Include generic definitions for transputer family.  A number of
+    macros are redefined in this file as needed for the Expert model. */
+ 
+ #include "t800/t800.h"
+ 
+ 
+ /*************************************************************
+  Controlling the Compilation Driver, @file{gcc}
+ *************************************************************/
+ 
+ /*>#define SWITCH_TAKES_ARG (char) */
+ /*>#define WORD_SWITCH_TAKES_ARG (name) */
+ 
+ #undef SWITCHES_NEED_SPACES
+ #undef CPP_SPEC
+ #undef NO_BUILTIN_SIZE_TYPE
+ #undef NO_BUILTIN_PTRDIFF_TYPE
+ #undef SIGNED_CHAR_SPEC
+ #undef CC1_SPEC
+ #undef CC1PLUS_SPEC
+ #undef ASM_SPEC
+ #undef ASM_FINAL_SPEC
+ #undef LINK_SPEC
+ 
+ #undef LIB_SPEC
+ #define LIB_SPEC  "-F -lm -lanc -lc -lm -lcrt -lOS"
+ #undef STARTFILE_SPEC
+ #define STARTFILE_SPEC  "ldfile_n%s crt0.o%s"
+ 
+ #undef ENDFILE_SPEC
+ #undef LINK_LIBGCC_SPECIAL
+ #undef LINK_LIBGCC_SPECIAL_1
+ #undef RELATIVE_PREFIX_NOT_LINKDIR
+ 
+ /* This is passed via -D when compiling gcc.o, so we shoudn't #undef it */
+ /* #undef STANDARD_EXEC_PREFIX */
+ 
+ #undef MD_EXEC_PREFIX
+ 
+ /* This is passed via -D when compiling gcc.o, so we shoudn't #undef it */
+ /* #undef STANDARD_STARTFILE_PREFIX */
+ 
+ #undef MD_STARTFILE_PREFIX
+ #undef MD_STARTFILE_PREFIX_1
+ #undef LOCAL_INCLUDE_DIR
+ #undef SYSTEM_INCLUDE_DIR
+ #undef STANDARD_INCLUDE_DIR
+ #undef INCLUDE_DEFAULTS
+ 
+ 
+ /*************************************************************
+  Run-time Target Specification
+ *************************************************************/
+ 
+ #undef CPP_PREDEFINES
+ #define CPP_PREDEFINES "-D__t800__ -Dunix"
+ 
+ /*>#define STDC_VALUE */
+ /*>extern int target_flags; */
+ 
+ /* Prologue should include stack extension stuff */
+ #define MASK_STACK_EXTEND	(010000000000)
+ #define TARGET_STACK_EXTEND	(target_flags & MASK_STACK_EXTEND)
+ 
+ /*>#define TARGET_SWITCHES */
+ /*>#define TARGET_OPTIONS */
+ 
+ #undef SUBTARGET_SWITCHES
+ #define SUBTARGET_SWITCHES \
+   {"stack-extend",	 MASK_STACK_EXTEND},	\
+   {"no-stack-extend",	-MASK_STACK_EXTEND},	\
+ 
+ #undef SUBTARGET_SWITCHES_DEFAULT
+ #define SUBTARGET_SWITCHES_DEFAULT \
+   (MASK_STACK_EXTEND | MASK_SHORT16)
+ 
+ #undef TARGET_VERSION
+ #define TARGET_VERSION fprintf (stderr, " (T800, ACE syntax)");
+ 
+ #define OVERRIDE_OPTIONS \
+   do {							\
+     target_flags &= ~MASK_DATASEG_PC_RELATIVE;	\
+   } while (0)
+ 
+ /*>#define OPTIMIZATION_OPTIONS (level) */
+ /*>#define CAN_DEBUG_WITHOUT_FP */
+ 
+ 
+ /*************************************************************
+  Storage Layout
+ *************************************************************/
+ 
+ /*>#define BITS_BIG_ENDIAN */
+ /*>#define BYTES_BIG_ENDIAN */
+ /*>#define WORDS_BIG_ENDIAN */
+ /*>#define FLOAT_WORDS_BIG_ENDIAN */
+ /*>#define BITS_PER_UNIT */
+ /*>#define BITS_PER_WORD */
+ /*>#define MAX_BITS_PER_WORD */
+ /*>#define UNITS_PER_WORD */
+ /*>#define MAX_UNITS_PER_WORD */
+ /*>#define POINTER_SIZE */
+ 
+ /* ACE compiler is known to promote arguments to word, just like the
+    generic description does.  Not sure about return values... */
+ 
+ /*>#define PROMOTE_MODE (m, unsignedp, type) */
+ /*>#define PROMOTE_FUNCTION_ARGS */
+ /*>#define PROMOTE_FUNCTION_RETURN */
+ /*>#define PROMOTE_FOR_CALL_ONLY */
+ 
+ /*>#define PARM_BOUNDARY */
+ /*>#define STACK_BOUNDARY */
+ 
+ #undef FUNCTION_BOUNDARY
+ #define FUNCTION_BOUNDARY  BITS_PER_WORD
+ 
+ /*>#define BIGGEST_ALIGNMENT */
+ /*>#define BIGGEST_FIELD_ALIGNMENT */
+ /*?#define MAX_OFILE_ALIGNMENT */
+ /*>#define DATA_ALIGNMENT (type, basic-align) */
+ /*>#define CONSTANT_ALIGNMENT (constant, basic-align) */
+ /*>#define EMPTY_FIELD_BOUNDARY */
+ /*>#define STRUCTURE_SIZE_BOUNDARY */
+ /*>#define STRICT_ALIGNMENT */
+ /*>#define PCC_BITFIELD_TYPE_MATTERS */
+ /*>#define BITFIELD_NBYTES_LIMITED */
+ /*>#define ROUND_TYPE_SIZE (struct, size, align) */
+ /*>#define ROUND_TYPE_ALIGN (struct, computed, specified) */
+ /*>#define MAX_FIXED_MODE_SIZE */
+ /*>#define CHECK_FLOAT_VALUE (mode, value, overflow) */
+ /*>#define TARGET_FLOAT_FORMAT */
+ 
+ 
+ /*************************************************************
+  Layout of Source Language Data Types
+ *************************************************************/
+ 
+ /* #define INT_TYPE_SIZE */
+ /* #define MAX_INT_TYPE_SIZE */
+ 
+ /* Generic description uses 32-bit short for simplicity (for now at
+    least), but ACE assumes short is 16-bit.  t9000 has support for 16
+    bit loads/stores, but t4/t8 has not, so this will be costly...  */
+ 
+ #undef SHORT_TYPE_SIZE
+ #define SHORT_TYPE_SIZE  (BITS_PER_WORD/2)
+ 
+ /*>#define LONG_TYPE_SIZE */
+ /*>#define MAX_LONG_TYPE_SIZE */
+ /*>#define LONG_LONG_TYPE_SIZE */
+ /*>#define CHAR_TYPE_SIZE */
+ /*>#define MAX_CHAR_TYPE_SIZE */
+ /*>#define FLOAT_TYPE_SIZE */
+ /*>#define DOUBLE_TYPE_SIZE */
+ /*>#define LONG_DOUBLE_TYPE_SIZE */
+ 
+ #undef DEFAULT_SIGNED_CHAR
+ #define DEFAULT_SIGNED_CHAR  1
+ 
+ /*>?#define DEFAULT_SHORT_ENUMS */
+ 
+ /* This is consistent with /home/parix/include/sys/size_t.h */
+ #undef SIZE_TYPE
+ #define SIZE_TYPE  "unsigned int"
+ 
+ /* This is consistent with /home/parix/include/stddef.h */
+ #undef PTRDIFF_TYPE
+ #define PTRDIFF_TYPE  "int"
+ 
+ /* This is consistent with /home/parix/include/sys/wchar_t.h */
+ #undef WCHAR_TYPE
+ #define WCHAR_TYPE  "char"
+ 
+ #undef WCHAR_TYPE_SIZE
+ #define WCHAR_TYPE_SIZE  8
+ 
+ /*>#define MAX_WCHAR_TYPE_SIZE */
+ /*>#define OBJC_INT_SELECTORS */
+ /*>#define OBJC_SELECTORS_WITHOUT_LABELS */
+ 
+ /*>#define TARGET_BELL */
+ /*>#define TARGET_BS */
+ /*>#define TARGET_TAB */
+ /*>#define TARGET_NEWLINE */
+ /*>#define TARGET_VT */
+ /*>#define TARGET_FF */
+ /*>#define TARGET_CR */
+ 
+ 
+ /*************************************************************
+  Register Usage
+ *************************************************************/
+ 
+ 
+ /*** Basic Characteristics of Registers ********************/
+ 
+ /*>#define FIRST_PSEUDO_REGISTER */
+ /*>#define FIXED_REGISTERS */
+ /*>#define CALL_USED_REGISTERS */
+ /*>#define CONDITIONAL_REGISTER_USAGE */
+ /*>?#define NON_SAVING_SETJMP */
+ /*>#define INCOMING_REGNO (out) */
+ /*>#define OUTGOING_REGNO (in) */
+ 
+ /*** Order of Allocation of Registers **********************/
+ 
+ /*>#define REG_ALLOC_ORDER */
+ /*>#define ORDER_REGS_FOR_LOCAL_ALLOC */
+ 
+ /*** How Values Fit in Registers ***************************/
+ 
+ /*>#define HARD_REGNO_NREGS (regno, mode) */
+ /*>#define HARD_REGNO_MODE_OK (regno, mode) */
+ /*>#define MODES_TIEABLE_P (mode1, mode2) */
+ 
+ /*** Handling Leaf Functions *******************************/
+ 
+ /*?#define LEAF_REGISTERS */
+ /*?#define LEAF_REG_REMAP (regno) */
+ 
+ /*** Registers That Form a Stack ***************************/
+ 
+ /*>#define STACK_REGS */
+ /*>#define FIRST_STACK_REG */
+ /*>#define LAST_STACK_REG */
+ 
+ /*** Obsolete Macros for Controlling Register Usage ********/
+ 
+ /*>#define OVERLAPPING_REGNO_P (regno) */
+ /*>#define INSN_CLOBBERS_REGNO_P (insn, regno) */
+ /*>#define PRESERVE_DEATH_INFO_REGNO_P (regno) */
+ 
+ 
+ /*************************************************************
+  Register Classes
+ *************************************************************/
+ 
+ /*>enum reg_class */
+ /*>#define N_REG_CLASSES */
+ /*>#define REG_CLASS_NAMES */
+ /*>#define REG_CLASS_CONTENTS */
+ /*>#define REGNO_REG_CLASS (regno) */
+ /*>#define BASE_REG_CLASS */
+ /*>#define INDEX_REG_CLASS */
+ /*>#define REG_CLASS_FROM_LETTER (char) */
+ /*>#define REGNO_OK_FOR_BASE_P (num) */
+ /*>#define REGNO_OK_FOR_INDEX_P (num) */
+ /*>#define PREFERRED_RELOAD_CLASS (x, class) */
+ /*>#define PREFERRED_OUTPUT_RELOAD_CLASS (x, class) */
+ /*>#define LIMIT_RELOAD_CLASS (mode, class) */
+ /*>#define SECONDARY_RELOAD_CLASS (class, mode, x) */
+ /*>#define SECONDARY_INPUT_RELOAD_CLASS (class, mode, x) */
+ /*>#define SECONDARY_OUTPUT_RELOAD_CLASS (class, mode, x) */
+ /*>#define SECONDARY_MEMORY_NEEDED (class1, class2, m) */
+ /*>#define SECONDARY_MEMORY_NEEDED_RTX (mode) */
+ /*>#define SECONDARY_MEMORY_NEEDED_MODE (mode) */
+ /*>#define SMALL_REGISTER_CLASSES */
+ /*>#define CLASS_LIKELY_SPILLED_P (class) */
+ /*>#define CLASS_MAX_NREGS (class, mode) */
+ /*>#define CLASS_CANNOT_CHANGE_SIZE */
+ /*>#define CONST_OK_FOR_LETTER_P (value, c) */
+ /*>#define CONST_DOUBLE_OK_FOR_LETTER_P (value, c) */
+ /*>#define EXTRA_CONSTRAINT (value, c) */
+ 
+ 
+ /*************************************************************
+  Stack Layout and Calling Conventions
+ *************************************************************/
+ 
+ 
+ /*** Basic Stack Layout ************************************/
+ 
+ /* The frame is laid out as follows:
+                         +----------------------+
+                         |           :          |
+                         | last incoming arg    |
+                         |           :          |
+              argptr  -> | first incoming arg   |
+                         | arguments size, bytes|  caller's frame
+                         |           :          |
+ 			| caller's entry point |
+ callee's frame link  -> | caller's frame-link  |
+                         | <scratch>            |
+                         +----------------------+
+                         | resptr               |
+         ARG_POINTER  -> | argptr               |
+                         | MDLptr               |
+ 			| caller's Iptr        |
+                         +----------------------+
+                         | local N              |
+                         |           :          |
+                         | local 0              |
+                         | outgoing arg N       |
+                         |           :          |
+                         | outgoing arg 0       |
+                         | outgoing args size   |
+ 			| data segment ptr     |
+ 			| callee's entry point |  callee's frame
+ 			| callee's frame link  |
+ FRAME_POINTER (Wptr) -> | <scratch>            |
+                         +----------------------+
+ 
+ Note that ARG_POINTER_REGNO points to the three hidden arguments, not
+ to the actual argument block.  That's because the offset from Wreg to
+ the actual argument block is not known until runtime (even worse, it
+ varies from caller to caller).
+ 
+ ***/
+ 
+ /*>#define STACK_GROWS_DOWNWARD */
+ /*>#define FRAME_GROWS_DOWNWARD */
+ /*>#define ARGS_GROW_DOWNWARD */
+ 
+ #undef STARTING_FRAME_OFFSET
+ #define STARTING_FRAME_OFFSET \
+   (STACK_POINTER_OFFSET + WORD_ROUND (current_function_outgoing_args_size))
+ 
+ /* When there are no outgoing arguments, we don't need "args size"
+    word either.  */
+ 
+ #undef STACK_POINTER_OFFSET
+ #define STACK_POINTER_OFFSET \
+   (current_function_outgoing_args_size? 5 : 4) * UNITS_PER_WORD
+ 
+ #undef FIRST_PARM_OFFSET
+ #define FIRST_PARM_OFFSET(fundecl)  0
+ 
+ /*?#define STACK_DYNAMIC_OFFSET(fundecl) */
+ /*?#define DYNAMIC_CHAIN_ADDRESS(frameaddr) */
+ #undef SETUP_FRAME_ADDRESSES 
+ #undef RETURN_ADDR_RTX/* (count, frameaddr) */
+ #undef RETURN_ADDR_IN_PREVIOUS_FRAME
+ 
+ 
+ /*** Registers That Address the Stack Frame  ***************/
+ 
+ /*>#define STACK_POINTER_REGNUM */
+ /*>#define FRAME_POINTER_REGNUM */
+ /*>#define HARD_FRAME_POINTER_REGNUM */
+ /*>#define ARG_POINTER_REGNUM */
+ #undef STATIC_CHAIN_REGNUM
+ #undef STATIC_CHAIN_INCOMING_REGNUM
+ /*?#define STATIC_CHAIN */
+ /*?#define STATIC_CHAIN_INCOMING */
+ 
+ /*** Eliminating Frame Pointer and Arg Pointer *************/
+ 
+ /*>#define FRAME_POINTER_REQUIRED */
+ #undef INITIAL_FRAME_POINTER_OFFSET /* (depth-var) */
+ 
+ 
+ #undef ELIMINABLE_REGS
+ #define ELIMINABLE_REGS \
+   {{ ARG_POINTER_REGNUM, R_WREG},	\
+    { STACK_POINTER_REGNUM, R_WREG}}
+ 
+ #undef CAN_ELIMINATE
+ #define CAN_ELIMINATE(FROM, TO)  1
+ 
+ #undef INITIAL_ELIMINATION_OFFSET
+ #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET_VAR) \
+   switch (FROM)								\
+     {									\
+     case ARG_POINTER_REGNUM:						\
+       (OFFSET_VAR) = STACK_POINTER_OFFSET				\
+ 	+ WORD_ROUND (current_function_outgoing_args_size)		\
+ 	 + WORD_ROUND (get_frame_size ())				\
+ 	  + UNITS_PER_WORD  /* MDLptr */				\
+ 	   + UNITS_PER_WORD;  /* caller's Iptr */			\
+       break;								\
+ 									\
+     case STACK_POINTER_REGNUM:						\
+       (OFFSET_VAR) = 0;							\
+       break;								\
+ 									\
+     default:								\
+       abort ();								\
+     }
+ 
+ /* ??? Don't know yet how setjump/longjump are implemented in libc  */
+ 
+ /*?#define LONGJMP_RESTORE_FROM_STACK */
+ 
+ 
+ /*** Passing Function Arguments on the Stack ***************/
+ 
+ /* ? */
+ #define PROMOTE_PROTOTYPES
+ 
+ #undef PUSH_ROUNDING /* (npushed) */
+ /*>#define ACCUMULATE_OUTGOING_ARGS */
+ #undef REG_PARM_STACK_SPACE /* (fndecl) */
+ #undef MAYBE_REG_PARM_STACK_SPACE
+ #undef FINAL_REG_PARM_STACK_SPACE /* (const_size, var_size) */
+ #undef OUTGOING_REG_PARM_STACK_SPACE
+ #undef STACK_PARMS_IN_REG_PARM_AREA
+ /*>#define RETURN_POPS_ARGS (funtype, stack-size) */
+ 
+ /*** Passing Arguments in Registers ************************/
+ 
+ /* In EXPERT model all arguments are passed on stack. */
+ 
+ /* ??? Even for libcalls? */
+ 
+ #undef FUNCTION_ARG
+ #define FUNCTION_ARG(cum, mode, type, named)  0
+ 
+ #undef FUNCTION_INCOMING_ARG
+ 
+ #undef FUNCTION_ARG_PARTIAL_NREGS
+ #define FUNCTION_ARG_PARTIAL_NREGS(cum, mode, type, named)  0
+ 
+ #undef FUNCTION_ARG_PASS_BY_REFERENCE
+ #define FUNCTION_ARG_PASS_BY_REFERENCE(cum, mode, type, named)  0
+ 
+ #undef FUNCTION_ARG_PRESCAN /* (cum, mode, type, named) */
+ #undef FUNCTION_ARG_CALLEE_COPIES /* (cum, mode, type, named) */
+ 
+ #undef CUMULATIVE_ARGS
+ #define CUMULATIVE_ARGS  int
+ 
+ #undef INIT_CUMULATIVE_ARGS
+ #define INIT_CUMULATIVE_ARGS(cum, fntype, libname) \
+   do {} while (0)
+ 
+ #undef INIT_CUMULATIVE_INCOMING_ARGS
+ #define INIT_CUMULATIVE_INCOMING_ARGS(cum, fntype, libname) \
+   do {} while (0)
+ 
+ #undef FUNCTION_ARG_ADVANCE
+ #define FUNCTION_ARG_ADVANCE(cum, mode, type, named) \
+   do {} while (0)
+ 
+ /*>#define FUNCTION_ARG_PADDING (mode, type) */
+ /*>#define FUNCTION_ARG_BOUNDARY (mode, type) */
+ 
+ #undef FUNCTION_ARG_REGNO_P
+ #define FUNCTION_ARG_REGNO_P(regno)  0
+ 
+ 
+ /*** How Scalar Function Values Are Returned ***************/
+ 
+ /* The function result values are returned in one of three ways:
+   - integral and pointer values are returned in Areg.
+   - floating-point values are returned in FAreg.
+   - structured values are returned in a location allocated by the caller and
+     pointed to by resptr.  Additionally, resptr is returned in Areg.
+ ***/
+ 
+ /*?#define TRADITIONAL_RETURN_FLOAT */
+ 
+ #undef FUNCTION_VALUE
+ #define FUNCTION_VALUE(VALTYPE, FUNC) \
+   gen_rtx (REG,                                                             \
+            ((TREE_CODE (VALTYPE) == INTEGER_TYPE                            \
+              || TREE_CODE (VALTYPE) == ENUMERAL_TYPE                        \
+              || TREE_CODE (VALTYPE) == BOOLEAN_TYPE                         \
+              || TREE_CODE (VALTYPE) == CHAR_TYPE                            \
+              || TREE_CODE (VALTYPE) == POINTER_TYPE                         \
+              || TREE_CODE (VALTYPE) == OFFSET_TYPE)                         \
+             && TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)                    \
+            ? word_mode : TYPE_MODE (VALTYPE),                               \
+            TREE_CODE (VALTYPE) == REAL_TYPE ? R_FAREG : R_AREG)
+ 
+ /*>#define FUNCTION_OUTGOING_VALUE (valtype, func) */
+ /*>#define LIBCALL_VALUE (mode) */
+ /*>#define FUNCTION_VALUE_REGNO_P (regno) */
+ /* #define APPLY_RESULT_SIZE */
+ 
+ 
+ /*** How Large Values Are Returned *************************/
+ 
+ #undef RETURN_IN_MEMORY
+ #undef DEFAULT_PCC_STRUCT_RETURN
+ 
+ /* Caller puts the structure value address into Creg, and it gets
+    pushed onto the stack by `call' insn.  However, Areg and Breg
+    are loaded by the code output from `call' pattern, so we want
+    the value address to be in Areg before the `call' pattern. */
+ 
+ #undef STRUCT_VALUE_REGNUM
+ #define STRUCT_VALUE_REGNUM  (R_AREG)
+ 
+ #undef STRUCT_VALUE
+ #undef STRUCT_VALUE_INCOMING_REGNUM
+ 
+ /* Callee finds the structure value address among the hidden arguments
+    addressed with ARG_POINTER_REGNUM */
+ 
+ #undef STRUCT_VALUE_INCOMING
+ #define STRUCT_VALUE_INCOMING \
+   gen_rtx (MEM, SImode,							\
+ 	   plus_constant (gen_rtx (REG, SImode, ARG_POINTER_REGNUM),	\
+ 			  UNITS_PER_WORD))
+ 
+ #undef PCC_STATIC_STRUCT_RETURN
+ 
+ 
+ /*** Caller-Saves Register Allocation **********************/
+ 
+ #undef DEFAULT_CALLER_SAVES
+ #undef CALLER_SAVE_PROFITABLE /* (refs, calls) */
+ 
+ 
+ /*** Function Entry and Exit *******************************/
+ 
+ #undef FUNCTION_PROLOGUE
+ #define FUNCTION_PROLOGUE(file, frame_size) \
+   {									\
+     int totsize = IN_WORDS (frame_size)					\
+                   + IN_WORDS (current_function_outgoing_args_size)	\
+ 		  + IN_WORDS (STACK_POINTER_OFFSET);			\
+ 									\
+     if (current_function_pretend_args_size)				\
+       /* Unused on transputers; we don't expect to handle this */	\
+       abort ();								\
+ 									\
+     if (TARGET_STACK_EXTEND)						\
+       {									\
+         rtx ajw_label = (rtx) gen_label_rtx ();				\
+ 									\
+ 	fprintf (file, "\tldlp 0\n");					\
+ 	fprintf (file, "\tldl 1\n");					\
+ 	fprintf (file, "\tldnl 5\n");					\
+ 	fprintf (file, "\tdiff\n");					\
+ 	fprintf (file, "\tldc %d\n", totsize*UNITS_PER_WORD);		\
+ 	fprintf (file, "\tgt\n");					\
+ 	fprintf (file, "\teqc 0\n");					\
+ 	fprintf (file, "\tcj ");					\
+         output_asm_label (ajw_label);					\
+ 	fprintf (file, "\n");						\
+ 									\
+ 									\
+         {								\
+ 	  HOST_WIDE_INT preferred_fragment_size				\
+ 	    /* Avoid too small fragments */				\
+ 	    = (totsize < 0x200? 0x200: totsize);			\
+ 									\
+ 	  /* 1st arg to CRT_stack_extender is a flags set.  This	\
+ 	     definition is according to include/sys/crt.h */		\
+ 									\
+           enum {							\
+             RETURN_DOUBLE = 1,	/* REAL64 instead of REAL32 in FAreg */ \
+             RETURN_AREG = 2,	/* result in Areg */			\
+             RETURN_FAREG = 4	/* result in FAreg */			\
+           };								\
+ 									\
+ 	  int flags = 0;						\
+ 									\
+ 	  if (current_function_returns_struct)				\
+ 	    flags |= RETURN_AREG;	/* structure value address */	\
+ 	  else if (current_function_return_rtx)				\
+ 	    {								\
+ 	      enum machine_mode m = GET_MODE (current_function_return_rtx); \
+ 									\
+ 	      if (GET_MODE_CLASS (m) == MODE_FLOAT			\
+ 		  || GET_MODE_CLASS (m) == MODE_COMPLEX_FLOAT)		\
+ 		flags |= RETURN_FAREG;					\
+ 	      else							\
+ 		flags |= RETURN_AREG;					\
+ 									\
+ 	      if (GET_MODE_SIZE (m) > UNITS_PER_WORD)			\
+ 		flags |= RETURN_DOUBLE;					\
+ 	    }								\
+ 									\
+ 	  fprintf (file, "\tldc %u\n", preferred_fragment_size*UNITS_PER_WORD); \
+ 	  fprintf (file, "\tldc %u\n", totsize*UNITS_PER_WORD);		\
+ 	  fprintf (file, "\tldc 0x%x\n", flags);			\
+ 	}								\
+ 									\
+ 	fprintf (file, "\t.globl __CRT_stack_extender\n");		\
+ 	fprintf (file, "\tcall __CRT_stack_extender\n");		\
+         output_asm_label (ajw_label);					\
+ 	fprintf (file, ":\n");						\
+       }									\
+     fprintf (file, "\tldl 1\n");					\
+     fprintf (file, "\tldnl 1\n");	/* .data ptr */			\
+     fprintf (file, "\tldc ");						\
+     assemble_name (file, XSTR (XEXP (DECL_RTL (current_function_decl),0),0));\
+     fprintf (file, "-2\n");						\
+     fprintf (file, "\tldpi\n");		/* this finction entry point */	\
+     fprintf (file, "\tldlp 5\n");	/* frame link */		\
+     fprintf (file, "\tajw -%u\n", totsize);				\
+     fprintf (file, "\tstl 1\n");	/* frame link */		\
+     fprintf (file, "\tstl 2\n");	/* this function entry point */	\
+     fprintf (file, "\tstl 3\n");	/* .data ptr */			\
+ 									\
+     /* Note: Wreg[4] is the args_size word.  See T800_OUTPUT__CALL */	\
+   }
+ 
+ /*>-#define EXIT_IGNORE_STACK */
+ /*>-#define FUNCTION_EPILOGUE (file, size) */
+ /*>-#define DELAY_SLOTS_FOR_EPILOGUE */
+ /*>-#define ELIGIBLE_FOR_EPILOGUE_DELAY (insn, n) */
+ 
+ 
+ /*** Generating Code for Profiling *************************/
+ 
+ /* ??? ... later */
+ /* #define FUNCTION_PROFILER (file, labelno) */
+ /* #define PROFILE_BEFORE_PROLOGUE */
+ /* #define FUNCTION_BLOCK_PROFILER (file, labelno) */
+ /* #define BLOCK_PROFILER (file, blockno) */
+ /* #define BLOCK_PROFILER_CODE */
+ 
+ 
+ /*************************************************************
+  Implementing the Varargs Macros
+ *************************************************************/
+ 
+ /*>#define EXPAND_BUILTIN_SAVEREGS (args) */
+ /*>#define SETUP_INCOMING_VARARGS (args_so_far, mode, type, */
+ 
+ 
+ /*************************************************************
+  Trampolines for Nested Functions
+ *************************************************************/
+ 
+ /* ??? ... later */
+ /* #define TRAMPOLINE_TEMPLATE (file) */
+ /* #define TRAMPOLINE_SECTION */
+ /* #define TRAMPOLINE_SIZE */
+ /* #define TRAMPOLINE_ALIGNMENT */
+ /* #define INITIALIZE_TRAMPOLINE (addr, fnaddr, static_chain) */
+ /* #define ALLOCATE_TRAMPOLINE (fp) */
+ /* #define INSN_CACHE_SIZE */
+ /* #define INSN_CACHE_LINE_WIDTH */
+ /* #define INSN_CACHE_DEPTH */
+ /* #define CLEAR_INSN_CACHE (BEG, END) */
+ /* #define TRANSFER_FROM_TRAMPOLINE */
+ 
+ 
+ /*************************************************************
+  Implicit Calls to Library Routines
+ *************************************************************/
+ 
+ /* #define MULSI3_LIBCALL */
+ /* #define DIVSI3_LIBCALL */
+ /* #define UDIVSI3_LIBCALL */
+ /* #define MODSI3_LIBCALL */
+ /* #define UMODSI3_LIBCALL */
+ /* #define MULDI3_LIBCALL */
+ /* #define DIVDI3_LIBCALL */
+ /* #define UDIVDI3_LIBCALL */
+ /* #define MODDI3_LIBCALL */
+ /* #define UMODDI3_LIBCALL */
+ /* #define INIT_TARGET_OPTABS */
+ /* #define TARGET_EDOM */
+ /* #define GEN_ERRNO_RTX */
+ 
+ /* Use mem{set,cpy} rather than b{zero,copy}. */
+ #define TARGET_MEM_FUNCTIONS
+ 
+ /* #define LIBGCC_NEEDS_DOUBLE */
+ /* #define FLOAT_ARG_TYPE */
+ /* #define FLOATIFY (passed-value) */
+ /* #define FLOAT_VALUE_TYPE */
+ /* #define INTIFY (float-value) */
+ /* nongcc_SI_type */
+ /* nongcc_word_type */
+ /* perform_@dots{} */
+ /* #define NEXT_OBJC_RUNTIME */
+ 
+ 
+ /*************************************************************
+  Addressing Modes
+ *************************************************************/
+ 
+ /*>#define HAVE_POST_INCREMENT */
+ /*>#define HAVE_PRE_INCREMENT */
+ /*>#define HAVE_POST_DECREMENT */
+ /*>#define HAVE_PRE_DECREMENT */
+ /*>#define CONSTANT_ADDRESS_P (x) */
+ /*>#define MAX_REGS_PER_ADDRESS */
+ /*>#define GO_IF_LEGITIMATE_ADDRESS (mode, x, label) */
+ /*>#define REG_OK_FOR_BASE_P (x) */
+ /*>#define REG_OK_FOR_INDEX_P (x) */
+ /*>#define LEGITIMIZE_ADDRESS (x, oldx, mode, win) */
+ /*>#define GO_IF_MODE_DEPENDENT_ADDRESS (addr, label) */
+ /*>#define LEGITIMATE_CONSTANT_P (x) */
+ 
+ 
+ /*************************************************************
+  Condition Code Status
+ *************************************************************/
+ 
+ /*>#define CC_STATUS_MDEP */
+ /*>#define CC_STATUS_MDEP_INIT */
+ /*>#define NOTICE_UPDATE_CC (exp, insn) */
+ /*>#define EXTRA_CC_MODES */
+ /*>#define EXTRA_CC_NAMES */
+ /*>#define SELECT_CC_MODE (op, x, y) */
+ /*>#define CANONICALIZE_COMPARISON (code, op0, op1) */
+ /*>#define REVERSIBLE_CC_MODE (mode) */
+ 
+ 
+ /*************************************************************
+  Describing Relative Costs of Operations
+ *************************************************************/
+ 
+ /*>#define CONST_COSTS (x, code, outer_code) */
+ /*>#define RTX_COSTS (x, code, outer_code) */
+ /*>#define ADDRESS_COST (address) */
+ /*>#define REGISTER_MOVE_COST (from, to) */
+ /*>#define MEMORY_MOVE_COST (m) */
+ /*>#define BRANCH_COST */
+ /*>#define SLOW_BYTE_ACCESS */
+ /*>#define SLOW_ZERO_EXTEND */
+ /*>#define SLOW_UNALIGNED_ACCESS */
+ /*>#define DONT_REDUCE_ADDR */
+ /*>#define MOVE_RATIO */
+ /*>#define NO_FUNCTION_CSE */
+ /*>#define NO_RECURSIVE_FUNCTION_CSE */
+ /*>#define ADJUST_COST (insn, link, dep_insn, cost) */
+ 
+ 
+ /*************************************************************
+  Dividing the Output into Sections (Texts, Data, @dots{})
+ *************************************************************/
+ 
+ #undef TEXT_SECTION_ASM_OP
+ #define TEXT_SECTION_ASM_OP  "\t.text"
+ 
+ #undef DATA_SECTION_ASM_OP 
+ #define DATA_SECTION_ASM_OP  "\t.data"
+ 
+ /* #define SHARED_SECTION_ASM_OP */
+ /* #define INIT_SECTION_ASM_OP */
+ 
+ #undef BSS_SECTION_ASM_OP
+ #define BSS_SECTION_ASM_OP  "\t.bss"
+ 
+ /* Define the .bss section for ASM_OUTPUT_LOCAL to use. */
+ 
+ #undef EXTRA_SECTIONS
+ #define EXTRA_SECTIONS in_bss
+ 
+ #undef EXTRA_SECTION_FUNCTIONS
+ #define EXTRA_SECTION_FUNCTIONS \
+ void								\
+ bss_section ()							\
+ {								\
+   if (in_section != in_bss)					\
+     {								\
+       fprintf (asm_out_file, "%s\n", BSS_SECTION_ASM_OP);	\
+       in_section = in_bss;					\
+     }								\
+ }
+ 
+ /* #define READONLY_DATA_SECTION */
+ /* #define SELECT_SECTION (exp, reloc) */
+ /* #define SELECT_RTX_SECTION (mode, rtx) */
+ /* #define JUMP_TABLES_IN_TEXT_SECTION */
+ /* #define ENCODE_SECTION_INFO (decl) */
+ /* #define STRIP_NAME_ENCODING (var, sym_name) */
+ 
+ 
+ /*************************************************************
+  Position Independent Code
+ *************************************************************/
+ 
+ /* #define PIC_OFFSET_TABLE_REGNUM */
+ /* #define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED */
+ /* #define FINALIZE_PIC */
+ /* #define LEGITIMATE_PIC_OPERAND_P (x) */
+ 
+ 
+ /*************************************************************
+  Defining the Output Assembler Language
+ *************************************************************/
+ 
+ 
+ /*** The Overall Framework of an Assembler File  ***********/
+ 
+ #undef ASM_FILE_START
+ #define ASM_FILE_START(stream)  {}
+ #undef ASM_FILE_END
+ #define ASM_FILE_END(stream)  {}
+ 
+ /* Use default definition for that */
+ 
+ #undef ASM_IDENTIFY_GCC(file)
+ 
+ #undef ASM_COMMENT_START
+ #define ASM_COMMENT_START  ";"
+ 
+ #undef ASM_APP_ON
+ #define ASM_APP_ON ""
+ 
+ #undef ASM_APP_OFF
+ #define ASM_APP_OFF ""
+ 
+ #undef ASM_OUTPUT_SOURCE_FILENAME
+ #define ASM_OUTPUT_SOURCE_FILENAME(stream, name) \
+   fprintf (stream, "\t.file \"%s\"\n", name)
+ 
+ #undef ASM_OUTPUT_SOURCE_LINE
+ /* #define ASM_OUTPUT_SOURCE_LINE(stream, line) */
+ 
+ #undef ASM_OUTPUT_IDENT
+ /* #define ASM_OUTPUT_IDENT (stream, string) */
+ 
+ #undef ASM_OUTPUT_SECTION_NAME
+ /* #define ASM_OUTPUT_SECTION_NAME (stream, string) */
+ 
+ /*>#define OBJC_PROLOGUE */
+ 
+ 
+ /*** Output of Data ****************************************/
+ 
+ /*>-#define ASM_OUTPUT_LONG_DOUBLE(stream, value) */
+ 
+ #ifdef HOST_WORDS_BIG_ENDIAN
+   /* Doubles on host are stored in memory with the high order word first. */		\
+ #undef ASM_OUTPUT_DOUBLE
+ #define ASM_OUTPUT_DOUBLE(STREAM, VALUE) \
+   do {								\
+     union { double d; int i[2];} u;				\
+     u.d = (VALUE);                                              \
+     fprintf (STREAM, "\t.word 0x%x, 0x%x\t%s double %.20g\n",   \
+              u.i[1], u.i[0], ASM_COMMENT_START, u.d);           \
+   } while (0)
+ #else
+ #undef ASM_OUTPUT_DOUBLE
+ #define ASM_OUTPUT_DOUBLE(STREAM, VALUE) \
+   do {								\
+     union { double d; int i[2];} u;				\
+     u.d = (VALUE);                                              \
+     fprintf (STREAM, "\t.word 0x%x, 0x%x\t%s double %.20g\n",   \
+              u.i[0], u.i[1], ASM_COMMENT_START, u.d);           \
+   } while (0)
+ #endif /* HOST_WORDS_BIG_ENDIAN */
+ 
+ #undef ASM_OUTPUT_FLOAT
+ #define ASM_OUTPUT_FLOAT(STREAM, VALUE) \
+   do {								\
+     union { float f; int i[2];} u;				\
+     u.f = (VALUE);                                              \
+     fprintf (STREAM, "\t.word 0x%x\t%s float %.12g\n",          \
+              u.i[0], ASM_COMMENT_START, u.f);			\
+   } while (0)
+ 
+ #undef ASM_OUTPUT_THREE_QUARTER_FLOAT /* (stream, value) */
+ #undef ASM_OUTPUT_SHORT_FLOAT /* (stream, value) */
+ #undef ASM_OUTPUT_BYTE_FLOAT /* (stream, value) */
+ #undef ASM_OUTPUT_QUADRUPLE_INT /* (stream, exp) */
+ #undef ASM_OUTPUT_DOUBLE_INT /* (stream, exp) */
+ 
+ #undef ASM_OUTPUT_INT
+ #define ASM_OUTPUT_INT(stream, exp) \
+   do {						\
+     fprintf (stream, "\t.word ");		\
+     output_addr_const (stream, exp);		\
+     putc ('\n', stream);			\
+   } while (0)
+ 
+ #undef ASM_OUTPUT_SHORT
+ #define ASM_OUTPUT_SHORT(stream, exp) \
+   do {						\
+     fprintf (stream, "\t.short ");		\
+     output_addr_const (stream, exp);		\
+     putc ('\n', stream);			\
+   } while (0)
+ 
+ #undef ASM_OUTPUT_CHAR
+ #define ASM_OUTPUT_CHAR(stream, exp) \
+   do {						\
+     fprintf (stream, "\t.byte ");		\
+     output_addr_const (stream, exp);		\
+     putc ('\n', stream);			\
+   } while (0)
+ 
+ #undef ASM_OUTPUT_BYTE
+ #define ASM_OUTPUT_BYTE(STREAM, VALUE) \
+   fprintf (STREAM, "\t.byte %u\n", (unsigned char) (VALUE))
+ 
+ #undef ASM_BYTE_OP
+ #define ASM_BYTE_OP  ".byte"
+ 
+ /* Rely on defaults.h for this */
+ 
+ #undef ASM_OUTPUT_ASCII
+ /* #define ASM_OUTPUT_ASCII(stream, ptr, len) */
+ 
+ /* #define ASM_OUTPUT_POOL_PROLOGUE(file funname fundecl size) */
+ /* #define ASM_OUTPUT_SPECIAL_POOL_ENTRY(file, x, mode, align, labelno, jumpto) */
+ 
+ /* ACE assembler considers ';' to be comment start character, not a
+    logical line separator.  Don't know if there is another char acting
+    as logical line separator; assume there isn't.  */
+ 
+ #define IS_ASM_LOGICAL_LINE_SEPARATOR(c)  (0)
+ 
+ #undef ASM_OPEN_PAREN
+ #define ASM_OPEN_PAREN  "("
+ 
+ #undef ASM_CLOSE_PAREN
+ #define ASM_CLOSE_PAREN  ")"
+ 
+ 
+ /*** Output of Uninitialized Variables *********************/
+ 
+ #undef ASM_OUTPUT_COMMON
+ /* #define ASM_OUTPUT_COMMON(stream, name, size, rounded) */
+ 
+ #undef ASM_OUTPUT_ALIGNED_COMMON
+ #define ASM_OUTPUT_ALIGNED_COMMON(STREAM, NAME, SIZE, ALIGNMENT) \
+   do {									\
+     if ((ALIGNMENT) > BITS_PER_UNIT)					\
+       fprintf (STREAM, "\t.align %u\n", (ALIGNMENT)/BITS_PER_UNIT);	\
+     fprintf (STREAM, "\t.comm ");					\
+     assemble_name (STREAM, NAME);					\
+     fprintf (STREAM, ",%u\n", SIZE);					\
+   } while (0)
+ 
+ #undef ASM_OUTPUT_SHARED_COMMON
+ /* #define ASM_OUTPUT_SHARED_COMMON (stream, name, size, rounded) */
+ 
+ #undef ASM_OUTPUT_LOCAL
+ /* #define ASM_OUTPUT_LOCAL(stream, name, size, rounded) */
+ 
+ #undef ASM_OUTPUT_ALIGNED_LOCAL
+ #define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGNMENT) \
+   do {									\
+     bss_section ();							\
+     if ((ALIGNMENT) > BITS_PER_UNIT)					\
+       fprintf (STREAM, "\t.align %u\n", (ALIGNMENT)/BITS_PER_UNIT); 	\
+     assemble_name (STREAM, NAME);					\
+     fprintf (STREAM, ":\n\t.space %u\n", SIZE);				\
+   } while (0)
+ 
+ #undef ASM_OUTPUT_SHARED_LOCAL
+ /* #define ASM_OUTPUT_SHARED_LOCAL (stream, name, size, rounded) */
+ 
+ 
+ /*** Output and Generation of Labels ***********************/
+ 
+ #undef ASM_OUTPUT_LABEL
+ #define ASM_OUTPUT_LABEL(stream, name) \
+   do {					\
+     assemble_name (stream, name);	\
+     fputs (":\n", stream);		\
+   } while (0)
+ 
+ #undef ASM_DECLARE_FUNCTION_NAME
+ /* #define ASM_DECLARE_FUNCTION_NAME(stream, name, decl) */
+ 
+ #undef ASM_DECLARE_FUNCTION_SIZE
+ /* #define ASM_DECLARE_FUNCTION_SIZE(stream, name, decl) */
+ 
+ #undef ASM_DECLARE_OBJECT_NAME
+ /* #define ASM_DECLARE_OBJECT_NAME(stream, name, decl) */
+ 
+ #undef ASM_FINISH_DECLARE_OBJECT
+ /* #define ASM_FINISH_DECLARE_OBJECT(stream, decl, toplevel, atend) */
+ 
+ #undef ASM_GLOBALIZE_LABEL
+ #define ASM_GLOBALIZE_LABEL(stream, name) \
+   do {						\
+     fputs ("\t.globl ", stream);		\
+     assemble_name (stream, name);		\
+     fputc ('\n', stream);			\
+   } while (0)
+ 
+ /* ACE compiler handles external references by mere globalizing the name */
+ 
+ #undef ASM_OUTPUT_EXTERNAL
+ #define ASM_OUTPUT_EXTERNAL(stream, decl, name) \
+   ASM_GLOBALIZE_LABEL (stream, name)
+ 
+ #undef ASM_OUTPUT_EXTERNAL_LIBCALL
+ #define ASM_OUTPUT_EXTERNAL_LIBCALL(stream, symref) \
+   do {							\
+     fputs ("\t.globl ", stream);			\
+     assemble_name (stream, XSTR (symref, 0));		\
+     fputc ('\n', stream);				\
+   } while (0)
+ 
+ #undef ASM_OUTPUT_LABELREF
+ #define ASM_OUTPUT_LABELREF(stream, name) \
+   fprintf (stream, "_%s", name)
+ 
+ #undef ASM_OUTPUT_INTERNAL_LABEL
+ #define ASM_OUTPUT_INTERNAL_LABEL(stream, prefix, num) \
+   fprintf (stream, ".L%s%u:\n", prefix, num)
+ 
+ #undef ASM_GENERATE_INTERNAL_LABEL
+ #define ASM_GENERATE_INTERNAL_LABEL(string, prefix, num) \
+   sprintf (string, "*.L%s%u", prefix, num)
+ 
+ /* Parix as seems to dislike dots in the middle of a name, so
+    traditional "%s.%d" won't do.  OK, we'll achieve uniquity
+    exploiting the fact that C identifiers never start in a digit.
+    ASM_OUTPUT_LABELREF will prepend '_' to this, thus making a valid
+    identifier.. */
+ 
+ #undef ASM_FORMAT_PRIVATE_NAME
+ #define ASM_FORMAT_PRIVATE_NAME(outvar, name, number) \
+   do {							\
+     (outvar) = (char *) alloca (strlen (name) + 12);	\
+     sprintf (outvar, "%d%s", number, name);		\
+   } while (0)
+ 
+ /* defaults.h will take care of this if we define SET_ASM_OP */
+ 
+ #undef ASM_OUTPUT_DEF
+ /* #define ASM_OUTPUT_DEF (stream, name, value) */
+ 
+ #undef SET_ASM_OP
+ #define SET_ASM_OP  ".set"
+ 
+ /* #define OBJC_GEN_METHOD_LABEL (buf, is_inst, class_name, cat_name, sel_name) */
+ 
+ 
+ /*** Macros Controlling Initialization Routines ************/
+ 
+ /* ??? ... later */
+ 
+ /* #define INIT_SECTION_ASM_OP */
+ /* #define HAS_INIT_SECTION */
+ /* #define INVOKE__main */
+ /* #define ASM_OUTPUT_CONSTRUCTOR (stream, name) */
+ /* #define ASM_OUTPUT_DESTRUCTOR (stream, name) */
+ /* #define OBJECT_FORMAT_COFF */
+ /* #define OBJECT_FORMAT_ROSE */
+ /* #define REAL_NM_FILE_NAME */
+ 
+ 
+ /*** Output of Assembler Instructions **********************/
+ 
+ /*>#define REGISTER_NAMES */
+ /*>#define ADDITIONAL_REGISTER_NAMES */
+ 
+ /* Expert model always reserves Wreg[0] as a scratch location, so
+    we don't need to do anything special for asm's that clobber Wreg[0] */
+ 
+ #undef ASM_SPECIAL_CLOBBER
+ 
+ /*>#define ASM_OUTPUT_OPCODE (stream, ptr) */
+ /*>#define FINAL_PRESCAN_INSN (insn, opvec, noperands) */
+ /*>#define PRINT_OPERAND (stream, x, code) */
+ /*>#define PRINT_OPERAND_PUNCT_VALID_P (code) */
+ /*>#define PRINT_OPERAND_ADDRESS (stream, x) */
+ /*>-#define DBR_OUTPUT_SEQEND(file) */
+ /*>-#define REGISTER_PREFIX */
+ /*>-#define LOCAL_LABEL_PREFIX */
+ /*>-#define USER_LABEL_PREFIX */
+ /*>-#define IMMEDIATE_PREFIX */
+ /*>-#define ASSEMBLER_DIALECT */
+ /*>#define ASM_OUTPUT_REG_PUSH (stream, regno) */
+ /*>#define ASM_OUTPUT_REG_POP (stream, regno) */
+ 
+ 
+ /*** Output of Dispatch Tables *****************************/
+ 
+ /* Note: the following two should generate the same labels as
+    ASM_OUTPUT_INTERNAL_LABEL (stream, "L", value), sans trailing ":\n".
+    Definitions for those in defaults.h are currently unusable because
+    they use ASM_OUTPUT_INTERNAL_LABEL, and ":\n" it appends confuses
+    assemblers. */
+ 
+ #undef ASM_OUTPUT_ADDR_DIFF_ELT
+ #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, VALUE, REL) \
+   do {								\
+     extern int t800_expected_table_label;			\
+ 								\
+     if ((REL) == t800_expected_table_label)			\
+       fprintf (STREAM, "\t.word\t.LL%u-.LL%ua\n", VALUE, REL);  \
+   } while (0)
+ 
+ /*>-#define ASM_OUTPUT_ADDR_VEC_ELT(stream, value) */
+ /*>#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE) */
+ /*>-#define ASM_OUTPUT_CASE_END(stream, num, table) */
+ 
+ 
+ /*** Assembler Commands for Alignment **********************/
+ 
+ /* Alignment for pieces of code reached only by jumping.  Seems worthy
+    to give them word-align. */
+ 
+ #undef ASM_OUTPUT_ALIGN_CODE
+ #define ASM_OUTPUT_ALIGN_CODE(file) \
+   fputs ("\t.align 4\n", file)
+ 
+ /* Likewise for top-of-the-loop labels */
+ 
+ #undef ASM_OUTPUT_LOOP_ALIGN
+ #define ASM_OUTPUT_LOOP_ALIGN(file) \
+   fputs ("\t.align 4\n", file)
+ 
+ #undef ASM_OUTPUT_SKIP
+ #define ASM_OUTPUT_SKIP(stream, nbytes) \
+   fprintf (stream, "\t.space %u\n", nbytes)
+ 
+ /* .space does the right thing (puts zeroes) even in .text segment.
+    (as -l doesn't show that, but examining .o file with od suggests
+    that this is the case) */
+ 
+ #undef ASM_NO_SKIP_IN_TEXT
+ /* #define ASM_NO_SKIP_IN_TEXT */
+ 
+ #undef ASM_OUTPUT_ALIGN
+ #define ASM_OUTPUT_ALIGN(stream, power) \
+   fprintf (stream, "\t.align %u\n", 1<<(power))
+ 
+ 
+ /*************************************************************
+  Controlling Debugging Information Format
+ *************************************************************/
+ 
+ 
+ /*** Macros Affecting All Debugging Formats ****************/
+ 
+ /* ??? ... later */
+ /* #define DBX_REGISTER_NUMBER (regno) */
+ /* #define DEBUGGER_AUTO_OFFSET (x) */
+ /* #define DEBUGGER_ARG_OFFSET (offset, x) */
+ /* #define PREFERRED_DEBUGGING_TYPE */
+ 
+ /*** Specific Options for DBX Output ***********************/
+ 
+ /* #define DBX_DEBUGGING_INFO */
+ /* #define XCOFF_DEBUGGING_INFO */
+ /* #define DEFAULT_GDB_EXTENSIONS */
+ /* #define DEBUG_SYMS_TEXT */
+ /* #define ASM_STABS_OP */
+ /* #define ASM_STABD_OP */
+ /* #define ASM_STABN_OP */
+ /* #define DBX_NO_XREFS */
+ /* #define DBX_CONTIN_LENGTH */
+ /* #define DBX_CONTIN_CHAR */
+ /* #define DBX_STATIC_STAB_DATA_SECTION */
+ /* #define DBX_TYPE_DECL_STABS_CODE */
+ /* #define DBX_STATIC_CONST_VAR_CODE */
+ /* #define DBX_REGPARM_STABS_CODE */
+ /* #define DBX_REGPARM_STABS_LETTER */
+ /* #define DBX_MEMPARM_STABS_LETTER */
+ /* #define DBX_FUNCTION_FIRST */
+ /* #define DBX_LBRAC_FIRST */
+ /* #define DBX_BLOCKS_FUNCTION_RELATIVE */
+ 
+ /*** Open-Ended Hooks for DBX Format ***********************/
+ 
+ /* #define DBX_OUTPUT_LBRAC (stream, name) */
+ /* #define DBX_OUTPUT_RBRAC (stream, name) */
+ /* #define DBX_OUTPUT_ENUM (stream, type) */
+ /* #define DBX_OUTPUT_FUNCTION_END (stream, function) */
+ /* #define DBX_OUTPUT_STANDARD_TYPES (syms) */
+ 
+ /*** File Names in DBX Format ******************************/
+ 
+ /* #define DBX_WORKING_DIRECTORY */
+ /* #define DBX_OUTPUT_MAIN_SOURCE_FILENAME (stream, name) */
+ /* #define DBX_OUTPUT_MAIN_SOURCE_DIRECTORY (stream, name) */
+ /* #define DBX_OUTPUT_MAIN_SOURCE_FILE_END (stream, name) */
+ /* #define DBX_OUTPUT_SOURCE_FILENAME (stream, name) */
+ 
+ /*** Macros for SDB and DWARF Output ***********************/
+ 
+ /* #define SDB_DEBUGGING_INFO */
+ /* #define DWARF_DEBUGGING_INFO */
+ /* #define PUT_SDB_@dots{} */
+ /* #define SDB_DELIM */
+ /* #define SDB_GENERATE_FAKE */
+ /* #define SDB_ALLOW_UNKNOWN_REFERENCES */
+ /* #define SDB_ALLOW_FORWARD_REFERENCES */
+ 
+ 
+ /*************************************************************
+  Cross Compilation and Floating Point
+ *************************************************************/
+ 
+ /* Both t8 and sparc have IEEE, so no need to bother with this (lucky me :) */
+ 
+ /* #define REAL_VALUE_TYPE */
+ /* #define REAL_VALUES_EQUAL (x, y) */
+ /* #define REAL_VALUES_LESS (x, y) */
+ /* #define REAL_VALUE_LDEXP (x, scale) */
+ /* #define REAL_VALUE_FIX (x) */
+ /* #define REAL_VALUE_UNSIGNED_FIX (x) */
+ /* #define REAL_VALUE_RNDZINT (x) */
+ /* #define REAL_VALUE_UNSIGNED_RNDZINT (x) */
+ /* #define REAL_VALUE_ATOF (string, mode) */
+ /* #define REAL_INFINITY */
+ /* #define REAL_VALUE_ISINF (x) */
+ /* #define REAL_VALUE_ISNAN (x) */
+ /* #define REAL_ARITHMETIC (output, code, x, y) */
+ /* #define REAL_VALUE_NEGATE (x) */
+ /* #define REAL_VALUE_TRUNCATE (mode, x) */
+ /* #define REAL_VALUE_TO_INT (low, high, x) */
+ /* #define REAL_VALUE_FROM_INT (x, low, high) */
+ 
+ 
+ /*************************************************************
+  Miscellaneous Parameters
+ *************************************************************/
+ 
+ /*>#define PREDICATE_CODES */
+ /*>#define CASE_VECTOR_MODE */
+ /*>#define CASE_VECTOR_PC_RELATIVE */
+ /*>#define CASE_DROPS_THROUGH */
+ /*>#define CASE_VALUES_THRESHOLD */
+ /*>#define WORD_REGISTER_OPERATIONS */
+ /*>#define LOAD_EXTEND_OP (mode) */
+ /*>#define IMPLICIT_FIX_EXPR */
+ /*>#define FIXUNS_TRUNC_LIKE_FIX_TRUNC */
+ /*>#define EASY_DIV_EXPR */
+ /*>#define MOVE_MAX */
+ /*>#define MAX_MOVE_MAX */
+ /*>#define SHIFT_COUNT_TRUNCATED */
+ /*>#define TRULY_NOOP_TRUNCATION (outprec, inprec) */
+ /*>#define STORE_FLAG_VALUE */
+ /*>#define FLOAT_STORE_FLAG_VALUE */
+ /*>#define Pmode */
+ /*>#define FUNCTION_MODE */
+ /*>#define INTEGRATE_THRESHOLD (decl) */
+ 
+ /* Ignoring #sccs is better that barfing on it, I think... */
+ 
+ #define SCCS_DIRECTIVE
+ 
+ #undef NO_IMPLICIT_EXTERN_C
+ /* #define NO_IMPLICIT_EXTERN_C */
+ 
+ /*>#define HANDLE_PRAGMA(stream) */
+ /*>#define VALID_MACHINE_ATTRIBUTE(type, attributes, identifier) */
+ /*>#define COMP_TYPE_ATTRIBUTES(type1, type2) */
+ /*>#define SET_DEFAULT_TYPE_ATTRIBUTES(type) */
+ 
+ /*>#define DOLLARS_IN_IDENTIFIERS */
+ 
+ /* ACE as accepts both dollars and dots in labels, ok */
+ 
+ #undef NO_DOLLAR_IN_LABEL
+ #undef NO_DOT_IN_LABEL
+ 
+ /* don't think any UNIXish environment requires it */
+ 
+ #undef DEFAULT_MAIN_RETURN
+ 
+ /* 'nm [target]libc.a | grep atexit' finds it. */
+ 
+ #define HAVE_ATEXIT
+ 
+ #undef EXIT_BODY
+ 
+ /*>#define INSN_SETS_ARE_DELAYED(insn) */
+ /*>#define INSN_REFERENCES_ARE_DELAYED(insn) */
+ /*>#define MACHINE_DEPENDENT_REORG(insn)  */
+ 
+ /*************************************************************
+  Custom additions
+ *************************************************************/
+ 
+ /* In Parix `as', `ldc x' loads offset to x from current pc (rather
+    than absolute value of x).  This affects certain patterns in
+    t800.md.  */
+ 
+ #define T800_LDC_SYMBOL_PC_RELATIVE
+ 
+ /* Parix `as' automatically scales symbols in ldl/ldnl/ldnlp operand
+    expression.  Therefore we always output symrefs without scaling,
+    which would be normally done for code == 'w' */
+ 
+ #undef T800_PRINT_OPERAND_SYMREF
+ #define T800_PRINT_OPERAND_SYMREF(file, x, code) \
+   output_addr_const (file, x)
+ 
+ /* This overrides the standard handling of incoming arguments in
+    function.c:assign_parms().
+ 
+    copy_to_reg is important; otherwise, DECL_RTL for incoming
+    arguments looks like (mem (mem (reg))), which is not a valid
+    address, and code in fixup_var_refs_1 (when it happens to be
+    called) comes up with an unrecognizable insn for it.  */
+ 
+ #undef SETUP_INCOMING_ARGS_RTX
+ #define SETUP_INCOMING_ARGS_RTX(internal_arg_pointer, second_time) \
+   do {									\
+     internal_arg_pointer = gen_rtx (MEM, Pmode, virtual_incoming_args_rtx); \
+     RTX_UNCHANGING_P (internal_arg_pointer) = 1;			\
+     if (! second_time)							\
+       {									\
+         internal_arg_pointer = copy_to_reg (internal_arg_pointer);	\
+         RTX_UNCHANGING_P (internal_arg_pointer) = 1;			\
+       }									\
+   } while (0)
+ 
+ /* Generate RTX for data segment memory location to be used instead of
+    plain SYMBOL_REF.  */
+ 
+ #undef T800_DATASEG_START_RTX
+ #define T800_DATASEG_START_RTX \
+   (gen_rtx (MEM, Pmode,					\
+ 	    gen_rtx (PLUS, Pmode,			\
+ 		     gen_rtx (REG, Pmode, R_WREG),	\
+ 		     GEN_INT (3 * UNITS_PER_WORD))))
+ 
+ 
+ /* Indicate that assembler cannot handle things like `adc .LL1-.LL2'. */
+ 
+ #undef T800_AS_ADC_LABELDIFF_OK
+ #define T800_AS_ADC_LABELDIFF_OK  0
+ 
+ 
+ /* C statements to output code for `return' pattern.  */
+ 
+ #undef T800_OUTPUT_RETURN
+ #define T800_OUTPUT_RETURN \
+   int totsize = IN_WORDS (get_frame_size ()) +				\
+                 IN_WORDS (current_function_outgoing_args_size) +       	\
+ 		IN_WORDS (STACK_POINTER_OFFSET);			\
+   rtx xop[1];								\
+ 									\
+   if (current_function_pretend_args_size)				\
+     abort ();								\
+ 									\
+   xop[0] = GEN_INT (totsize);						\
+   output_asm_insn ("ajw +%0", xop);					\
+ 									\
+   /* ... structured values are returned in a location allocated by	\
+      the caller and pointed to by resptr.  Additionally, resptr is	\
+      returned in Areg */						\
+ 									\
+   if (current_function_returns_struct)					\
+     {									\
+       xop[0] = GEN_INT (4);						\
+       output_asm_insn ("ldl %0", xop);					\
+     }									\
+   return "ret";
+ 
+ 
+ /* C statements to output code for `call' pattern(s).  */
+ 
+ #undef T800_OUTPUT__CALL
+ #define T800_OUTPUT__CALL \
+   do {									\
+     rtx xop[1];								\
+ 									\
+     /* if the functioin takes any args, fill the args_size word */	\
+     if (operands[2] != const0_rtx) 					\
+       {									\
+         xop[0] = operands[2];						\
+         output_asm_insn ("ldc %0", xop);				\
+         output_asm_insn ("stl 4", xop);					\
+       }									\
+ 									\
+     /* If the function being called returns an aggregate, Areg is	\
+        preloaded with output location address (STRUCT_VALUE_REGNUM).	\
+        Otherwise, Areg contains a garbage which I think is perfectly	\
+        valid to pass as resptr in this case, it isn't going to be used	\
+        anyway.								\
+ 									\
+        If the call doesn't take any args, we don't load argptr either	\
+        -- unless the call is aggregate valued, in which case we need	\
+        to load something for argptr in order for resptr to arrive in	\
+        the proper register.  */						\
+ 									\
+     /* argptr */							\
+     if (operands[2] != const0_rtx					\
+         || GET_MODE (PATTERN (insn)) == BLKmode)			\
+       {									\
+         xop[0] = GEN_INT (WORD_ROUND (STACK_POINTER_OFFSET));		\
+         output_asm_insn ("ldlp %w0", xop);				\
+       }									\
+ 									\
+     /* MDLptr */							\
+     xop[0] = GEN_INT (1 * UNITS_PER_WORD  /* MDLptr offset */		\
+ 		      + WORD_ROUND (get_frame_size ())			\
+ 		      + WORD_ROUND (current_function_outgoing_args_size)\
+ 		      + WORD_ROUND (STACK_POINTER_OFFSET));		\
+     output_asm_insn ("ldl %w0", xop);					\
+ 									\
+     output_asm_insn ("call %1", operands);				\
+ 									\
+     return "";								\
+   } while (0)
+ 
+ 
+ /* C statements to output code for `gcall' pattern(s).
+ 
+    For gcall, we have to do by hand what normal `call' does
+    automatically, including storing return address on the stack */
+ 
+ #undef T800_OUTPUT__GCALL
+ #define T800_OUTPUT__GCALL \
+   do {									\
+     rtx xop[1];								\
+ 									\
+     output_asm_insn ("ajw -4", xop);					\
+ 									\
+     /* If the function being called returns an aggregate, Areg is	\
+        preloaded with output location address (STRUCT_VALUE_REGNUM),	\
+        while function address is shifted to Breg.  If so, we first	\
+        store Areg down to resptr, which also shifts function address	\
+        to its normal position (Areg).					\
+ 									\
+        For non-aggregate-valued calls, we don't write resptr: it isn't	\
+        going to be used then anyway.					\
+ 									\
+        For argumentless calls, we don't write argptr. */		\
+ 									\
+     /* resptr */							\
+     if (GET_MODE (XEXP (XVECEXP (PATTERN (insn), 0, 0), 1)) != VOIDmode)\
+       output_asm_insn ("stl 3", xop);					\
+ 									\
+     /* argptr */							\
+     if (operands[2] != const0_rtx)					\
+       {									\
+         xop[0] = GEN_INT (WORD_ROUND (STACK_POINTER_OFFSET)		\
+                           + 4 * UNITS_PER_WORD);  /* ajw compensation */\
+         output_asm_insn ("ldlp %w0", xop);				\
+         output_asm_insn ("stl 2", xop);					\
+       }									\
+ 									\
+     /* MDLptr */							\
+     xop[0] = GEN_INT (1 * UNITS_PER_WORD  /* MDLptr offset */		\
+ 		      + WORD_ROUND (get_frame_size ())			\
+ 		      + WORD_ROUND (current_function_outgoing_args_size)\
+ 		      + WORD_ROUND (STACK_POINTER_OFFSET)		\
+ 		      + 4 * UNITS_PER_WORD);  /* ajw compensation */	\
+     output_asm_insn ("ldl %w0", xop);					\
+     output_asm_insn ("stl 1", xop);					\
+ 									\
+     /* return address */						\
+     output_asm_insn ("ldc 2", xop);					\
+     output_asm_insn ("ldpi", xop);					\
+     output_asm_insn ("stl 0", xop);					\
+ 									\
+     /* alternative 0 is for address in Areg, alternative 1 for		\
+        constant address.  The latter uses `j' instead of `gcall' */	\
+ 									\
+     if (which_alternative == 0)						\
+       output_asm_insn ("gcall", xop);					\
+     else								\
+       output_asm_insn ("j %1", operands);				\
+ 									\
+     return "";								\
+   } while (0)
+ 
+ /* Parix AS doesn't know what `pfix' is.  Let's put it simpler...  */
+ 
+ #undef T800_OUTPUT_NOP
+ #define T800_OUTPUT_NOP  return ".byte 0x20";
+ 
+ #undef T800_EXPAND_ALLOCATE_STACK
+ #define T800_EXPAND_ALLOCATE_STACK \
+     fatal ("The program being compiled requires dynamic stack space allocation which is not implemented in Expert run-time model.  So much sorry.");
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/config/t800/float.h gcc-2.7.2-t800.12/config/t800/float.h
*** gcc-2.7.2/config/t800/float.h	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/config/t800/float.h	Mon May 13 22:36:47 1996
***************
*** 0 ****
--- 1,67 ----
+ /* float.h */
+ #ifndef _FLOAT_H___
+ #define _FLOAT_H___
+ 
+    /* Radix of exponent representation */
+ #undef FLT_RADIX
+ #define FLT_RADIX 2
+    /* Number of base-FLT_RADIX digits in the significand of a float */
+ #undef FLT_MANT_DIG
+ #define FLT_MANT_DIG 24
+    /* Number of decimal digits of precision in a float */
+ #undef FLT_DIG
+ #define FLT_DIG 6
+    /* Addition rounds to 0: zero, 1: nearest, 2: +inf, 3: -inf, -1: unknown */
+ #undef FLT_ROUNDS
+ #define FLT_ROUNDS 1
+    /* Difference between 1.0 and the minimum float greater than 1.0 */
+ #undef FLT_EPSILON
+ #define FLT_EPSILON 1.19209290e-07F
+    /* Minimum int x such that FLT_RADIX**(x-1) is a normalised float */
+ #undef FLT_MIN_EXP
+ #define FLT_MIN_EXP (-125)
+    /* Minimum normalised float */
+ #undef FLT_MIN
+ #define FLT_MIN 1.17549435e-38F
+    /* Minimum int x such that 10**x is a normalised float */
+ #undef FLT_MIN_10_EXP
+ #define FLT_MIN_10_EXP (-37)
+    /* Maximum int x such that FLT_RADIX**(x-1) is a representable float */
+ #undef FLT_MAX_EXP
+ #define FLT_MAX_EXP 128
+    /* Maximum float */
+ #undef FLT_MAX
+ #define FLT_MAX 3.40282347e+38F
+    /* Maximum int x such that 10**x is a representable float */
+ #undef FLT_MAX_10_EXP
+ #define FLT_MAX_10_EXP 38
+ 
+    /* Number of base-FLT_RADIX digits in the significand of a double */
+ #undef DBL_MANT_DIG
+ #define DBL_MANT_DIG 53
+    /* Number of decimal digits of precision in a double */
+ #undef DBL_DIG
+ #define DBL_DIG 15
+    /* Difference between 1.0 and the minimum double greater than 1.0 */
+ #undef DBL_EPSILON
+ #define DBL_EPSILON 2.2204460492503131e-16
+    /* Minimum int x such that FLT_RADIX**(x-1) is a normalised double */
+ #undef DBL_MIN_EXP
+ #define DBL_MIN_EXP (-1021)
+    /* Minimum normalised double */
+ #undef DBL_MIN
+ #define DBL_MIN 2.2250738585072014e-308
+    /* Minimum int x such that 10**x is a normalised double */
+ #undef DBL_MIN_10_EXP
+ #define DBL_MIN_10_EXP (-307)
+    /* Maximum int x such that FLT_RADIX**(x-1) is a representable double */
+ #undef DBL_MAX_EXP
+ #define DBL_MAX_EXP 1024
+    /* Maximum double */
+ #undef DBL_MAX
+ #define DBL_MAX 1.7976931348623157e+308
+    /* Maximum int x such that 10**x is a representable double */
+ #undef DBL_MAX_10_EXP
+ #define DBL_MAX_10_EXP 308
+ 
+ #endif /*  _FLOAT_H___ */
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/config/t800/t-parix gcc-2.7.2-t800.12/config/t800/t-parix
*** gcc-2.7.2/config/t800/t-parix	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/config/t800/t-parix	Tue Jan 23 10:11:36 1996
***************
*** 0 ****
--- 1,15 ----
+ # (For development stage): Don't try to build C++ or Objective C by
+ # default.  The space before LANGUAGES avoids changing this line by
+ # configure.
+  LANGUAGES=c
+ 
+ # Add more dependencies for reg-stack.o because it #includes
+ # reg-stack2.c.  Although including .c file in another .c file
+ # is nasty, should get rid of this eventually...
+ reg-stack.o: reg-stack2.c reg-stack.h $(CONFIG_H) $(RTL_H) $(TREE_H) \
+   tree.h rtl.h insn-config.h insn-codes.h insn-flags.h insn-attr.h regs.h \
+   flags.h recog.h output.h hard-reg-set.h
+ 
+ # libgcc1-test shows we need no functions from libgcc1.  So don't build it.
+ LIBGCC1 =
+ CROSS_LIBGCC1 =
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/config/t800/t-t800 gcc-2.7.2-t800.12/config/t800/t-t800
*** gcc-2.7.2/config/t800/t-t800	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/config/t800/t-t800	Fri May 24 18:27:53 1996
***************
*** 0 ****
--- 1,48 ----
+ # (For development stage): Don't try to build C++ or Objective C by
+ # default.  The space before LANGUAGES avoids changing this line by
+ # configure.
+  LANGUAGES=c
+ 
+ # Add more dependencies for reg-stack.o because it #includes
+ # reg-stack2.c.  Although including .c file in another .c file
+ # is nasty, should get rid of this eventually...
+ reg-stack.o: reg-stack2.c reg-stack.h $(CONFIG_H) $(RTL_H) $(TREE_H) \
+   tree.h rtl.h insn-config.h insn-codes.h insn-flags.h insn-attr.h regs.h \
+   flags.h recog.h output.h hard-reg-set.h
+ 
+ # We don't have stdio for t800 yet, so don't let libgcc2.c use stdio.h
+ LIBGCC2_INCLUDES = -Dinhibit_libc
+ 
+ # libgcc1-test shows we need no functions from libgcc1.  So don't build it.
+ LIBGCC1 =
+ CROSS_LIBGCC1 =
+ 
+ # Since libgcc1-test is linked without crt0, we need to change the lit
+ # hook from the default @@hook to the entry point of libgcc1-test.c
+ LIBGCC1_LDFLAGS = -Wl,--hook,_main_without__main
+ 
+ # building enquire requires some libc headers, which we don't have.
+ # So don't build it by default; "make enquire" is you really need it.
+ ENQUIRE = 
+ 
+ # Since you most likely don't have libc for target handy, using
+ # enquire to build float.h is not feasible.  So use a premade one
+ # (thanks to Roman Pozlevich <roma@roma.botik.ru>
+ CROSS_FLOAT_H = $(srcdir)/config/t800/float.h
+ 
+ # Enable FP emulation for transputers that lack FPU
+ # (thanks to Roman Pozlevich <roma@roma.botik.ru>
+ 
+ # These are really part of libgcc1, but this will cause them to be
+ # built correctly, so...
+ 
+ LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c
+ 
+ dp-bit.c: $(srcdir)/config/fp-bit.c
+ 	echo '#define FLOAT_BIT_ORDER_MISMATCH' > dp-bit.c
+ 	cat $(srcdir)/config/fp-bit.c >> dp-bit.c
+ 
+ fp-bit.c: $(srcdir)/config/fp-bit.c
+ 	echo '#define FLOAT' > fp-bit.c
+ 	echo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c
+ 	cat $(srcdir)/config/fp-bit.c >> fp-bit.c
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/config/t800/t800.c gcc-2.7.2-t800.12/config/t800/t800.c
*** gcc-2.7.2/config/t800/t800.c	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/config/t800/t800.c	Fri Apr 18 23:19:18 1997
***************
*** 0 ****
--- 1,1930 ----
+ /* Subroutines used for code generation on transputer.
+    Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
+ 
+    Written by Yury Shevchuk <sizif@botik.ru>
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ #include <stdio.h>
+ #include <limits.h>
+ #include "config.h"
+ #include "rtl.h"
+ #include "real.h"
+ #include "insn-config.h"
+ #include "insn-flags.h"
+ #include "regs.h"
+ #include "expr.h"
+ #include "recog.h"
+ #include "reload.h"
+ #include "output.h"
+ #include "hard-reg-set.h"
+ #include "reg-stack.h"
+ 
+ 
+ rtx force_ABCreg PROTO((enum machine_mode, rtx));
+ rtx my_emit_jump_insn PROTO((rtx, rtx));
+ int t800_expand_compare PROTO((enum rtx_code, rtx *));
+ static int is_offset PROTO((rtx op));
+ int t800_dataseg_symrefs_mentioned_p PROTO((rtx));
+ static void t800_output_addr_const PROTO((FILE *, rtx, int));
+ static void assert_sane_reg PROTO((rtx));
+ 
+ 
+ /* This is where cmpM pattern saves its arguments so that
+    following sCC or bCC can use them */
+ 
+ struct t800_compare t800_compare;
+ 
+ /* This allows instruction patterns to find out whether we're doing
+    initialization or the actual RTL generation.  */
+ 
+ int t800_init_once_completed;
+ 
+ /* This implements the REGISTER_MOVE_COST macro.  */
+ 
+ char register_move_cost[FIRST_PSEUDO_REGISTER][FIRST_PSEUDO_REGISTER] = {
+   { 2,  2,  2, 10, 10, 10,  2,  2,  2},     /*R_AREG*/   
+   { 2,  2,  2, 10, 10, 10,  2,  2,  2},     /*R_BREG*/   
+   { 2,  2,  2, 10, 10, 10,  2,  2,  2},     /*R_CREG*/   
+   {10, 10, 10,  2,  2,  2, 14, 14, 14},     /*R_FAREG*/  
+   {10, 10, 10,  2,  2,  2, 14, 14, 14},     /*R_FBREG*/  
+   {10, 10, 10,  2,  2,  2, 14, 14, 14},     /*R_FCREG*/  
+   { 2,  2,  2, 14, 14, 14,  2,  2,  2},     /*R_WREG*/   
+   { 2,  2,  2, 14, 14, 14,  2,  2,  2},     /*R_FAKE1*/
+   { 2,  2,  2, 14, 14, 14,  2,  2,  2},     /*R_FAKE2*/
+ };
+ 
+ /* Stored by output__my_fancy_tablejump, checked by ASM_OUTPUT_ADDR_DIFF_ELT
+    to make sure that table_rel_label has not been optimized away. */
+ 
+ int t800_expected_table_label;
+ 
+ 
+ /************************************************************
+  Helper functions for t800.h macros
+ ************************************************************/
+ 
+ /* PRINT_OPERAND implementation.  On transputers, what eventually gets
+    printed is always a constant expression.  But operand (X) may be
+    some other RTX, eg MEM; the machine description allows this because
+    it is more efficient.  This routine first finds the constant to be
+    printed inside of X. */
+ 
+ void
+ print_operand(stream, x, code)
+     FILE *stream;
+     rtx x;
+     int code;
+ {
+   if (GET_CODE (x) == MEM)
+     x = XEXP (x, 0);
+ 
+   if (GET_CODE (x) == PLUS)
+     {
+       /* (plus ([WABC]reg) (const_int|symbol_ref|const))  */
+       assert_sane_reg (XEXP (x, 0));
+       x = XEXP (x, 1);
+     }
+ 
+   if (GET_CODE (x) == REG)
+     {
+       /* equivalent to (plus ([WABC]reg) (const_int 0))  */
+       assert_sane_reg (x);
+       x = GEN_INT (0);
+     }
+ 
+   /* Now x should be suitable for t800_output_addr_const.  It will
+      abort if not.  */
+ 
+   t800_output_addr_const (stream, x, code);
+ }
+ 
+ 
+ /* Variation of generic output_addr_const: less general but handles
+    `code' argument from PRINT_OPERAND */
+ 
+ void
+ t800_output_addr_const (file, x, code)
+      FILE *file;
+      rtx x;
+      int code;
+ {
+   HOST_WIDE_INT val;
+ 
+  restart:
+   switch (GET_CODE (x))
+     {
+     case SYMBOL_REF:
+ #ifdef T800_PRINT_OPERAND_SYMREF
+       /* Some assemblers don't need the scaling we do for 'w' on SYMBOL_REF's */
+       T800_PRINT_OPERAND_SYMREF (file, x, code);
+ #else
+       output_addr_const (file, x);
+       if (code == 'w')
+ 	fprintf (file, "/%d", UNITS_PER_WORD);
+ #endif
+       break;
+ 
+     case LABEL_REF:
+     case CODE_LABEL:
+       output_addr_const (file, x);
+       break;
+ 
+     case CONST_INT:
+       switch (code)
+ 	{
+ 	case 'w':	/* word offset */
+ 	  if (INTVAL (x) % UNITS_PER_WORD)
+ 	    abort ();
+ 	  /*FALL THROUGH*/
+ 	case 'q':	/* quotient */
+ 	  val = INTVAL (x) / UNITS_PER_WORD;
+ 	  break;
+ 
+ 	case 'r':	/* remainder */
+ 	  val = INTVAL (x) % UNITS_PER_WORD;
+ 	  break;
+ 
+ 	case 0:		/* output it as it is */
+ 	  val = INTVAL (x);
+ 	  break;
+ 
+ 	default:
+ 	  abort ();
+ 	}
+ 	  
+       fprintf (file,
+ #if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT
+ 	       "%d",
+ #else
+ 	       "%ld",
+ #endif
+ 	       val);
+       break;
+ 
+     case CONST:
+       t800_output_addr_const (file, XEXP (x, 0), code);
+       break;
+ 
+     case PLUS:
+       /* Some assemblers need integer constants to appear last (eg masm).  */
+       if (GET_CODE (XEXP (x, 0)) == CONST_INT)
+ 	{
+ 	  t800_output_addr_const (file, XEXP (x, 1), code);
+ 	  if (INTVAL (XEXP (x, 0)) >= 0)
+ 	    fprintf (file, "+");
+ 	  t800_output_addr_const (file, XEXP (x, 0), code);
+ 	}
+       else
+ 	{
+ 	  t800_output_addr_const (file, XEXP (x, 0), code);
+ 	  if (INTVAL (XEXP (x, 1)) >= 0)
+ 	    fprintf (file, "+");
+ 	  t800_output_addr_const (file, XEXP (x, 1), code);
+ 	}
+       break;
+ 
+     case MINUS:
+       /* Avoid outputting things like x-x or x+5-x,
+ 	 since some assemblers can't handle that.  */
+       x = simplify_subtraction (x);
+       if (GET_CODE (x) != MINUS)
+ 	goto restart;
+ 
+       t800_output_addr_const (file, XEXP (x, 0), code);
+       fprintf (file, "-");
+       if (GET_CODE (XEXP (x, 1)) == CONST_INT
+ 	  && INTVAL (XEXP (x, 1)) < 0)
+ 	{
+ 	  fprintf (file, ASM_OPEN_PAREN);
+ 	  t800_output_addr_const (file, XEXP (x, 1), code);
+ 	  fprintf (file, ASM_CLOSE_PAREN);
+ 	}
+       else
+ 	t800_output_addr_const (file, XEXP (x, 1), code);
+       break;
+ 
+     default:
+       abort ();
+     }
+ }
+ 
+ 
+ /* Check if we have register eliminations done.  Any fake registers
+    must be eliminated by now; the only valid register in WREG family
+    after reload is Wreg itself. */
+ 
+ static void
+ assert_sane_reg (x)
+      rtx x;
+ {
+   if (GET_CODE (x) != REG || REGNO (x) > R_WREG)
+     abort ();
+ }
+ 
+ 
+ int
+ t800_address_cost (x)
+     rtx x;
+ {
+   int cost = 0;
+ 
+ again:
+   switch (GET_CODE (x))
+     {
+     case PLUS:
+       if (GET_CODE (XEXP (x, 1)) != CONST_INT)
+         /* An illegal address; the return value does not matter.  */
+         goto Default;
+ 
+       cost = t800_const_cost (INTVAL (XEXP (x, 1)) / UNITS_PER_WORD);
+       x = XEXP (x, 0);
+       goto again;
+ 
+     case REG:
+       /* Local addresses are preferable, since Wreg is not subject to
+          spill.  Prefer them whenever possible.  */
+       return cost + 1
+ 	- (TEST_HARD_REG_BIT (reg_class_contents[WORKSPACE_REGS], REGNO (x)));
+ 
+     case LABEL_REF:
+     case SYMBOL_REF:
+       /* There is no way to find the true cost of it, because we don't
+          know how far the label is. Make it relatively cheap in the
+          hope that the labels are not too far, on the average.  */
+       return cost + 3;
+ 
+     Default:
+     default:
+       /* Probably invalid address */
+       return 10;
+     }
+ }
+ 
+ /* Tell how costly the constant is. On transputers, this can be
+    measured as the amount of {pfix,nfix} insns needed.  */
+ 
+ int
+ t800_const_cost (i)
+   int i;
+ {
+   int cost = 0;
+ 
+   if (i < 0)
+     {
+       if (i >= (signed int)0xfffffff0U)
+         /* This takes an extra nfix only to obtain sign-extension */
+         cost++;
+       i = ~i;
+     }
+   while (i = (unsigned)i >> 4)
+     cost++;
+ 
+   return cost;
+ }
+ 
+ /* The implementation of SECONDARY_MEMORY_NEEDED macro.  Copying
+    between floating and any other reg on transputers requires an
+    intermediate memory location. */
+ 
+ #ifdef SECONDARY_MEMORY_NEEDED
+ int
+ secondary_memory_needed(class1, class2, mode)
+   enum reg_class class1;
+   enum reg_class class2;
+   enum machine_mode mode;
+ {
+   int float_reg_1 = 1;
+   int float_reg_2 = 1;
+ 
+   GO_IF_HARD_REG_SUBSET (reg_class_contents[class1],
+                          reg_class_contents[FLOAT_REGS], m1);
+   float_reg_1 = 0;
+ m1:
+ 
+   GO_IF_HARD_REG_SUBSET (reg_class_contents[class2],
+                          reg_class_contents[FLOAT_REGS], m2);
+   float_reg_2 = 0;
+ m2:
+ 
+   return float_reg_1 ^ float_reg_2;
+ }
+ #endif /* SECONDARY_MEMORY_NEEDED */
+ 
+ 
+ static int regno_to_find;
+ 
+ static int
+ find_popped_regno (insn, popped_reg)
+      rtx insn, popped_reg;
+ {
+   register popped_regno;
+ 
+   if (GET_CODE (popped_reg) == SUBREG)
+     popped_regno = REGNO (SUBREG_REG (popped_reg)) + SUBREG_WORD (popped_reg);
+   else
+     popped_regno = REGNO (popped_reg);
+ 
+   return (popped_regno == regno_to_find);
+ }
+ 
+ int
+ insn_clobbers_regno_p (insn, regno)
+   rtx insn;
+   int regno;
+ {
+   regno_to_find = regno;
+   return note_popped_inputs (insn, find_popped_regno);
+ }
+ 
+ int
+ t800_fp_class (c)
+   enum reg_class c;
+ {
+   GO_IF_HARD_REG_SUBSET (reg_class_contents[c],
+                          reg_class_contents[FLOAT_REGS], yes);
+   return 0;
+ yes:
+   return 1;
+ }
+ 
+ /* Attempt to convert memory address X into a valid one.  */
+ 
+ rtx
+ t800_legitimize_address (x, oldx, mode)
+      rtx x;
+      rtx oldx;
+      enum machine_mode mode;
+ {
+ 
+   /* (PLUS (MULT r1 4) r2)) , where r[12] are ABCregs, can be
+      legitimized by loading into a reg with a single `wsub' insn. */
+ 
+   if (GET_CODE (x) == PLUS
+       && GET_CODE (XEXP (x, 0)) == MULT)
+     {
+       rtx factor = XEXP (XEXP (x, 0), 1);
+       if (wsub_scale_operand (factor, VOIDmode))
+         {
+           rtx newx = gen_reg_rtx (SImode);
+           rtx base = XEXP (x, 1);
+           rtx index = XEXP (XEXP (x, 0), 0);
+ 
+           base = force_ABCreg (SImode, force_operand (base, 0));
+           index = force_ABCreg (SImode, force_operand (index, 0));
+           emit_insn (gen__wsub (newx, base, index, factor));
+ 	  return newx;
+         }
+     }
+ 
+   /* Now if this is a (plus (...) (const_int offset)) where `offset'
+      is not a word-multiple, just copy it to a pseudo.  Otherwise
+      memory_address will generate superfluous pseudo in attempt to
+      make an indexed address, which is not useful here anyway.  */
+ 
+   if (GET_CODE (x) == PLUS
+       && GET_CODE (XEXP (x, 1)) == CONST_INT
+       && (INTVAL (XEXP (x, 1)) % UNITS_PER_WORD) != 0)
+     return copy_addr_to_reg (x);
+ 
+   /* Know no special tricks for legitimizing this; let the compiler do
+      it in common way */
+   return x;
+ }
+ 
+ 
+ /************************************************************
+  Predicates for use in (match_operand ...)
+ ************************************************************/
+ 
+ /* Return 1 if an operand OP is a local memory reference */
+ 
+ int
+ local_operand (op, mode)
+      rtx op;
+      enum machine_mode mode;
+ {
+   if (mode != VOIDmode && GET_MODE (op) != mode)
+     return 0;
+ 
+   /* Strip SUBREG; this allows for (subreg (failed_pseudo_reg))
+      and (subreg (mem (local_operand_address)))  */
+   if (GET_CODE (op) == SUBREG)
+       op = SUBREG_REG (op);
+ 
+   /* When reload is in progress, pseudo-regs are the ones failed to get
+      hard regs and therefore destined to stack slots. Thus, pseudo-reg
+      is a local operand when reload is in progress */
+   if (reload_in_progress && true_regnum (op) >= FIRST_PSEUDO_REGISTER)
+       return(1);
+ 
+   /* Reject non-memory operations */
+   if (GET_CODE (op) != MEM)
+     return 0;
+ 
+   return local_operand_address (XEXP (op,0), mode);
+ }
+ 
+ 
+ /* Return non-zero if an operand OP is a local memory address, i.e.
+    (Wreg [+ offset]).  Offset is checked to be satisfactory for MODE.
+    (in assumption that Wreg is always aligned well enough for any mode).  */
+ 
+ int
+ local_operand_address (addr, mode)
+      rtx addr;
+      enum machine_mode mode;
+ {
+   if (GET_CODE (addr) == PLUS)
+     {
+       if (GET_CODE (XEXP (addr, 1)) != CONST_INT
+ 	  || (INTVAL (XEXP (addr, 1)) % UNITS_PER_WORD) != 0)
+         return 0;
+       addr = XEXP (addr, 0);
+     }
+ 
+   return Wreg_operand (addr, Pmode);
+ }
+ 
+ 
+ /* Return 1 if an operand OP is a non-local memory reference,
+    i.e. (mem (match_operand "ABCreg_operand")) */
+ 
+ int
+ nonlocal_operand (op, mode)
+      rtx op;
+      enum machine_mode mode;
+ {
+   if (GET_CODE (op) != MEM)
+     return 0;
+ 
+   if (mode != VOIDmode && GET_MODE (op) != mode)
+     return 0;
+ 
+   return (ABCreg_operand (XEXP (op, 0), SImode));
+ }
+ 
+ 
+ /* Return 1 if an operand OP is an offsetted non-local memory reference,
+    i.e. (mem (plus (match_operand "ABCreg_operand") (const_int))) */
+ 
+ int
+ nonlocal_plus_operand (op, mode)
+      rtx op;
+      enum machine_mode mode;
+ {
+   rtx addr;
+ 
+   if (GET_CODE (op) != MEM)
+     return 0;
+   if (mode != VOIDmode && GET_MODE (op) != mode)
+     return 0;
+ 
+   addr = XEXP (op, 0);
+   if (GET_CODE (addr) == PLUS)
+     {
+       rtx x = XEXP (addr, 1);
+ 
+       if (GET_CODE (x) == CONST_INT
+ 	  && (INTVAL (x) % UNITS_PER_WORD) == 0)
+ 	goto win;
+ 
+       if (TARGET_DATASEG_BY_POINTER)
+ 	{
+ 	  if (GET_CODE (x) == SYMBOL_REF
+ 	      && SYMBOL_REF_FLAG (x) == 1)
+ 	    goto win;
+ 
+ 	  if (GET_CODE (x) == CONST)
+ 	    {
+ 	      rtx x1 = XEXP (x, 0);
+ 
+ 	      /* If there is a non-word constant offset, this address
+ 		 does not match.  */
+ 
+ 	      if (GET_CODE (x1) == PLUS
+ 		  && GET_CODE (XEXP (x1, 1)) == CONST_INT
+ 		  && (INTVAL (XEXP (x1, 1)) % UNITS_PER_WORD) != 0)
+ 		return 0;
+ 
+ 	      /* The rest may be arbitrarily complex expression
+ 		 of symrefs.  Assuming data and code segment labels
+ 		 never mix in CONST, a simple check for presence
+ 		 of data segment symref should be enough.  */
+ 
+ 	      if (t800_dataseg_symrefs_mentioned_p (x1))
+ 		goto win;
+ 	    }
+ 	}
+       return 0;
+     win:
+       addr = XEXP (addr, 0);
+     }
+ 
+   return (ABCreg_operand (addr, SImode));
+ }
+ 
+ 
+ /* Return 1 if OP is a valid offset from a word pointer, i.e.
+    a constant which is a multiple of word size.  For use as
+    operand for ldnlp.  */
+ 
+ int
+ word_offset_operand (op, mode)
+      register rtx op;
+      enum machine_mode mode;
+ {
+   if (GET_CODE (op) == CONST_INT
+       && (INTVAL (op) % UNITS_PER_WORD) == 0)
+     return 1;
+ 
+   /* In dataseg-by-pointer model, data segment SYMBOL_REF's are
+      converted into offsets from data segment start by print_operand.
+      As they are word aligned, they can be given to ldnlp.  */
+ 
+   if (TARGET_DATASEG_BY_POINTER)
+     {
+       if (GET_CODE (op) == SYMBOL_REF
+ 	  && SYMBOL_REF_FLAG (op) == 1)
+ 	return 1;
+ 
+       if (GET_CODE (op) == CONST
+ 	  && (GET_CODE (XEXP (op, 0)) == PLUS
+ 	      || GET_CODE (XEXP (op, 0)) == MINUS))
+ 
+ 	/* Walk RHS first as it seems more likely to prove
+ 	   unacceptable (non-word-multiple CONST_INT) */
+ 
+ 	return word_offset_operand (XEXP (XEXP (op, 0), 1), VOIDmode)
+ 	  && word_offset_operand (XEXP (XEXP (op, 0), 0), VOIDmode);
+     }
+   return 0;
+ }
+ 
+ 
+ /* Return 1 if OP is a valid operand for adc instruction, which is a
+    CONST_INT or (in dataseg-by-pointer model) data segment symbolic
+    expression, because it will be relocated in link time.
+ 
+    ??? We could try to use immediate_operand for that, but it requires
+    to make LEGITIMATE_CONSTANT more restrictive (not accept
+    LABEL_REFs, for example), and I'm afraid that will affect handling
+    of JUMP/CALL insns, for which LABEL_REF is valid.  It's simpler to
+    have a separate predicate... */
+ 
+ int
+ adc_operand (op, mode)
+      register rtx op;
+      enum machine_mode mode;
+ {	
+   if (GET_CODE (op) == CONST_INT)
+     return 1;
+ 
+   if (TARGET_DATASEG_BY_POINTER)
+     {
+       if (GET_CODE (op) == SYMBOL_REF
+ 	  && SYMBOL_REF_FLAG (op) == 1)
+ 	return 1;
+ 
+       if (GET_CODE (op) == CONST
+ 	  && t800_dataseg_symrefs_mentioned_p (XEXP (op, 0)))
+ 	return 1;
+     }
+   return 0;
+ }
+ 
+ /* Return 1 if OP is a symbolic offset expression, such as
+    (CONST (MINUS L1 L2)) */
+ 
+ int
+ const_offset_operand (op, mode)
+      register rtx op;
+      enum machine_mode mode;
+ {
+   if (mode != VOIDmode && GET_MODE (op) != mode)
+     return 0;
+ 
+   if (GET_CODE (op) != CONST)
+     return 0;
+ 
+   return is_offset (XEXP (op,0));
+ }
+ 
+ /* Helper routine for const_offset_operand.  Given a CONST body,
+    return 1 if it is of int type (e.g. L1-L2), return 0 if it is of
+    pointer type (e.g. L1+5) */
+ 
+ static int
+ is_offset (op)
+      register rtx op;
+ {
+   switch (GET_CODE (op))
+     {
+     case PLUS:
+       return is_offset (XEXP (op, 0)) && is_offset (XEXP (op, 0));
+ 
+     case MINUS:
+       return is_offset (XEXP (op, 0)) == is_offset (XEXP (op, 0));
+ 
+     case CONST_INT:
+       return 1;
+ 
+     case LABEL_REF:
+     case SYMBOL_REF:
+       return 0;
+ 
+     default:
+       abort ();
+     }
+ }
+ 
+ 
+ /* Return 1 if OP is a valid operand for ldpi instruction, ie. is a
+    program-counter-relative address.  */
+ 
+ int
+ ldpi_operand (op, mode)
+      register rtx op;
+      enum machine_mode mode;
+ {
+   if (mode != VOIDmode && GET_MODE (op) != mode)
+     return 0;
+ 
+   if (GET_CODE (op) == LABEL_REF)
+     return 1;
+ 
+   /* Int type CONST's (e.g L1-L2) are not acceptable for ldpi -- we
+      don't want to let ldpi add PC to them! */
+ 
+   if (GET_CODE (op) == CONST && const_offset_operand (op, mode))
+     return 0;
+   
+   /* If data segment is pc-relative, all SYMBOL_REF's are OK; but if
+      data segment is addressed by pointer, we don't want to use ldpi
+      for loading data segment addresses, so reject data segment
+      SYMBOL_REF's.  (ENCODE_SECTION_INFO marks data segment SYMREF's
+      with `1' in SYMBOL_REF_FLAG) */
+ 
+   if (TARGET_DATASEG_PC_RELATIVE)
+     return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST);
+   else
+     {
+      /* Reject SYMREF's if they belong to data segment
+        (ENCODE_SECTION_INFO marks such SYMREF's with `1' in
+        SYMBOL_REF_FLAG) */
+ 
+       if (GET_CODE (op) == SYMBOL_REF)
+ 	return SYMBOL_REF_FLAG (op) != 1;
+ 
+       /* Likewise for SYMREF's hidden inside CONST */
+     
+       if (GET_CODE (op) == CONST)
+ 	return ! t800_dataseg_symrefs_mentioned_p (op);
+     }
+ 
+   return 0;
+ }
+ 
+ 
+ int
+ t800_dataseg_symrefs_mentioned_p (pat)
+      rtx pat;
+ {
+   register char *fmt;
+   register int i, j;
+ 
+   if (GET_CODE (pat) == SYMBOL_REF)
+     return SYMBOL_REF_FLAG (pat) == 1;
+   else
+     {
+       fmt = GET_RTX_FORMAT (GET_CODE (pat));
+       for (i = GET_RTX_LENGTH (GET_CODE (pat)); --i >= 0; )
+ 	if (fmt[i] == 'E')
+ 	  {
+ 	    for (j = XVECLEN (pat, i); --j >= 0; )
+ 	      if (t800_dataseg_symrefs_mentioned_p (XVECEXP (pat, i, j)))
+ 		return 1;
+ 	  }
+ 	else if (fmt[i] == 'e')
+ 	  if (t800_dataseg_symrefs_mentioned_p (XEXP (pat, i)))
+ 	    return 1;
+     }
+   return 0;
+ }
+ 
+ 
+ /* Returns 1 if OP is either a register or a local operand.
+    This is used in place of register_operand to avoid preloading from
+    local variables to pseudo registers that may probably fail to get a
+    hard register. */
+ 
+ int
+ ABCreg_or_local_operand (op, mode)
+      rtx op;
+      enum machine_mode mode;
+ {
+     return ABCreg_operand(op, mode) || local_operand(op, mode);
+ }
+ 
+ /* Ditto for nonmemory_operand */
+ 
+ int nonmem_or_local_operand (op, mode)
+      rtx op;
+      enum machine_mode mode;
+ {
+     return nonmemory_operand(op, mode) || local_operand(op, mode);
+ }
+ 
+ int
+ FABCreg_or_nonlocal_operand (op, mode)
+      rtx op;
+      enum machine_mode mode;
+ {
+     return FABCreg_operand(op, mode) || nonlocal_operand(op, mode);
+ }
+ 
+ /* A class of operands that remain in the class no matter what pseudos
+    fail to get a hard register.  */
+ 
+ int
+ nice_operand (op, mode)
+      rtx op;
+      enum machine_mode mode;
+ {
+   if (GET_CODE (op) == CONST_INT)
+     return 1;
+   return ABCreg_operand(op, mode) || local_operand(op, mode);
+ }
+ 
+ 
+ int
+ ABCreg_operand (op, mode)
+      register rtx op;
+      enum machine_mode mode;
+ {
+   if (GET_MODE (op) != mode && mode != VOIDmode)
+     return 0;
+ 
+   if (GET_CODE (op) == SUBREG)
+     op = SUBREG_REG (op);
+   if (GET_CODE (op) != REG)
+     return 0;
+ 
+   /* Hard ABCregs undoubtedly *are* ABCregs */
+ 
+   if (REGNO (op) == R_AREG || REGNO (op) == R_BREG || REGNO (op) == R_CREG)
+     return 1;
+ 
+   /* Allow pseudos because they will turn into, or will be reloaded
+      into the proper hard regs.  Reject virtual registers since they
+      are known to be changed into Wreg[+offset], so there is no chance
+      for them to become ABCreg's.
+ 
+      We don't reject pseudos even during reload; this might be
+      questionable, but consistent with the behaviour of
+      register_operand.  */
+ 
+   if (REGNO (op) > LAST_VIRTUAL_REGISTER)
+     return 1;
+ 
+   return 0;
+ }
+ 
+ int
+ FABCreg_operand (op, mode)
+      register rtx op;
+      enum machine_mode mode;
+ {
+   if (GET_MODE (op) != mode && mode != VOIDmode)
+     return 0;
+ 
+   if (GET_CODE (op) == SUBREG)
+     op = SUBREG_REG (op);
+   if (GET_CODE (op) != REG)
+     return 0;
+ 
+   /* Hard FABCregs undoubtedly *are* FABCregs */
+ 
+   if (REGNO (op) == R_FAREG || REGNO (op) == R_FBREG || REGNO (op) == R_FCREG)
+     return 1;
+ 
+   /* Allow pseudos because they will turn into, or will be reloaded
+      into the proper hard regs.  Reject virtual registers since they
+      are known to be changed into Wreg[+offset], so there is no chance
+      for them to become FABCreg's.  */
+ 
+   if (REGNO (op) > LAST_VIRTUAL_REGISTER)
+     return 1;
+ 
+   return 0;
+ }
+ 
+ int
+ Wreg_operand (op, mode)
+      register rtx op;
+      enum machine_mode mode;
+ {
+   if (GET_MODE (op) != mode && mode != VOIDmode)
+     return 0;
+ 
+   if (GET_CODE (op) == SUBREG)
+     op = SUBREG_REG (op);
+   if (GET_CODE (op) != REG)
+     return 0;
+ 
+   /* Virtual registers are OK here, as they will be replaced by WREG
+      or its equivalent (fake arg/stack pointers). But other pseudos
+      must be rejected, as WREG is a fixed register and cannot be
+      reloaded into.  */
+ 
+   switch (REGNO (op))
+     {
+       case R_WREG:
+       case R_FAKE1:
+       case R_FAKE2:
+       case VIRTUAL_INCOMING_ARGS_REGNUM:
+       case VIRTUAL_STACK_VARS_REGNUM:
+       case VIRTUAL_STACK_DYNAMIC_REGNUM:
+       case VIRTUAL_OUTGOING_ARGS_REGNUM:
+         return 1;
+     }
+ 
+   return 0;
+ }
+ 
+ 
+ /* Returns 1 if OP is a legitimate offset multiplier (size of array
+    element) for `wsub' or `wsubdb' command.  */
+ 
+ int
+ wsub_scale_operand (op, mode)
+      register rtx op;
+      enum machine_mode mode;
+ {
+   /* Don't accept CONST_INT or anything similar
+      if the caller wants something floating.  */
+   if (GET_MODE (op) == VOIDmode && mode != VOIDmode
+       && GET_MODE_CLASS (mode) != MODE_INT)
+     return 0;
+ 
+   if (GET_CODE (op) == CONST_INT
+       && (GET_MODE (op) == mode || mode == VOIDmode
+           || GET_MODE (op) == VOIDmode))
+     switch (INTVAL (op))
+       {
+       case UNITS_PER_WORD/2:
+ 	if (! TARGET_HAVE_SIXTEEN)
+ 	  break;
+ 	/* fall through */
+       case UNITS_PER_WORD:
+       case UNITS_PER_WORD*2:
+         return 1;
+       }
+   return 0;
+ }
+ 
+ 
+ /* Return 1 if the OP is zero in mode MODE.  This is really used for
+    FP modes only; integer modes probably won't work with the current
+    definition.  */
+ 
+ int
+ zero_operand (op, mode)
+      register rtx op;
+      enum machine_mode mode;
+ {
+   return op == CONST0_RTX (mode);
+ }
+ 
+ 
+ static REAL_VALUE_TYPE dconst2e32;
+ static REAL_VALUE_TYPE fconst2e32;
+ 
+ void
+ init_fp_specval ()
+ {
+   fconst2e32 = REAL_VALUE_ATOF ("2E32", SFmode);
+   dconst2e32 = REAL_VALUE_ATOF ("2E32", DFmode);
+ }
+ 
+ int
+ fp_specval_operand (op, mode)
+      rtx op;
+      enum machine_mode mode;
+ {
+   if (GET_MODE (op) == mode
+       && GET_CODE (op) == CONST_DOUBLE)
+     {
+       REAL_VALUE_TYPE rv;
+ 
+       REAL_VALUE_FROM_CONST_DOUBLE (rv, op);
+       if (REAL_VALUES_EQUAL (rv, dconst2)
+           || REAL_VALUES_EQUAL (rv, dconst2e32)
+           || REAL_VALUES_EQUAL (rv, fconst2e32))
+         return 1;
+     }
+   return 0;
+ }
+ 
+ int
+ fp_specval_ok_for_letter (x, c)
+      rtx x;
+      int c;
+ {
+   REAL_VALUE_TYPE rv;
+ 
+   REAL_VALUE_FROM_CONST_DOUBLE (rv, x);
+   switch (c)
+     {
+     case 'G': return REAL_VALUES_EQUAL (rv, dconst2);
+     case 'H': return REAL_VALUES_EQUAL (rv, dconst2e32)
+                      || REAL_VALUES_EQUAL (rv, fconst2e32);
+     }
+ 
+   return 0;
+ }
+ 
+ /* The predicate that accepts anything of the proper mode for the
+    operand.  */
+ 
+ int
+ whatever_operand (op, mode)
+      rtx op;
+      enum machine_mode mode;
+ {
+   enum machine_mode opmode = GET_MODE (op);
+   
+   return opmode == mode || mode == VOIDmode
+          /* accept CONST_INT (which is VOIDmode) for integer modes */
+          || GET_MODE_CLASS (mode) == MODE_INT && opmode == VOIDmode;
+ }
+ 
+ 
+ /************************************************************
+  Helper functions called from t800.md
+ ************************************************************/
+ 
+ 
+ enum { INVERSE = 0x1, NOT_01 = 0x2 };
+ 
+ 
+ /* Emit insn for an sCOND pattern.  */
+ 
+ void
+ t800_expand_scond (cond, operand0)
+      enum rtx_code cond;
+      rtx operand0;
+ {
+   rtx temp = operand0;
+   int r = t800_expand_compare (cond, &temp);
+ 
+   /* This may generate insn sequence that mentions operand0 more than
+      once.  This is OK in this particular case, since `eqc' does not
+      pop its input.  */
+ 
+   while (r & NOT_01 || r & INVERSE)
+     {
+       emit_insn (gen__eqc (operand0, temp, GEN_INT (0)));
+       r &= ~NOT_01;
+       r ^= INVERSE;
+       temp = operand0;
+     }
+ 
+   if (temp != operand0)
+     emit_move_insn (operand0, temp);
+ }
+ 
+ 
+ /* Emit insn for a bCOND pattern.  */
+ 
+ void
+ t800_expand_bcond (cond, dest_label)
+      enum rtx_code cond;
+      rtx dest_label;
+ {
+   rtx temp = NULL_RTX;
+   int r = t800_expand_compare (cond, &temp);
+ 
+   if (r & INVERSE)
+     my_emit_jump_insn (gen__cj (dest_label, temp), dest_label);
+   else
+     my_emit_jump_insn (gen__inv_cj (dest_label, temp), dest_label);
+ }
+ 
+ 
+ /* Common part for rtl generation for sCOND/bCOND groups of patterns.
+    The operands to be compared are stored in the structure
+    t800_compare by cmpM pattern.
+ 
+    This function generates insn sequence that carries out the
+    essential part of the comparison; that is, the trailing `eqc 0's
+    that may be required to invert the result or produce a valid 0/1
+    comparison result are never included in the sequence.  Instead, it
+    is responsibility of the caller to invert/normalize the result
+    according to taste.  t800_expand_scond and t800_expand_bcond,
+    which call this function, do this in distinct ways.
+ 
+    Return value is a two-bit mask.
+      00:  the code emitted produces the 0/1 result;
+      01:  the code emitted produces the inverse 0/1 result;
+      10:  the code emitted produces the 0/not0 result;
+      11:  the code emitted produces the inverse 0/not0 result.
+      
+    OUT_REG is a pointer to the rtx where the result of comparison
+    is suggested to come.  If *OUT_REG == 0, we allocate a new pseudo
+    for the output.  On return, we put there the actual rtx for the
+    comparison result.  */
+ 
+ int
+ t800_expand_compare (cond, out_reg)
+      enum rtx_code cond;
+      rtx *out_reg;
+ {
+   rtx op[2] = {t800_compare.op[0], t800_compare.op[1]};
+   rtx (*gen_gt) PROTO((rtx, rtx, rtx)) = t800_compare.fp? gen__fpgt: gen__gt;
+   
+   /* Convert QImode comparison to SImode.  Unsigned comparisons are
+      converted to the cheap signed SImode ones by zero-extending the
+      operands.  For other comparisons, we use zero-extension whenever
+      possible as well, because BYTE_LOADS_ZERO_EXTEND.  */
+ 
+   if (GET_MODE (op[0]) == QImode || GET_MODE (op[0]) == HImode)
+     switch (cond)
+       {
+       case GTU:  cond = GT; goto zero_extend;
+       case LTU:  cond = LT; goto zero_extend;
+       case GEU:  cond = GE; goto zero_extend;
+       case LEU:  cond = LE; goto zero_extend;
+       case EQ:
+       case NE:
+       zero_extend:
+         if (GET_CODE (op[1]) == CONST_INT)
+ 	    op[1] = GEN_INT (INTVAL (op[1])
+ 			     & (GET_MODE (op[0]) == QImode? 0xff: 0xffff));
+ 	else
+ 	  op[1] = convert_to_mode (SImode, op[1], 1/*unsignedp*/);
+         op[0] = convert_to_mode (SImode, op[0], 1/*unsignedp*/);
+         op[0] = force_reg (SImode, op[0]);
+         break;
+ 
+       default:
+         /* Comparing with a small CONST_INT is a common case where we can
+            avoid sign-extension.  */
+         if (GET_CODE (op[1]) == CONST_INT
+             && INTVAL (op[1]) >= 0
+ 	    && INTVAL (op[1]) <= (GET_MODE (op[0]) == QImode? 127: 32767))
+           goto zero_extend;
+         op[1] = convert_to_mode (SImode, op[1], 0/*unsignedp*/);
+         op[0] = convert_to_mode (SImode, op[0], 0/*unsignedp*/);
+         op[0] = force_reg (SImode, op[0]);
+         break;
+       }
+ 
+   if (GET_CODE (op[1]) == CONST_INT)
+     switch (cond)
+       {
+       case EQ:
+       case NE:
+         /* If comparing with 0 for branching, no comarison insn is
+            necessary.  Otherwise, emit `eqc'.  */
+         if (INTVAL (op[1]) == 0)
+           {
+             *out_reg = op[0];
+             return (cond != NE) | NOT_01;
+           }
+         else
+           {
+             if (! *out_reg)
+               *out_reg = gen_reg_rtx (SImode);
+             emit_insn (gen__eqc (*out_reg, op[0], op[1]));
+             return (cond != EQ);
+           }
+ 
+ #if 0  /* It's not clear whether it makes better or worse.  */
+       case GE:
+       case LT:
+ 
+         /* If possible, convert to the easy GT/LE case by decrementing
+            the constant we compare with:
+              x >= c  =>  x > c-1
+              x < c   =>  x <= c-1
+            This is not true if c == INT_MIN.
+            This isn't worth doing with c == 0, because in this case we
+            would convert the cheap positive constant to the more costly
+            negative one.
+            Note that we should use INT_MIN for the target; hope it is the
+            same as the one for host. */
+ 
+         if (INTVAL (op[1]) != 0)
+             && INTVAL (op[1]) != INT_MIN)
+           {
+             op[1] = GEN_INT (INTVAL (op[1]) - 1);
+             cond = (cond == GE? GT: LE);
+           }
+         break;
+ #endif
+     }
+ 
+   if (CONSTANT_P (op[1]) || Wreg_operand (op[1], VOIDmode))
+     op[1] = copy_to_mode_reg (GET_MODE (op[0]), op[1]);
+ 
+   if (! *out_reg)
+     *out_reg = gen_reg_rtx (SImode);
+   
+   switch (cond)
+     {
+       case EQ:  /* diff; eqc 0  || fpeq */ 
+       case NE:  /* diff         || fpeq; eqc 0 */
+         if (t800_compare.fp)
+           {
+             emit_insn (gen__fpeq (*out_reg, op[0], op[1]));
+             return (cond != EQ);
+           }
+         else
+           {
+             emit_insn (gen_subsi3 (*out_reg, op[0], op[1]));
+             return (cond != NE) | NOT_01;
+           }
+ 
+       case GE:  /* (reversed) gt; eqc 0 */
+       case LT:  /* (reversed) gt */
+ 	if (TARGET_HAVE_FPGE && t800_compare.fp)
+ 	  {
+ 	    emit_insn (gen__fpge (*out_reg, op[0], op[1]));
+ 	    return (cond != GE);
+ 	  }
+         emit_insn ((*gen_gt) (*out_reg, op[1], op[0]));
+         return (cond != LT);
+ 
+       case GT:  /* gt */
+       case LE:  /* gt; eqc 0 */
+ 	if (TARGET_HAVE_FPGE && t800_compare.fp)
+ 	  {
+ 	    emit_insn (gen__fpge (*out_reg, op[1], op[0]));
+ 	    return (cond != LE);
+ 	  }
+         emit_insn ((*gen_gt) (*out_reg, op[0], op[1]));
+         return (cond != GT);
+ 
+       case GEU: /* ldiff; eqc 0 */
+       case LTU: /* ldiff */
+ 	if (TARGET_HAVE_GTU && ! t800_compare.fp)
+ 	  {
+ 	    emit_insn (gen__gtu (*out_reg, op[1], op[0]));
+ 	    return (cond != LTU);
+ 	  }
+         emit_insn (gen__ldiff (*out_reg, gen_reg_rtx (SImode),
+                                op[0], op[1], force_reg (SImode, GEN_INT (0))));
+         return (cond != LTU);
+ 
+       case GTU: /* (reversed) ldiff */
+       case LEU: /* (reversed) ldiff; eqc 0 */
+ 	if (TARGET_HAVE_GTU && ! t800_compare.fp)
+ 	  {
+ 	    emit_insn (gen__gtu (*out_reg, op[0], op[1]));
+ 	    return (cond != GTU);
+ 	  }
+         emit_insn (gen__ldiff (*out_reg, gen_reg_rtx (SImode),
+                                op[1], op[0], force_reg (SImode, GEN_INT (0))));
+         return (cond != GTU);
+ 
+       default:
+         abort ();
+     }
+ }
+ 
+ 
+ /* Same as emit_jump insn except it establishes the JUMP_LABEL field.
+    This is to get around the bug of calling functions like redirect_jump
+    which use JUMP_LABEL prior to jump optimization, ie before the
+    JUMP_LABEL got a value.
+    Eliminate it when and whether the bug is fixed. */
+ 
+ rtx
+ my_emit_jump_insn (pattern, label)
+      rtx pattern;
+      rtx label;
+ {
+   rtx insn = emit_jump_insn (pattern);
+   JUMP_LABEL (insn) = label;
+   return insn;
+ }
+ 
+ 
+ /* Return 1 iff x is a register, possibly enclosed in a
+    mode-conversion SUBREG.  */
+ 
+ int
+ reg_p (x)
+     rtx x;
+ {
+   return GET_CODE (x) == REG
+          || GET_CODE (x) == SUBREG && GET_CODE (SUBREG_REG (x)) == REG;
+ }
+ 
+ 
+ /* Return 1 iff X is, or is likely to be allocated to, an fp register.  */
+ 
+ int
+ t800_fp_reg_p (x)
+     rtx x;
+ {
+   return (TARGET_HAVE_FPU
+ 	  && GET_CODE (x) == REG
+           && (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT
+ 	      || GET_MODE_CLASS (GET_MODE (x)) == MODE_COMPLEX_FLOAT)
+ 	  && (REGNO (x) >= FIRST_PSEUDO_REGISTER
+ 	      || FP_REGNO_P (REGNO (x))));
+ }
+ 
+ /* Return 1 iff X is an ABCreg.  Much like ABCreg_operand, but does
+    not accept pseudos during reload.  */
+ 
+ int
+ t800_ABCreg_p (op)
+      register rtx op;
+ {
+   if (GET_CODE (op) == SUBREG)
+     op = SUBREG_REG (op);
+   if (GET_CODE (op) != REG)
+     return 0;
+ 
+   if (REGNO (op) == R_AREG || REGNO (op) == R_BREG || REGNO (op) == R_CREG)
+     return 1;
+ 
+   if (REGNO (op) > LAST_VIRTUAL_REGISTER && ! reload_in_progress)
+     return 1;
+ 
+   return 0;
+ }
+ 
+ 
+ /* Copy x into a new pseudo if it is not an ABCreg */
+ 
+ rtx
+ force_ABCreg (mode, x)
+      enum machine_mode mode;
+      rtx x;
+ {
+   if (ABCreg_operand (x, mode))
+     return x;
+ 
+   if (Wreg_operand (x, VOIDmode))
+     return copy_to_mode_reg (mode, x);
+ 
+   return force_reg (mode, x);
+ }
+ 
+ 
+ /* The essential part of gen_call() and gen_call_value().  */
+ 
+ void
+ t800_expand_call(ret, fun, stack_size_rtx, next_arg_reg, struct_value_size_rtx)
+     rtx ret;
+     rtx fun;
+     rtx stack_size_rtx;
+     rtx next_arg_reg;
+     rtx struct_value_size_rtx;
+ {
+   rtx addr = XEXP (fun, 0);
+   int aggregate_valued
+     = (struct_value_size_rtx && INTVAL (struct_value_size_rtx));
+   rtx insn;
+   rtx temp;
+   rtx saveslot;
+ 
+   if (ret == NULL_RTX)
+     ret = gen_rtx (REG, SImode, R_AREG);
+ 
+   /* If the function address is not constant, or if FUNCTION_ARG decided
+      it's better to pass everything on stack, normal `call' insn
+      won't do. Use gcall instead. */
+ 
+   if (! CONSTANT_P (addr)
+       || next_arg_reg == const0_rtx)  /* "passed-on-stack" sign
+ 					 from FUNCTION_ARG */
+     {
+       int (*function_address_predicate)()
+         = insn_operand_predicate[CODE_FOR__gcall][1];
+ 
+       if (function_address_predicate
+ 	  && (! function_address_predicate (addr, Pmode)))
+         addr = copy_to_reg (addr);
+ 
+ #ifdef PSEUDO_STACK_POINTER
+       if (current_function_calls_alloca)
+ 	{
+ 	  /* Just before the call, retarget Wreg to where our pseudo
+ 	     stack pointer points.  Save the normal value of Wreg in a
+ 	     stack slot just above the
+ 	     current_function_outgoing_args_size, to be able to revert
+ 	     Wreg to normal after the call.
+ 
+ 	     Careful: Areg and Breg at the moment may carry stack value
+ 	     return address and the function address, do not clobber them.  */
+ 
+ 	  temp = gen_rtx (REG, Pmode, R_CREG);
+ 	  saveslot = t800_gen_local (Pmode, current_function_outgoing_args_size);
+ 
+ 	  emit_insn (gen_move_insn (temp, stack_pointer_rtx));
+ 	  emit_insn (gen__gajw (hard_stack_pointer_rtx, temp));
+ 	  emit_insn (gen_move_insn (saveslot, temp));
+ 	}
+ #endif /* PSEUDO_STACK_POINTER */
+ 
+ #ifdef STRUCT_VALUE_REGNUM
+       /* If this call takes return value address in a reg, we must
+ 	 arrange for using a special flavor of gcall which has
+ 	 function address constrained to another register.  See
+ 	 T800_OUTPUT__GCALL and gcall patterns. */
+ 
+       if (aggregate_valued)
+         emit_call_insn (gen__gcall_aggregate (ret, addr, stack_size_rtx));
+       else
+         emit_call_insn (gen__gcall (ret, addr, stack_size_rtx));
+ #else
+       insn = emit_call_insn (gen__gcall (ret, addr, stack_size_rtx));
+       if (aggregate_valued)
+         {
+           /* sign to T800_OUTPUT_GCALL in expert model */
+           PUT_MODE (PATTERN (insn), BLKmode);
+         }
+ #endif /* STRUCT_VALUE_REGNUM */
+ 
+ #ifdef PSEUDO_STACK_POINTER
+       if (current_function_calls_alloca)
+ 	{
+ 	  /* Restore Wreg to its normal position */
+ 	  emit_insn (gen_move_insn (temp, saveslot));
+ 	  emit_insn (gen__gajw (hard_stack_pointer_rtx, temp));
+ 	  /* The old Wreg value is left on the regstack.  Never mind,
+ 	     stack converter will take care of it */
+ 	}
+     }
+ #endif /* PSEUDO_STACK_POINTER */
+ 
+   else
+     {
+       /* The normal case */
+       insn = emit_call_insn (gen__call (ret, addr, stack_size_rtx));
+       if (aggregate_valued)
+         {
+           /* sign to T800_OUTPUT_CALL in expert model */
+           PUT_MODE (PATTERN (insn), BLKmode);
+         }
+     }
+ }
+ 
+ /* Temporary slot management.  define_expand's use a temporary stack
+    slot when dealing with insns that require certain operand to be in
+    memory rather than in a register.  The slot is allocated once per
+    function, on the first call to t800_temp_slot.  All subsequent
+    calls to t800_temp_slot return rtx of the appropriate mode for the
+    same slot.  */
+ 
+ #define WIDEST_MODE DFmode
+ 
+ rtx t800_temp_slots[NUM_MACHINE_MODES];
+ 
+ void
+ t800_temp_slot_init ()
+ {
+   int mode;
+   for (mode=NUM_MACHINE_MODES; --mode >= 0; )
+     t800_temp_slots[mode] = NULL_RTX;
+ }
+ 
+ rtx
+ t800_temp_slot (mode)
+     enum machine_mode mode;
+ {
+   extern int virtuals_instantiated;  /* from function.c */
+ 
+   if (t800_temp_slots[mode] == NULL_RTX)
+     {
+       if (t800_temp_slots[WIDEST_MODE] == NULL_RTX)
+         t800_temp_slots[WIDEST_MODE] =
+           assign_stack_local (WIDEST_MODE, GET_MODE_SIZE (WIDEST_MODE), 0);
+       if (mode != WIDEST_MODE)
+ 	t800_temp_slots[mode] =
+ 	  gen_rtx (MEM, mode, XEXP (t800_temp_slots[WIDEST_MODE], 0));
+     }
+ 
+   /* If we allocated the slot in the RTL generation phase,
+      assign_stack_local have used virtual frame pointer in the slot
+      address.  If we are called after instantiation (eg during reload)
+      returning the slot with such an address is not legal, since the
+      slot would be used as is and never instantiated.  So make sure
+      any virtuals in the slot's address are instantiated.  */
+   else if (virtuals_instantiated)
+     {
+       instantiate_decl (t800_temp_slots[mode], GET_MODE_SIZE (mode), 1);
+     }
+ 
+   return t800_temp_slots[mode];
+ }
+ 
+ 
+ /* For an arbitrary MEM rtx, return a MEM rtx which is a valid
+    nonlocal_operand.  This is accomplished by copying the memory
+    address into a pseudo, if necessary.  */
+ 
+ rtx
+ t800_force_nonlocal (x)
+     rtx x;
+ {
+   rtx addr;
+ 
+   if (GET_CODE (x) != MEM)
+     abort ();
+ 
+   addr = XEXP (x,0);
+ 
+   if (ABCreg_operand (addr, Pmode))
+     return x;
+ 
+   return gen_rtx (MEM, GET_MODE (x), copy_addr_to_reg (addr));
+ }
+ 
+ /* For an arbitrary MEM rtx, return a MEM rtx which is a valid
+    nonlocal_operand.  This is accomplished by copying the memory
+    address into the register REG, if necessary.  */
+ 
+ rtx
+ t800_force_nonlocal_using (x, reg)
+     rtx x;
+     rtx reg;
+ {
+   rtx addr;
+ 
+   if (GET_CODE (x) != MEM)
+     abort ();
+ 
+   addr = XEXP (x,0);
+ 
+   if (ABCreg_operand (addr, Pmode))
+     return x;
+ 
+   emit_move_insn (reg, addr);
+   return gen_rtx (MEM, GET_MODE (x), reg);
+ }
+ 
+ /* Generate rtx for a workspace slot address.  */
+ 
+ rtx
+ t800_gen_local_address (offset)
+     int offset;
+ {
+   register rtx addr = gen_rtx (REG, SImode, R_WREG);
+   if (offset)
+     return gen_rtx (PLUS, SImode, addr, GEN_INT (offset));
+   else
+     return addr;
+ }
+ 
+ /* Generate rtx for a workspace slot.  */
+ 
+ rtx
+ t800_gen_local (mode, offset)
+     enum machine_mode mode;
+     int offset;
+ {
+   return gen_rtx (MEM, mode, t800_gen_local_address (offset));
+ }
+ 
+ /* Given an object for which reload_memory_operand is true, return the
+    address of the operand, taking into account anything that reload
+    may do.  Stolen from config/a29k/a29k.c  */
+ 
+ rtx
+ t800_get_reloaded_address (op)
+      rtx op;
+ {
+   if (GET_CODE (op) == SUBREG)
+     {
+       if (SUBREG_WORD (op) != 0)
+ 	abort ();
+ 
+       op = SUBREG_REG (op);
+     }
+ 
+   if (GET_CODE (op) == REG)
+     op = reg_equiv_mem[REGNO (op)];
+ 
+   return find_replacement (&XEXP (op, 0));
+ }
+ 
+ 
+ 
+ /************************************************************
+  Machine-dependent functions called from reg-stack.c
+ ************************************************************/
+ 
+ #define ABC_STACKNO   0
+ #define FABC_STACKNO  1
+ 
+ /* Helper procedure for t800_emit_{drops,swaps}()
+    Emit insns according to the control string STR.  Reflect the
+    effect of insn emitted on the REGSTACK.
+    STR is the control string. Character assignments are:
+     'r' -   swap two regs near ABC-stack top    "rev"
+     'd' -   drop ABC-stack top                  "stl -5"
+     's' -   store reg temporarily               "stl -1"
+     'l' -   load temporarily stored reg         "ldl -1"
+     'R' -   swap two regs near FABC-stack top   "fprev"
+     'D' -   drop FABC-stack top                 "ldlp -3; fpstnlxx"
+     'S' -   store FABC-stack top temporarily    "ldlp -3; fpldnlxx"
+     'L' -   load temporarily stored reg         "ldlp -5; fpstnlxx"
+ 
+    Temporary locations layout:
+      Wreg[-1] Integer store area
+      Wreg[-2] Floating store area, high
+      Wreg[-3] Floating store area, low
+      Wreg[-4] Drop area, high
+      Wreg[-5] Drop area, low
+    */
+ 
+ static void
+ emit_t800_insns (str, st)
+     char *str;
+     stack st;
+ {
+   static int last_stored_virtual;
+   static int last_stored_fp_virtual;
+   static enum machine_mode last_stored_fp_mode;
+   enum machine_mode mode;
+   rtx pattern;
+   int offset;
+   int r0,r1;
+ 
+   for ( ; *str; emit_insn (pattern))
+     switch (*str++)
+       {
+       case 'd':
+ 	if (TARGET_HAVE_POP)
+ 	  {
+ 	    /* Use the T805 insn to drop the reg at stack top */
+ 	    pattern = gen__pop (hard_reg[STACK_REG_FIRST(ABC_STACKNO)][SImode]);
+ 	    CLEAR_HARD_REG_BIT (st->reg_set, st->reg[st->top[ABC_STACKNO]++]);
+ 	    break;
+ 	  }
+ 	else
+ 	  {
+ 	    /* Drop is just like a store except we use a different
+ 	       stack offset to avoid the conflict with load/store.  */
+ 	    offset = -5 * UNITS_PER_WORD;
+ 	    goto store;
+ 	  }
+ 
+       case 's':
+         /* Store a reg temporarily; it will be loaded back to stack
+            later in the sequence. Store into a spare memory location--
+            the one at a small negative offset from Wreg.  */
+         offset = -1 * UNITS_PER_WORD;
+         last_stored_virtual = st->reg[st->top[ABC_STACKNO]];
+ 
+       store:
+         pattern = gen__stl (t800_gen_local (SImode, offset),
+                             hard_reg[STACK_REG_FIRST(ABC_STACKNO)][SImode]);
+         CLEAR_HARD_REG_BIT (st->reg_set, st->reg[st->top[ABC_STACKNO]++]);
+         break;
+ 
+       case 'l':
+         /* Load a reg saved by 's' */
+         offset = -1 * UNITS_PER_WORD;
+         pattern = gen__ldl (hard_reg[STACK_REG_FIRST(ABC_STACKNO)][SImode],
+                             t800_gen_local (SImode, offset));
+         SET_HARD_REG_BIT (st->reg_set, last_stored_virtual);
+         st->reg[--(st->top[ABC_STACKNO])] = last_stored_virtual;
+         break;
+ 
+       case 'r':
+         pattern = gen__rev (hard_reg[STACK_REG_FIRST(ABC_STACKNO)][SImode],
+                             hard_reg[STACK_REG_FIRST(ABC_STACKNO)+1][SImode]);
+         r0 = st->reg[st->top[ABC_STACKNO]];
+         r1 = st->reg[st->top[ABC_STACKNO] + 1];
+         st->reg[st->top[ABC_STACKNO]] = r1;
+         st->reg[st->top[ABC_STACKNO] + 1] = r0;
+         break;
+ 
+       case 'D':
+         offset = -5 * UNITS_PER_WORD;
+         goto fp_store;
+ 
+       case 'S':
+         offset = -3 * UNITS_PER_WORD;
+         last_stored_fp_virtual = st->reg[st->top[FABC_STACKNO]];
+ 
+       fp_store:
+         mode = st->mode[REG_BY_HARD_REGNO (st, R_FAREG)];
+         pattern = gen_rtx (SET, mode,
+                            t800_force_nonlocal_using (t800_gen_local (mode, offset), 
+ 						      hard_reg[STACK_REG_FIRST(ABC_STACKNO)][Pmode]),
+                            hard_reg[STACK_REG_FIRST(FABC_STACKNO)][mode]);
+         CLEAR_HARD_REG_BIT (st->reg_set, st->reg[st->top[FABC_STACKNO]++]);
+         break;
+ 
+       case 'L':
+         /* Load a reg saved by 's' */
+         offset = -3 * UNITS_PER_WORD;
+         mode = st->mode[REG_BY_HARD_REGNO (st, R_FAREG)];
+         pattern = gen_rtx (SET, mode,
+                            hard_reg[STACK_REG_FIRST(FABC_STACKNO)][mode],
+                            t800_force_nonlocal_using (t800_gen_local (mode, offset), 
+ 						      hard_reg[STACK_REG_FIRST(ABC_STACKNO)][Pmode]));
+         SET_HARD_REG_BIT (st->reg_set, last_stored_fp_virtual);
+         st->reg[--(st->top[FABC_STACKNO])] = last_stored_fp_virtual;
+         break;
+ 
+       case 'R':
+         mode = st->mode[REG_BY_HARD_REGNO (st, R_FAREG)];
+         pattern = gen__fprev (hard_reg[STACK_REG_FIRST(FABC_STACKNO)][mode],
+                               hard_reg[STACK_REG_FIRST(FABC_STACKNO)+1][mode]);
+         r0 = st->reg[st->top[FABC_STACKNO]];
+         r1 = st->reg[st->top[FABC_STACKNO] + 1];
+         st->reg[st->top[FABC_STACKNO]] = r1;
+         st->reg[st->top[FABC_STACKNO] + 1] = r0;
+         break;
+ 
+       default:
+         abort ();
+       }
+ }
+ 
+ 
+ /* Procedure for discarding regs from reg-stack.
+ 
+    There are two ways to delete a reg from reg-stack.
+    1) if the reg is at the top of stack, it can be popped (stl <dummy>);
+    2) if the reg is at the bottom, it can be forgotten without
+       an insn, since the transputer's reg-stacks are not `strict'.
+    There is no insn to drop a reg that is in the middle of the stack.
+    In this case we have to swap some regs to bring the reg to be
+    dropped into suitable position (top, in practice).
+ 
+    REGSTACK is the state of the stack at the point where we are
+      to insert dropping insns. REGSTACK is modified to reflect the
+      effect of inserted insns.
+    DROP_SET is the hard-reg-set indicating which *virtual* regs
+      to drop.  */
+ 
+ void
+ t800_emit_drops (regstack, drop_set)
+     stack regstack;
+     HARD_REG_SET drop_set;
+ {
+   int i,j,k;
+ 
+   /* Calling this with empty drop_set seems fairly frequent.
+      Don't bother going through the loop in this case...  */
+   GO_IF_HARD_REG_EQUAL (drop_set, reg_class_contents[NO_REGS], end);
+ 
+   for (k = 0; k < STACK_REG_NSTACKS; ++k)
+     {
+       int dropmask = 0x111;
+ 
+       if (STACK_REG_LAST(k) + 1 - STACK_REG_FIRST(k) != 3)
+         abort ();
+ 
+       /* Fill dropmask with a hex mask for registers to be popped.
+          Registers that are not currently on stack are also marked
+          dropped to reduce the number of cases.   */
+ 
+       for (i = regstack->top[k]; i <= STACK_REG_LAST(k); ++i)
+         if (! TEST_HARD_REG_BIT (drop_set, regstack->reg[i]))
+           dropmask &= ~(1 << (i - regstack->top[k]) * 4);
+ 
+ again:
+       switch (dropmask)
+         {
+         /*     CBA */
+         case 0x000:          /* Nothing to drop */
+           break;
+ 
+         case 0x011:          /* Drop Breg,Areg */
+ #if 0
+           emit_t800_insns ("dd", regstack);
+           break;
+ #else
+           /* The second drop is better to do with `rev' on T800. On
+              T805 as well, because `rev' is short and `pop' is long.  */
+           emit_t800_insns ("d", regstack);
+           dropmask = 0x101;
+           goto again;
+ #endif
+ 
+         case 0x001:          /* Drop Areg */
+           emit_t800_insns ("d", regstack);
+           break;
+ 
+         case 0x010:          /* Drop Breg only */
+           /* Swap reg B to top of stack, then drop the top.  */
+           emit_t800_insns ("rd", regstack);
+           break;
+ 
+         case 0x101:
+           /* Swap reg B to top of stack, thus converting to case 0x110.  */
+           emit_t800_insns ("r", regstack);
+ 
+           /* FALL THROUGH */
+ 
+         case 0x110: j = regstack->top[k] + 0; goto bottom_drop;
+         case 0x100: j = regstack->top[k] + 1; goto bottom_drop;
+         case 0x111: j = regstack->top[k] - 1; goto bottom_drop;
+         bottom_drop:
+ 
+           /* The regs to drop are at the bottom of stack -- no insns
+              needed.  Just forget that the stack contains these regs.
+              J is the index of the most deep non-dropped reg.  */
+ 
+           for (i = STACK_REG_LAST(k); i > j; i--)
+             CLEAR_HARD_REG_BIT (regstack->reg_set, regstack->reg[i]);
+ 
+           for (i = STACK_REG_LAST(k); j >= regstack->top[k]; j--,i--)
+             regstack->reg[i] = regstack->reg[j];
+ 
+           regstack->top[k] = i + 1;
+           break;
+ 
+         default:
+           /* "cannot happen" */
+           abort ();
+         }
+     }
+ end:
+   ;
+ }
+ 
+ 
+ /* Procedure for reg-stack reordering.
+ 
+    OLDSTACK is the state of the stack at the point where we are to
+    insert dropping insns. OLDSTACK is modified to reflect the effect
+    of inserted insns.
+    NEWSTACK is the desired stack state.
+ 
+    Stack reordering sequences:
+ 
+    Transformation   Insn sequence
+         210         <none; the order is right>
+         201         rev
+         102         rev; =>120
+         120         stl temp; rev; ldl temp
+         012         rev; =>021
+         021         stl temp; rev; ldl temp; =>201
+    */
+ 
+ void
+ t800_emit_swaps (oldstack, newstack)
+      stack oldstack;
+      stack newstack;
+ {
+   int i,j,k;
+   char *p;
+ 
+   /* The only difference must be the order of the stacks */
+ 
+   GO_IF_HARD_REG_EQUAL (oldstack->reg_set, newstack->reg_set, win);
+     abort ();
+ win:
+ 
+   /* See if we need to store a reg from ABC-stack temporarily into
+      memory.  This can be the case if:
+      (a) ABC-stack is full and the reg at the bottom needs to be
+      swapped; we need to remove one reg as `rev' cannot access the reg
+      at the bottom;
+      (b) FABC-stack is full as well and the reg at the bottom needs to be
+      swapped; we'll need to remove the reg at the top of FABC-stack,
+      which requires a reg of ABC-stack for address.
+      
+      The code below occasionally uses stack->reg[R] instead of
+      REG_BY_HARD_REGNO (stack, R); it yields the same effect when the
+      stack is full.  */
+ 
+   if (STACK_DEPTH (oldstack, ABC_STACKNO) == 3
+       && (oldstack->reg[R_CREG] != newstack->reg[R_CREG]
+           || STACK_DEPTH (oldstack, FABC_STACKNO) == 3
+           && oldstack->reg[R_FCREG] != newstack->reg[R_FCREG]))
+     {
+       struct stack_def tmpstack;
+ 
+       /* We need to store a reg.  If the reg currently on top is the
+          one that needs to be at the bottom in the new stack, emit
+          `rev' before storing.  */
+       if (oldstack->reg[R_AREG] == newstack->reg[R_CREG])
+         emit_t800_insns ("rs", oldstack);
+       else
+         emit_t800_insns ("s", oldstack);
+ 
+       /* Handle the simplified situation by a recursive call.  To do
+          this, we need to make a modified copy of the new stack that
+          does not contain the register just stored.  Note that this
+          reg is always either top or next-to-top in the new stack.  */
+       bcopy (newstack, &tmpstack, sizeof (struct stack_def));
+       if (TEST_HARD_REG_BIT (oldstack->reg_set, tmpstack.reg[R_AREG]))
+         {
+           /* The reg stored is next-to-top in newstack */
+           CLEAR_HARD_REG_BIT (tmpstack.reg_set, tmpstack.reg[R_BREG]);
+           tmpstack.reg[R_BREG] = tmpstack.reg[R_AREG];
+           tmpstack.top[ABC_STACKNO]++;
+         }
+       else
+         {
+           CLEAR_HARD_REG_BIT (tmpstack.reg_set, tmpstack.reg[R_AREG]);
+           tmpstack.top[ABC_STACKNO]++;
+         }
+       
+       t800_emit_swaps (oldstack, &tmpstack);
+ 
+       /* Load the stored reg back, then fall into the common part
+          to check whether it is in the correct place.  */
+       emit_t800_insns ("l", oldstack);
+     }
+ 
+   else
+ 
+   /* See if we need to store a reg from FABC-stack temporarily into
+      memory.  Now we're sure to have a room on ABC-stack to hold the
+      address needed to do the store.  */
+   if (STACK_DEPTH (oldstack, FABC_STACKNO) == 3
+       && oldstack->reg[R_FCREG] != newstack->reg[R_FCREG])
+     {
+       struct stack_def tmpstack;
+ 
+       if (oldstack->reg[R_FAREG] == newstack->reg[R_FCREG])
+         emit_t800_insns ("RS", oldstack);
+       else
+         emit_t800_insns ("S", oldstack);
+ 
+       bcopy (newstack, &tmpstack, sizeof (struct stack_def));
+       if (TEST_HARD_REG_BIT (oldstack->reg_set, tmpstack.reg[R_FAREG]))
+         {
+           /* The reg stored is next-to-top in newstack */
+           CLEAR_HARD_REG_BIT (tmpstack.reg_set, tmpstack.reg[R_FBREG]);
+           tmpstack.reg[R_FBREG] = tmpstack.reg[R_FAREG];
+           tmpstack.top[FABC_STACKNO]++;
+         }
+       else
+         {
+           CLEAR_HARD_REG_BIT (tmpstack.reg_set, tmpstack.reg[R_FAREG]);
+           tmpstack.top[FABC_STACKNO]++;
+         }
+       
+       t800_emit_swaps (oldstack, &tmpstack);
+       emit_t800_insns ("L", oldstack);
+     }
+ 
+   /* Now the situation must be simple enough to do with no storing;
+      all we have to do is to emit `rev' and `fprev' if necessary.  */
+ 
+   if (STACK_DEPTH (oldstack, ABC_STACKNO) >= 2
+       && REG_BY_HARD_REGNO (oldstack, R_AREG)
+       != REG_BY_HARD_REGNO (newstack, R_AREG))
+     emit_t800_insns ("r", oldstack);
+ 
+   if (STACK_DEPTH (oldstack, FABC_STACKNO) >= 2
+       && REG_BY_HARD_REGNO (oldstack, R_FAREG)
+       != REG_BY_HARD_REGNO (newstack, R_FAREG))
+     emit_t800_insns ("R", oldstack);
+ }
+ 
+ 
+ /* Initialize specified registers to something (zero). The order
+    of pushing is arbitrary (which is not too good, but simple).
+    Reflect the effect of insns emitted in REGSTACK. */
+ 
+ void
+ t800_emit_pushes (regstack, push_set)
+      stack regstack;
+      HARD_REG_SET push_set;
+ {
+   int i,k;
+   enum machine_mode mode;
+ 
+   for (k = 0; k < STACK_REG_NSTACKS; ++k)
+     for (i = STACK_REG_FIRST (k); i <= STACK_REG_LAST(k); ++i)
+       {
+         if (!TEST_HARD_REG_BIT (push_set, i))
+           continue;
+         mode = (k == ABC_STACKNO? SImode : SFmode);
+         emit_insn (gen_rtx (SET, mode, hard_reg[STACK_REG_FIRST(k)][mode],
+                             CONST0_RTX (mode)));
+         regstack->reg[--regstack->top[k]] = i;
+         SET_HARD_REG_BIT (regstack->reg_set, i);
+       }
+ }
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/config/t800/t800.h gcc-2.7.2-t800.12/config/t800/t800.h
*** gcc-2.7.2/config/t800/t800.h	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/config/t800/t800.h	Fri Nov 22 19:59:16 1996
***************
*** 0 ****
--- 1,2138 ----
+ /* Definitions of target machine for GNU compiler for INMOS transputer family.
+    Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
+ 
+    Written by Yury Shevchuk <sizif@botik.ru>
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ 
+ /* This file is laid out along the manual (tm.texi), and is supposed
+    to be read with printed manual in hand. Therefore it contains no
+    common comments, just transputer-specific ones. */
+ 
+ 
+ /*************************************************************
+  Controlling the Compilation Driver, @file{gcc}
+ *************************************************************/
+ 
+ /* #define SWITCH_TAKES_ARG(@var{char}) */
+ /* #define WORD_SWITCH_TAKES_ARG(@var{name}) */
+ /* #define SWITCHES_NEED_SPACES */
+ /* #define CPP_SPEC */
+ /* #define SIGNED_CHAR_SPEC */
+ /* #define CC1_SPEC */
+ /* #define CC1PLUS_SPEC */
+ /* #define ASM_SPEC */
+ /* #define ASM_FINAL_SPEC */
+ /* #define LINK_SPEC */
+ /* #define LIB_SPEC */
+ /* #define STARTFILE_SPEC */
+ /* #define ENDFILE_SPEC */
+ /* #define LINK_LIBGCC_SPECIAL */
+ /* #define RELATIVE_PREFIX_NOT_LINKDIR */
+ /* #define STANDARD_EXEC_PREFIX */
+ /* #define MD_EXEC_PREFIX */
+ /* #define STANDARD_STARTFILE_PREFIX */
+ /* #define MD_STARTFILE_PREFIX */
+ /* #define LOCAL_INCLUDE_DIR */
+ /* #define SYSTEM_INCLUDE_DIR */
+ /* #define STANDARD_INCLUDE_DIR */
+ /* #define INCLUDE_DEFAULTS */
+ 
+ 
+ /*************************************************************
+  Run-time Target Specification
+ *************************************************************/
+ 
+ #define CPP_PREDEFINES  "-Dtransputer"
+ 
+ /* #define STDC_VALUE */
+ 
+ extern int target_flags;
+ 
+ /* configure can set this using -D in CFLAGS */
+ #ifndef TARGET_CPU_DEFAULT
+ #define TARGET_CPU_DEFAULT 800
+ #endif
+ 
+ #if TARGET_CPU_DEFAULT == 800
+ #define MASK_CPU_DEFAULT  MASK_CPU_CAPABILITIES_T800
+ #elif TARGET_CPU_DEFAULT == 805
+ #define MASK_CPU_DEFAULT  MASK_CPU_CAPABILITIES_T805
+ #elif TARGET_CPU_DEFAULT == 425
+ #define MASK_CPU_DEFAULT  MASK_CPU_CAPABILITIES_T425
+ #elif TARGET_CPU_DEFAULT == 450
+ #define MASK_CPU_DEFAULT  MASK_CPU_CAPABILITIES_T450
+ #elif TARGET_CPU_DEFAULT == 9000
+ #define MASK_CPU_DEFAULT  MASK_CPU_CAPABILITIES_T9000
+ #else
+ #error "Improper value for TARGET_CPU_DEFAULT.  Someone improved configure?"
+ #endif
+ 
+ /* Processor type to capabilities mask mapping */
+ 
+ #define MASK_CPU_CAPABILITIES_T800 \
+   (MASK_HAVE_FPU | MASK_HAVE_FPENTRY)
+ 
+ #define MASK_CPU_CAPABILITIES_T805 \
+   (MASK_HAVE_FPU | MASK_HAVE_FPENTRY | MASK_HAVE_POP)
+ 
+ #define MASK_CPU_CAPABILITIES_T425 \
+   (MASK_HAVE_POP)
+ 
+ #define MASK_CPU_CAPABILITIES_T450 \
+   (MASK_HAVE_POP | MASK_HAVE_GTU | MASK_HAVE_SIXTEEN \
+    | MASK_HAVE_XTEND | MASK_HAVE_SLMUL)
+ 
+ #define MASK_CPU_CAPABILITIES_T9000 \
+   (MASK_HAVE_FPU | MASK_HAVE_POP | MASK_HAVE_GTU \
+    | MASK_HAVE_XTEND | MASK_HAVE_SIXTEEN)
+ 
+ #define MASK_CPU_CAPABILITIES_ALL \
+   (0			\
+    | MASK_HAVE_FPU	\
+    | MASK_HAVE_FPENTRY	\
+    | MASK_HAVE_FPGE	\
+    | MASK_HAVE_POP	\
+    | MASK_HAVE_GTU	\
+    | MASK_HAVE_SIXTEEN	\
+    | MASK_HAVE_XTEND	\
+    | MASK_HAVE_SLMUL	\
+   )
+ 
+ /* Masks for the -m switches */
+ 
+ #define MASK_USE_cmpqi			000000000001
+ #define MASK_DATASEG_PC_RELATIVE	000000000002
+ #define MASK_SHORT16			000000000004
+ #define MASK_SHORT32			000000000010
+ /* processor capabilities */
+ #define MASK_HAVE_FPU			000000001000
+ #define MASK_HAVE_FPENTRY		000000002000
+ #define MASK_HAVE_FPGE			000000004000
+ #define MASK_HAVE_POP			000000010000
+ #define MASK_HAVE_GTU			000000020000
+ #define MASK_HAVE_SIXTEEN		000000040000
+ #define MASK_HAVE_XTEND			000000100000
+ #define MASK_HAVE_SLMUL			000000200000
+ 
+ /* Debugging: enable cmpqi pattern */
+ 
+ #define TARGET_USE_cmpqi   (target_flags & MASK_USE_cmpqi)
+ 
+ /* Data segment access relative to PC (ldc/ldpi/ldnl) as opposed to
+    access via pointer to the data segment start (ldl/ldnl) */
+ 
+ #define TARGET_DATASEG_PC_RELATIVE  (target_flags & MASK_DATASEG_PC_RELATIVE)
+ #define TARGET_DATASEG_BY_POINTER  (! TARGET_DATASEG_PC_RELATIVE)
+ 
+ /* Make short ints 16-bit wide.  This is closer to traditions, but
+    gives inefficient code if the target lacks 16-bit operation support */
+ 
+ #define TARGET_SHORT16 \
+   (target_flags & MASK_SHORT16 \
+    || (target_flags & (MASK_SHORT32|MASK_HAVE_SIXTEEN) == MASK_HAVE_SIXTEEN))
+ 
+ /* Target has FP support at all (there are fp-registers) */
+ 
+ #define TARGET_HAVE_FPU  (target_flags & MASK_HAVE_FPU)
+ 
+ /* Target has the indirect fpu* instructions -- t800,t805.  The
+    absence of this bit means the direct counterparts of the fpu*
+    instructions are available -- t9000 */
+ 
+ #define TARGET_HAVE_FPENTRY  (target_flags & MASK_HAVE_FPENTRY)
+ 
+ /* Target has the fpge instruction */
+ 
+ #define TARGET_HAVE_FPGE  (target_flags & MASK_HAVE_FPGE)
+ 
+ /* Target has the pop instruction */
+ 
+ #define TARGET_HAVE_POP  (target_flags & MASK_HAVE_POP)
+ 
+ /* Target has the gtu instruction */
+ 
+ #define TARGET_HAVE_GTU  (target_flags & MASK_HAVE_GTU)
+ 
+ /* Target has the quick sign extension instructions (xbword, lbx,
+    (and if HAVE_SIXTEEN) xsword, lsx)  */
+ 
+ #define TARGET_HAVE_XTEND  (target_flags & MASK_HAVE_XTEND)
+ 
+ /* Target has the 16-bit load/store/subscript instructions
+    (ls,ss,ssub) -- t9000, t450 */
+ 
+ #define TARGET_HAVE_SIXTEEN  (target_flags & MASK_HAVE_SIXTEEN)
+ 
+ /* Target has signed long multiplication (slmul, sulmul) -- t450 */
+ 
+ #define TARGET_HAVE_SLMUL  (target_flags & MASK_HAVE_SLMUL)
+ 
+ 
+ #define TARGET_SWITCHES_DEFAULT \
+   (0 \
+    | MASK_USE_cmpqi \
+    | MASK_DATASEG_PC_RELATIVE \
+    | MASK_CPU_DEFAULT \
+   )
+ 
+ #define TARGET_SWITCHES \
+   {{"no-cmpqi",			-MASK_USE_cmpqi},		\
+    {"dataseg-pc-relative",	+MASK_DATASEG_PC_RELATIVE},	\
+    {"dataseg-by-pointer",	-MASK_DATASEG_PC_RELATIVE},	\
+    {"short16",			-MASK_SHORT32},			\
+    {"short16",			+MASK_SHORT16},			\
+    {"short32",			-MASK_SHORT16},			\
+    {"short32",			+MASK_SHORT32},			\
+    {"t800", 			-MASK_CPU_CAPABILITIES_ALL},	\
+    {"t800", 			+MASK_CPU_CAPABILITIES_T800},	\
+    {"t805", 			-MASK_CPU_CAPABILITIES_ALL},	\
+    {"t805", 			+MASK_CPU_CAPABILITIES_T805},	\
+    {"t425", 			-MASK_CPU_CAPABILITIES_ALL},	\
+    {"t425", 			+MASK_CPU_CAPABILITIES_T425},	\
+    {"t450", 			-MASK_CPU_CAPABILITIES_ALL},	\
+    {"t450", 			+MASK_CPU_CAPABILITIES_T450},	\
+    {"t9000", 			-MASK_CPU_CAPABILITIES_ALL},	\
+    {"t9000", 			+MASK_CPU_CAPABILITIES_T9000},	\
+    {"fpu",			+MASK_HAVE_FPU},		\
+    {"no-fpu",			-MASK_HAVE_FPU},		\
+    {"fpentry",			+MASK_HAVE_FPENTRY},		\
+    {"no-fpentry",		-MASK_HAVE_FPENTRY},		\
+    {"fpge",			+MASK_HAVE_FPGE},		\
+    {"no-fpge",			-MASK_HAVE_FPGE},		\
+    {"pop",			+MASK_HAVE_POP},		\
+    {"no-pop",			-MASK_HAVE_POP},		\
+    {"gtu",			+MASK_HAVE_GTU},		\
+    {"no-gtu",			-MASK_HAVE_GTU},		\
+    {"sixteen",			+MASK_HAVE_SIXTEEN},		\
+    {"no-sixteen",		-MASK_HAVE_SIXTEEN},		\
+    {"xtend",			+MASK_HAVE_XTEND},		\
+    {"no-xtend",			-MASK_HAVE_XTEND},		\
+    {"slmul",			+MASK_HAVE_SLMUL},		\
+    {"no-slmul",			-MASK_HAVE_SLMUL},		\
+    SUBTARGET_SWITCHES						\
+    {"",  TARGET_SWITCHES_DEFAULT | SUBTARGET_SWITCHES_DEFAULT}}
+ 
+ /* #define TARGET_OPTIONS  {} */
+ 
+ /* These are meant to be redefined by subtargets */
+ #define SUBTARGET_SWITCHES
+ #define SUBTARGET_SWITCHES_DEFAULT  0
+ #define SUBTARGET_OPTIONS
+ 
+ #define TARGET_VERSION fprintf (stderr, " (Transputer, TTOOLS syntax)");
+ 
+ /* #define OVERRIDE_OPTIONS */
+ /* #define OPTIMIZATION_OPTIONS(LEVEL) */
+ 
+ 
+ /*************************************************************
+  Storage Layout
+ *************************************************************/
+ 
+ #define BITS_BIG_ENDIAN                 0
+ #define BYTES_BIG_ENDIAN                0
+ #define WORDS_BIG_ENDIAN                0
+ #define BITS_PER_UNIT                   8
+ #define BITS_PER_WORD                   32
+ /* - #define MAX_BITS_PER_WORD */
+ #define UNITS_PER_WORD                  4
+ #define POINTER_SIZE                    BITS_PER_WORD
+ 
+ 
+ /* Transputers most naturally operate on signed 32-bit values.  Tried
+    to switch this off: gives slightly worse code sometimes, but it
+    seems to be mostly due to the reuse of pseudos, which is not good
+    with our insns that pop their inputs.  */
+ 
+ #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE) \
+   {                                                 \
+     if (GET_MODE_CLASS (MODE) == MODE_INT           \
+         && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)   \
+       (MODE) = SImode;                              \
+     (UNSIGNEDP) = 0;                                \
+   }
+ 
+ #define PROMOTE_FUNCTION_ARGS
+ #define PROMOTE_FUNCTION_RETURN
+ /*-#define PROMOTE_FOR_CALL_ONLY */
+ 
+ #define PARM_BOUNDARY            BITS_PER_WORD
+ #define STACK_BOUNDARY           BITS_PER_WORD
+ #define FUNCTION_BOUNDARY        BITS_PER_UNIT
+ #define BIGGEST_ALIGNMENT        BITS_PER_WORD
+ #define BIGGEST_FIELD_ALIGNMENT  BITS_PER_WORD
+ 
+ /* #define MAX_OFILE_ALIGNMENT */
+ /* #define DATA_ALIGNMENT(type, basic_align) */
+ /* #define CONSTANT_ALIGNMENT(constant, basic_align) */
+ 
+ #define EMPTY_FIELD_BOUNDARY  BITS_PER_WORD
+ 
+ /* - #define STRUCTURE_SIZE_BOUNDARY */
+ 
+ #define STRICT_ALIGNMENT  1
+ 
+ /* Don't need this with the present definition of ROUND_TYPE_ALIGN  */
+ /* -#define PCC_BITFIELD_TYPE_MATTERS */
+ 
+ /* Inhibit bitfields to cross a word boundary for better access.  */
+ #define BITFIELD_NBYTES_LIMITED  1
+ 
+ /* #define ROUND_TYPE_SIZE(struct, size, align) */
+ 
+ /* Make structures at least word-aligned.  Otherwise we get bulky code
+    when passing a byte-aligned structure as a function arg because of
+    our STRICT_ALIGNMENT (see calls.c:expand_call()). Small structure
+    assignment will also be better this way.  */
+ 
+ #define ROUND_TYPE_ALIGN(STRUCT, COMPUTED, SPECIFIED) \
+   (MAX (MAX ((COMPUTED), (SPECIFIED)),                              \
+         TREE_CODE (STRUCT) == RECORD_TYPE ? BITS_PER_WORD : 0))
+ 
+ /* #define MAX_FIXED_MODE_SIZE */
+ /* #define CHECK_FLOAT_VALUE(mode, value) */
+ 
+ #define TARGET_FLOAT_FORMAT  IEEE_FLOAT_FORMAT
+ 
+ 
+ /*************************************************************
+  Layout of Source Language Data Types
+ *************************************************************/
+ 
+ /* Use default value */
+ /* #define INT_TYPE_SIZE */
+ 
+ /* T800 doesn't have 16-bit loads/stores, so supporting 16-bit shorts
+    is no pleasure.  But it is still supported as an option for the
+    sake of compatibility with alien librares and existing software
+    that counts on short being half-word-wide.  */
+ 
+ #define SHORT_TYPE_SIZE  (TARGET_SHORT16 ? 16 : 32)
+ 
+ /* #define LONG_TYPE_SIZE */
+ /* #define LONG_LONG_TYPE_SIZE */
+ /* #define CHAR_TYPE_SIZE */
+ /* #define FLOAT_TYPE_SIZE */
+ /* #define DOUBLE_TYPE_SIZE */
+ /* #define LONG_DOUBLE_TYPE_SIZE */
+ 
+ /* lb loads char w/o sign extension; so this may lead to better code */
+ #define DEFAULT_SIGNED_CHAR  0
+ 
+ /* Let's have int-sized enums to simplify access */
+ #define DEFAULT_SHORT_ENUMS  0
+ 
+ /* #define SIZE_TYPE */
+ /* #define PTRDIFF_TYPE */
+ /* #define WCHAR_TYPE */
+ /* #define WCHAR_TYPE_SIZE */
+ /* #define OBJC_INT_SELECTORS */
+ /* #define OBJC_SELECTORS_WITHOUT_LABELS */
+ 
+ #define TARGET_BELL                     007
+ #define TARGET_BS                       010
+ #define TARGET_TAB                      011
+ #define TARGET_NEWLINE                  012
+ #define TARGET_VT                       013
+ #define TARGET_FF                       014
+ #define TARGET_CR                       015
+ 
+ 
+ /*************************************************************
+  Register Usage
+ *************************************************************/
+ 
+ /*** Basic Caracteristics of Registers **********************/
+ 
+ /* Hard registers. Cannot use enum here because things like
+         #if ARG_POINTER_REGNUM != FRAME_POINTER_REGNUM
+    in emit-rtl.c won't work with enums.
+ 
+    Two fake registers are added, for use as STACK_POINTER_REGNUM and
+    ARG_POINTER_REGNUM.  Those are used in code generation and are
+    eliminated in reload pass in favor of FRAME_POINTER_REGNUM (which
+    is Wreg). */
+ 
+ #define R_AREG     (0)
+ #define R_BREG     (1)
+ #define R_CREG     (2)
+ #define R_FAREG    (3)
+ #define R_FBREG    (4)
+ #define R_FCREG    (5)
+ #define R_WREG     (6)
+ #define R_FAKE1    (7)
+ #define R_FAKE2    (8)
+ 
+ #define FIRST_PSEUDO_REGISTER           9
+ 
+ #define FIXED_REGISTERS \
+   /*Areg,Breg,Creg,FAreg,FBreg,FCreg,Wreg,Fake1,Fake2*/ \
+   {    0,   0,   0,    0,    0,    0,   1,    1,    1 }
+ 
+ /* No one survives a function call */
+ 
+ #define CALL_USED_REGISTERS \
+   /*Areg,Breg,Creg,FAreg,FBreg,FCreg,Wreg,Fake1,Fake2*/ \
+   {    1,   1,   1,    1,    1,    1,   1,   1,    1 }
+ 
+ /* ??? Reconsider this once setjmp is implemented... */
+ 
+ #define NON_SAVING_SETJMP  1
+ 
+ #define CONDITIONAL_REGISTER_USAGE \
+   if (! TARGET_HAVE_FPU) {				\
+       int i; 						\
+       HARD_REG_SET x;					\
+       COPY_HARD_REG_SET (x, reg_class_contents[(int)FLOAT_REGS]); \
+       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ )	\
+        if (TEST_HARD_REG_BIT (x, i)) 			\
+ 	 fixed_regs[i] = call_used_regs[i] = 1; 	\
+   }							\
+ 
+ /* -#define INCOMING_REGNO (out) */
+ /* -#define OUTGOING_REGNO (in) */
+ 
+ 
+ /*** Order of Allocation of Registers ***********************/
+ 
+ /* #define REG_ALLOC_ORDER */
+ /* #define ORDER_REGS_FOR_LOCAL_ALLOC */
+ 
+ 
+ /*** How Values Fit in Registers ****************************/
+ 
+ /* A single fp register is enough to hold any mode.  For integer
+    registers, act in the standard way.  */
+ #define HARD_REGNO_NREGS(REGNO, MODE) \
+   (FP_REGNO_P (REGNO) ? 1 : IN_WORDS(GET_MODE_SIZE (MODE)))
+ 
+ /* Disallow placing non-fp values in fp registers, since they are hard
+    to access.  {TI,XF,TF,XC,TC}mode cannot go in a reg at all: fp regs do
+    not support them and there's no enough integer regs to hold them.
+    Everything else is OK.  */
+ #define HARD_REGNO_MODE_OK(REGNO, MODE) \
+   (GET_MODE_UNIT_SIZE (MODE) <= 2*UNITS_PER_WORD                    \
+    && ((REGNO) <= R_CREG                                            \
+         || (GET_MODE_CLASS (MODE) == MODE_FLOAT                     \
+             || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)))
+ 
+ #define MODES_TIEABLE_P(MODE1, MODE2) \
+   (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))
+ 
+ 
+ /*** Handling Leaf Functions ********************************/
+ 
+ /* #define LEAF_REGISTERS */
+ /* #define LEAF_REG_REMAP (regno) */
+ 
+ /*** Registers That Form a Stack ****************************/
+ 
+ /* reg-stack2.c requires that STACK_REGS be not just "defined", but
+    rather defined to the number of register class containing all stack
+    registers. */
+ 
+ #define STACK_REGS  STACK_REGS_
+ 
+ /* Amount of register stacks on the machine.  Transputers has two:
+    [ABC]reg and F[ABC]reg.  On the models without FPU F[ABC]reg are
+    considered fixed registers, so compiler doesn't touch them. */
+ 
+ #define STACK_REG_NSTACKS  2
+ 
+ /* Register stacks' boundaries.  The regs that belong to the same
+    stack must have consequent numbers, the lowest numbered register
+    being the stack top.  */
+ 
+ #define STACK_REG_FIRST(STACKNO)        ((STACKNO) == 0? R_AREG: R_FAREG)
+ #define STACK_REG_LAST(STACKNO)         ((STACKNO) == 0? R_CREG: R_FCREG)
+ 
+ /* Tell which register stack the stack register REGNO belongs to.  */
+ 
+ #define STACK_REG_STACKNO(REGNO)        ((REGNO) >= R_FAREG)
+ 
+ /* This macro tells stack-register convertor pass what is the proper
+    reg-stack position for an insn operand.  The convertor inserts
+    reg-stack shuffling insns before the insn to bring the insn's operands
+    into the proper positions.
+ 
+    Unlike REG_CLASS_FROM_LETTER, this macro may be asked about
+    non-register operands containing a single stack register inside.
+    In this case, it is expected to return the class appropriate for
+    that register.
+    
+    'U' is an EXTRA_CONSTRAINT used for nonlocal memory references,
+    that contain a stack register somewhere inside a MEM.  Indicate
+    to the stack-reg converter that this register needs to be at the
+    reg-stack top before executing the insn.  */
+ 
+ #define STACK_REG_CLASS_FROM_LETTER(C) \
+   ((C) == 'r' ? GENERAL_REGS :                 \
+    (C) == 'a' ? AREG :                         \
+    (C) == 'b' ? BREG :                         \
+    (C) == 'c' ? CREG :                         \
+    (C) == 'f' && TARGET_HAVE_FPU ? FLOAT_REGS :\
+    (C) == 't' && TARGET_HAVE_FPU ? FAREG :     \
+    (C) == 'u' && TARGET_HAVE_FPU ? FBREG :     \
+    (C) == 'v' && TARGET_HAVE_FPU ? FCREG :     \
+    (C) == 'U' ? AREG :                         \
+    (C) == 'R' ? AREG :                         \
+    NO_REGS)
+ 
+ /* The following two macros handle `extra operands' that some insns
+    may have.  The registers that are live before a call or function
+    return are the extra operands.  Since these have no constraints,
+    stack register convertor cannot obtain the information it needs
+    for them in the regular way.  Instead, STACK_REG_EXTRA_OPERAND_CLASS
+    is used to determine the proper reg-stack position for an extra operand,
+    and STACK_REG_EXTRA_OPERAND_FLAGS describes various properties of
+    the operand.  */
+ 
+ /* Require the regs to be in the natural order on the reg-stack before
+    function call or return. */
+ 
+ #define STACK_REG_EXTRA_OPERAND_CLASS(INSN, REG) \
+   REGNO_REG_CLASS (REGNO (REG))
+ 
+ /* Extra operands must always have the flag INPUT.  POPPED indicates
+    that the insn automatically pops this operand off the stack. See
+    reg-stack.h, reg-stack.c for more details.  */
+ 
+ #define STACK_REG_EXTRA_OPERAND_FLAGS(INSN, REG) \
+   (GET_CODE (INSN) == CALL_INSN         ? (POPPED|INPUT) :  \
+    GET_CODE (PATTERN (INSN)) == RETURN  ? (INPUT)                    :  \
+    0)
+ 
+ /* Machine-dependent reg-stack shuffling routines called from reg-stack.new.  */
+ 
+ #define STACK_REG_EMIT_DROPS(STK, DROP_SET)   t800_emit_drops (STK, DROP_SET)
+ #define STACK_REG_EMIT_SWAPS(OLDSTK, NEWSTK)  t800_emit_swaps (OLDSTK, NEWSTK)
+ #define STACK_REG_EMIT_PUSHES(STK, PUSH_SET)  t800_emit_pushes (STK, PUSH_SET)
+ 
+ /* Tell reg-stack converter not to bother changing virtual stack
+    register numbers to hard register numbers, because on transputers
+    (unlike i387) it is not necessary.  Register operands never occur
+    explicitly in transputer assembler syntax, but are instead implied
+    by the insn which they are for. */
+ 
+ #define STACK_REGS_SUBSTITUTION_UNNECESSARY
+ 
+ 
+ /*** Obsolete Macros for Controlling Register Usage *********/
+ 
+ /* #define OVERLAPPING_REGNO_P(@var{regno}) */
+ 
+ #define INSN_CLOBBERS_REGNO_P(INSN, REGNO) \
+   insn_clobbers_regno_p (INSN, REGNO)
+ 
+ /* #define PRESERVE_DEATH_INFO_REGNO_P(@var{regno}) */
+ 
+ 
+ /*************************************************************
+  Register Classes
+ *************************************************************/
+ 
+ /* reg-stack2.c requires STACK_REGS to be #defined to the class
+    containing all stack registers.  So we name the corresponding enum
+    member differently to avoid failure if preprocessor does not permit
+    "recursive" definitions.
+ 
+    AB_REGS is the union of AREG ind BREG; it is used when handling
+    insn with two commutative operands in AREG and BREG.
+    FAB_REGS is its floating counterpart.  */
+ 
+ enum reg_class
+ {
+     NO_REGS,
+     AREG, BREG, CREG,
+     FAREG, FBREG, FCREG,
+     WREG,
+     AB_REGS,                    /* [AB]reg: AREG+BREG */
+     FAB_REGS,                   /* F[AB]reg: FAREG+FBREG */
+     GENERAL_REGS,               /* Areg, Breg, Creg */
+     FLOAT_REGS,                 /* FAreg, FBreg, FCreg */
+     WORKSPACE_REGS,             /* Wreg, Fake1, Fake2 */
+     BASE_REGS,                  /* Areg, Breg, Creg, Wreg, Fake1, Fake2 */
+     STACK_REGS_,                /* [ABC]reg, F[ABC]reg */
+     ALL_REGS,
+     LIM_REG_CLASSES
+ };
+ 
+ #define N_REG_CLASSES                   (int) LIM_REG_CLASSES
+ 
+ #define REG_CLASS_NAMES \
+   { "NO_REGS",                                          \
+     "AREG", "BREG", "CREG",                             \
+     "FAREG", "FBREG", "FCREG",                          \
+     "WREG",                                             \
+     "AB_REGS",                                          \
+     "FAB_REGS",                                         \
+     "GENERAL_REGS",                                     \
+     "FLOAT_REGS",                                       \
+     "WORKSPACE_REGS",                                   \
+     "BASE_REGS",                                        \
+     "STACK_REGS",                                       \
+     "ALL_REGS" }
+ 
+ #define REG_CLASS_CONTENTS \
+   { 0,                      /* NOREGS */                \
+     001, 002, 004,          /* AREG, BREG, CREG */      \
+     010, 020, 040,          /* FAREG, FBREG, FCREG */   \
+     0100,                   /* WREG */                  \
+     003,                    /* AB_REGS */               \
+     030,                    /* FAB_REGS */              \
+     007,                    /* GENERAL_REGS */          \
+     070,                    /* FLOAT_REGS */            \
+     0700,                   /* WORKSPACE_REGS */        \
+     0707,                   /* BASE_REGS */             \
+     0077,                   /* STACK_REGS */            \
+     0777 }                  /* ALL_REGS */
+ 
+ #define REGNO_REG_CLASS(REGNO) \
+   (REGNO <= R_WREG			\
+      ? ((enum reg_class)((REGNO)+1))	\
+      : (WORKSPACE_REGS))		\
+ 
+ #define BASE_REG_CLASS  BASE_REGS
+ #define INDEX_REG_CLASS  NO_REGS
+ 
+ #define REG_CLASS_FROM_LETTER(C) \
+   (((C) == 'r' || (C) == 'a' || (C) == 'b' || (C) == 'c')                    \
+      ? GENERAL_REGS :                                                        \
+    TARGET_HAVE_FPU && ((C) == 'f' || (C) == 't' || (C) == 'u' || (C) == 'v') \
+      ? FLOAT_REGS :                                                          \
+    NO_REGS)
+ 
+ #define REGNO_OK_FOR_INDEX_P(REGNO)  0
+ 
+ #define REGNO_OK_FOR_BASE_P(REGNO) \
+   (TEST_HARD_REG_BIT (reg_class_contents[(int) BASE_REGS],      \
+                       ((REGNO) < FIRST_PSEUDO_REGISTER)         \
+                         ? (REGNO) : reg_renumber[(REGNO)]))
+ 
+ #define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS
+ 
+ /* #define PREFERRED_OUTPUT_RELOAD_CLASS (@var{x}, @var{class}) */
+ /* #define LIMIT_RELOAD_CLASS(@var{mode}, @var{class}) */
+ 
+ /* We need a secondary reload for an address of the stack slot
+    corresponding to the failed pseudo which required the primary
+    reload.  It is currently needed only when reloading an FP
+    register.  QImode reloads are now done in SImode; it is safe
+    because the stack slots for pseudos always get BIGGEST_ALIGNMENT,
+    which is BITS_PER_WORD, so that QImode pseudos actually get
+    SImode stack slots.
+ 
+    true_regnum returns regno if X is a register and -1 otherwise;
+    we don't need a scratch only if X is a hard reg.
+    ... of if X is an (easy) constant.  */
+ 
+ #define SECONDARY_RELOAD_CLASS(CLASS, MODE, X) \
+   ((t800_fp_class (CLASS)					\
+     && (X) != CONST0_RTX (GET_MODE (X))				\
+     && ((unsigned) true_regnum(X) >= FIRST_PSEUDO_REGISTER	\
+         || ABCreg_operand (X, MODE)))				\
+    ? GENERAL_REGS : NO_REGS)
+ 
+ #if 0 /* Although we need secondary memory for copying between general
+ 	 and fp registers, we don't define this, since standard
+ 	 handling of secondary memory reloads doesn't expect that
+ 	 moving between fp registers and stack slots used as secondary
+ 	 memory in turn requires a scratch general register.  Instead,
+ 	 we handle such moves ourselves in reload_{in,out}*.  */
+ 
+ /* Copying between floating and any other reg requires an intermediate
+    memory location on T800 */
+ 
+ #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, M) \
+   secondary_memory_needed(CLASS1, CLASS2, M)
+ 
+ #endif
+ 
+ /*-#define SECONDARY_MEMORY_NEEDED_RTX (mode) */
+ /*-#define SECONDARY_MEMORY_NEEDED_MODE (mode) */
+ 
+ /* Allow using all registers for reloading since there are so
+    few of them on T800.  */
+ 
+ #define SMALL_REGISTER_CLASSES
+ 
+ /* Don't leave extra pseudos for global-alloc: they have little
+    chances to be allocated anyway.  Hope this will speed us up...  */
+ 
+ #define CLASS_LIKELY_SPILLED_P(class)  0
+ 
+ /* This is the size of MODE in words, except for the FP registers,
+    where a single reg always suffices.  */
+ 
+ #define CLASS_MAX_NREGS(CLASS, MODE) \
+  (t800_fp_class (CLASS) ? 1 : IN_WORDS (GET_MODE_SIZE (MODE)))
+ 
+ /* #define CLASS_CANNOT_CHANGE_SIZE */
+ 
+ /* 'I' stands for word-offset constant.  */
+ 
+ #define CONST_OK_FOR_LETTER_P(VALUE, C) \
+   ((C) == 'I'? ((VALUE) % UNITS_PER_WORD) == 0 :	\
+    0)
+ 
+ /* 'G' stands for 2.0, for `fpumulby2' and `fpudivby2';
+    'H' stands for 2e32, for `fpuexpinc32' and `fpuexpdec32'.
+ 
+    Yet another special floating value is 0.0, which is (unlike
+    2.0 end 2e32) permitted by LEGITIMATE_CONSTANT_P.  It currently
+    needs no constraint.  */
+ 
+ #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \
+   fp_specval_ok_for_letter (VALUE, C)
+ 
+ 
+ /* 'S' stands for a local memory reference, which is either
+      (mem (plus (Wreg) (offset)))  or  (mem (Wreg))
+ 
+    'R' is a simple nonlocal memory reference, (mem (ABCreg))
+ 
+    'U' is a general nonlocal memory reference, either (mem (ABCreg))
+      or  (mem (plus (ABCreg) (offset)))
+ 
+    'R' and 'U' are also recognized by STACK_REG_CLASS_FROM_LETTER so
+    that reg-stack pass is able to find out the proper reg-stack
+    position for the address register.  */
+ 
+ #define EXTRA_CONSTRAINT(X, C) \
+   ((C) == 'S'? local_operand (X, GET_MODE (X)) :    		\
+    (C) == 'R'? nonlocal_operand (X, GET_MODE (X)) :		\
+    (C) == 'U'? nonlocal_plus_operand (X, GET_MODE (X)) :	\
+    0)
+ 
+ 
+ /*************************************************************
+  Describing Stack Layout and Calling Conventions
+ *************************************************************/
+ 
+ /*** Basic Stack Layout *************************************/
+ 
+ /* The stack layout in this hypothetical run-time model is as follows:
+             +--------------------+
+             |   arg N            |
+             |   ...              |
+             |   arg 0            |
+             +--------------------+
+             |   return addr      |
+             +--------------------+
+             |   local N          |
+             |   ...              | (get_frame_size())
+             |   local 0          |
+             +--------------------+
+             |   outgoing arg N   |
+             |   ...              | (current_function_outgoing_args_size)
+             |   outgoing arg 0   |
+      Wreg ->+--------------------+
+   */
+ 
+ #define STACK_GROWS_DOWNWARD
+ #undef FRAME_GROWS_DOWNWARD
+ #undef ARGS_GROW_DOWNWARD
+ 
+ #define STARTING_FRAME_OFFSET  WORD_ROUND (current_function_outgoing_args_size)
+ 
+ /* Leaving this undefined saves a lot of hair in allocate_dynamic_stack_space(),
+    making no effect otherwise (it defaults to 0 in function.c) */
+ /* #define STACK_POINTER_OFFSET  (0) */
+ 
+ #define FIRST_PARM_OFFSET(FUNDECL)  (0)
+ 
+ /* See the comment for STACK_POINTER_OFFSET above */
+ /* #define STACK_DYNAMIC_OFFSET(FUNDECL) */
+ 
+ #define DYNAMIC_CHAIN_ADDRESS(FRAMEADDR)  ((void *)abort ())
+ /*-#define SETUP_FRAME_ADDRESSES () */
+ /*-#define RETURN_ADDR_RTX (count, frameaddr) */
+ /*-#define RETURN_ADDR_IN_PREVIOUS_FRAME */
+ 
+ 
+ /*** Registers That Address the Stack Frame *****************/
+ 
+ /* Stack pointer is a base reg for outgoing args;
+    Frame pointer is a base reg for local variables (stack slots);
+    Arg pointer is a base reg for incoming args.
+ 
+    On the T800, all these areas are addressed with Wreg.  However, it
+    is not good to define all three pointers to Wreg as GCC will
+    duplicate arg pointer in a general reg if ARG_POINTER_REGNUM ==
+    STACK_POINTER_REGNUM (see function.c).  Furthermore, the difference
+    between frame and arg pointers becomes known only after all stack
+    slots are allocated, i.e. in the reload pass. Therefore we use a
+    separate (fake) register for argument pointer and let the reload
+    pass eliminate it when the frame size becomes determined.  */
+ 
+ #define STACK_POINTER_REGNUM  R_FAKE2
+ #define FRAME_POINTER_REGNUM  R_WREG
+ /* #define HARD_FRAME_POINTER_REGNUM */
+ #define ARG_POINTER_REGNUM    R_FAKE1
+ 
+ /* ?? #define STATIC_CHAIN_REGNUM */
+ /* ?? #define STATIC_CHAIN_INCOMING_REGNUM */
+ /* ?? #define STATIC_CHAIN */
+ /* ?? #define STATIC_CHAIN_INCOMING */
+ 
+ 
+ /*** Eliminating Frame Pointer and Arg Pointer **************/
+ 
+ /* Wreg is the only register designated for addressing stack frame,
+    and we use it as a frame pointer.  Arg pointer is a fake register
+    which is eliminated to Wreg in reload pass.  For functions which do
+    not call alloca() stack pointer is another fake register, also
+    eliminated in favor of Wreg.  In functions that do call alloca() we
+    use a pseudo for stack pointer, so the mentioned fake stack pointer
+    register should not appear at all. */
+ 
+ #define FRAME_POINTER_REQUIRED  (1)
+ 
+ /*-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH_VAR) */
+ 
+ #define ELIMINABLE_REGS \
+   {{ ARG_POINTER_REGNUM, R_WREG},	\
+    { STACK_POINTER_REGNUM, R_WREG}}
+ 
+ #define CAN_ELIMINATE(FROM, TO)  (1)
+ 
+ #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET_VAR) \
+   switch (FROM)								\
+     {									\
+     case ARG_POINTER_REGNUM:						\
+       (OFFSET_VAR) = WORD_ROUND (current_function_outgoing_args_size)	\
+ 	+ WORD_ROUND (get_frame_size ())				\
+ 	  + UNITS_PER_WORD;  /* caller's Iptr */			\
+       break;								\
+ 									\
+     case STACK_POINTER_REGNUM:						\
+       (OFFSET_VAR) = 0;							\
+       break;								\
+ 									\
+     default:								\
+       abort ();								\
+     }
+ 
+ /* #define LONGJMP_RESTORE_FROM_STACK */
+ 
+ 
+ /*** Passing Function Arguments on the Stack ****************/
+ 
+ #define PROMOTE_PROTOTYPES
+ 
+ /*-#define PUSH_ROUNDING(npushed) */
+ 
+ #define ACCUMULATE_OUTGOING_ARGS
+ 
+ /*-#define REG_PARM_STACK_SPACE(FNDECL) */
+ /*-#define MAYBE_REG_PARM_STACK_SPACE */
+ /*-#define FINAL_REG_PARM_STACK_SPACE(const_size, var_size) */
+ /*-#define OUTGOING_REG_PARM_STACK_SPACE */
+ /*-#define STACK_PARMS_IN_REG_PARM_AREA */
+ 
+ #define RETURN_POPS_ARGS(FNDECL, FUNTYPE, STACK_SIZE)  0
+ 
+ 
+ /*** Passing Arguments in Registers *************************/
+ 
+ /* Normally the first three words of the arguments are passed in the
+    registers of the integer reg-stack; those are pushed onto the stack
+    by the `call' insn so that the callee will see all the arguments
+    arriving on the stack.
+ 
+    However, sometimes the caller needs to behave differently. First,
+    when calling a function by a pointer rather than name, `gcall' insn
+    is used instead of `call', which does not push integer reg-stack onto
+    the stack.  So we tell calls.c to put all the parms onto the stack in
+    this case.
+ 
+    Second, there may be complex cases when we should pass some arg on
+    the stack; in this case we pass all args on the stack to avoid the
+    complexity.  This situation is detected by FUNCTION_ARG_PRESCAN and
+    indicated by CUM.must_pass_in_stack.
+    
+    In this case, FUNCTION_ARG returns 0 for all args, forcing them
+    onto the stack, and returns const0_rtx when called after
+    processing args to produce next_arg_reg. This unusual value is
+    a sign to the call patterns to adapt to this unusual situation. */
+ 
+ #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
+   ((CUM).must_pass_in_stack                                         \
+     ? ((TYPE) != void_type_node ? 0 : const0_rtx)                   \
+     : ((CUM).lst_free_reg <= R_CREG                                 \
+         ? gen_rtx (REG, (MODE), (CUM).lst_free_reg)                 \
+         : 0 /* pass on stack */))
+ 
+ /* The called function finds all args on the stack. */
+ 
+ #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)  0
+ 
+ #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \
+   (! (CUM).must_pass_in_stack                                       \
+    && (CUM).lst_free_reg <= R_CREG                                  \
+    && (CUM).lst_free_reg + T800_ARG_SIZE (MODE, TYPE) > R_CREG + 1  \
+    ? R_CREG + 1 - (CUM).lst_free_reg                                \
+    : 0)                                                             \
+ 
+ /* There seems to be no need for this.  */
+ 
+ #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)  0
+ 
+ 
+ /* This macro has a chance to glance over all the arguments of the
+    function being called before FUNCTION_ARG is asked where each
+    particular argument should be passed.
+ 
+    On transputers, it can command to pass everything on stack if there
+    is an arg that would normally be passed in registers but cannot be
+    passed there for some reason (eg MUST_PASS_IN_STACK says it
+    shouldn't).
+ 
+    We also choose to pass everything in stack if current function uses
+    dynamic stack space allocation: in this case we have a pseudo stack
+    pointer which should be swapped with Wreg just before the actual
+    call, and we wouldn't have a scratch register required for this if
+    we passed in registers as usual.
+ 
+    If the passing on stack has been triggered, the `call' and
+    `call_value' patterns will use `j' or `gcall' instead of `call' to
+    avoid pushing [ABC]reg onto the stack.  */
+ 
+ #define FUNCTION_ARG_PRESCAN(CUM, MODE, TYPE, NAMED) \
+   do {                                                                  \
+     (CUM).must_pass_in_stack |= current_call_is_indirect;               \
+     (CUM).must_pass_in_stack |= current_function_calls_alloca;          \
+     if (! (CUM).must_pass_in_stack                                      \
+         && (CUM).lst_free_reg <= R_CREG)                                \
+       {                                                                 \
+         (CUM).must_pass_in_stack |= MUST_PASS_IN_STACK (MODE, TYPE);    \
+                                                                         \
+         /* If it is a large object that we would pass part in regs,     \
+            part on stack, it may be more efficient to pass it merely on \
+            stack.  */                                                   \
+ 									\
+         if ((CUM).lst_free_reg == R_AREG                                \
+             && T800_ARG_SIZE (MODE, TYPE) > 3)                          \
+           (CUM).must_pass_in_stack = 1;                                 \
+                                                                         \
+         FUNCTION_ARG_ADVANCE (CUM, MODE, TYPE, NAMED);                  \
+       }                                                                 \
+   } while (0)
+ 
+ /* Helper macro used from other macros in this section.  */
+ #define T800_ARG_SIZE(MODE, TYPE) \
+   IN_WORDS ((MODE) != BLKmode                           \
+              ? GET_MODE_SIZE (MODE)                     \
+              : int_size_in_bytes (TYPE))
+ 
+ typedef struct {
+   /* The first arg_regno free after scanning the arguments so far.  */
+   int lst_free_reg;
+ 
+   /* The flag set by FUNCTION_ARG_PRESCAN saying we dont want to pass
+      anything in registers for current call.  */
+   int must_pass_in_stack;
+ } CUMULATIVE_ARGS;
+ 
+ #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME) \
+   ((CUM).lst_free_reg = R_AREG,                     \
+    (CUM).must_pass_in_stack = 0)
+ 
+ /* Rewind CUMULATIVE_ARGS after FUNCTION_ARG_PRESCAN. */
+ #define RESET_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME) \
+   ((CUM).lst_free_reg = R_AREG)
+ 
+ 
+ /* - #define INIT_CUMULATIVE_INCOMING_ARGS(CUM, FNTYPE, LIBNAME) */
+ 
+ #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \
+  do {                                                       \
+    if (FUNCTION_ARG(CUM, MODE, TYPE, NAMED))                \
+      (CUM).lst_free_reg += T800_ARG_SIZE (MODE, TYPE);      \
+  } while (0)
+   
+ /* #define FUNCTION_ARG_PADDING(@var{mode}, @var{type}) */
+ /* #define FUNCTION_ARG_BOUNDARY(@var{mode}, @var{type}) */
+ 
+ #define FUNCTION_ARG_REGNO_P(REGNO)  ((unsigned)(REGNO) <= R_CREG)
+ 
+ 
+ /*** How Scalar Function Values Are Returned ****************/
+ 
+ /* Integer values are returned on the integer reg-stack.  Returning
+    floating values there is not efficient, since moves between
+    integer and and floating regs are costly.  The rest two ways are to
+    return either in a floating reg or in memory.  We choose the first:
+    floating values are returned on the floating reg-stack.
+ 
+    The `ret' instruction does not restore regs from stack, so the
+    caller will see returns just where the callee has put them (hence
+    FUNCTION_OUTGOING_VALUE not needed). */
+ 
+ /* - #define TRADITIONAL_RETURN_FLOAT */
+ 
+ /* This definition is agreed with PROMOTE_MODE & PROMOTE_FUNCTION_RETURN */
+ 
+ #define FUNCTION_VALUE(VALTYPE, FUNC) \
+   gen_rtx (REG,                                                             \
+            ((TREE_CODE (VALTYPE) == INTEGER_TYPE                            \
+              || TREE_CODE (VALTYPE) == ENUMERAL_TYPE                        \
+              || TREE_CODE (VALTYPE) == BOOLEAN_TYPE                         \
+              || TREE_CODE (VALTYPE) == CHAR_TYPE                            \
+              || TREE_CODE (VALTYPE) == POINTER_TYPE                         \
+              || TREE_CODE (VALTYPE) == OFFSET_TYPE)                         \
+             && TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)                    \
+            ? word_mode : TYPE_MODE (VALTYPE),                               \
+            (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_HAVE_FPU)            \
+                                   ? R_FAREG : R_AREG)
+ 
+ /* - #define FUNCTION_OUTGOING_VALUE(@var{valtype}, @var{func}) */
+ 
+ #define LIBCALL_VALUE(MODE) \
+   gen_rtx (REG, MODE, (TARGET_HAVE_FPU					    \
+                        && (GET_MODE_CLASS (MODE) == MODE_FLOAT              \
+                            || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)) \
+                       ? R_FAREG : R_AREG)
+ 
+ #define FUNCTION_VALUE_REGNO_P(REGNO) \
+   ((REGNO) == R_AREG || (TARGET_HAVE_FPU && (REGNO) == R_FAREG))
+ 
+ /* #define APPLY_RESULT_SIZE */
+ 
+ 
+ /*** How Large Values Are Returned **************************/
+ 
+ /* Passing struct value address as invisible first arg seems
+    to be the easiest way */
+ 
+ /* - #define RETURN_IN_MEMORY(TYPE) */
+ /* - #define DEFAULT_PCC_STRUCT_RETURN */
+ /* #define STRUCT_VALUE_REGNUM */
+ /* #define STRUCT_VALUE_INCOMING_REGNUM */
+ 
+ #define STRUCT_VALUE  0
+ #define STRUCT_VALUE_INCOMING  0
+ 
+ /* - #define PCC_STATIC_STRUCT_RETURN */
+ 
+ 
+ /*** Caller-Saves Register Allocation ***********************/
+ 
+ #define DEFAULT_CALLER_SAVES
+ /* #define CALLER_SAVE_PROFITABLE(REFS, CALLS) */
+ 
+ 
+ /*** Function Entry and Exit ********************************/
+ 
+ #define FUNCTION_PROLOGUE(file, frame_size) \
+   {									\
+     int totsize = IN_WORDS (frame_size) +				\
+                   IN_WORDS (current_function_outgoing_args_size);	\
+ 									\
+     /* Unused on t800; we don't expect to handle this */		\
+     if (current_function_pretend_args_size)				\
+       abort ();								\
+ 									\
+     if (totsize)							\
+       fprintf (file, "\tajw -%d\n", totsize);				\
+   }
+ 
+ /* We must use `return' pattern instead of epilogue on T800, because
+    jump to epilogue would clobber all regs, including the one carrying
+    return value.  */
+ 
+ /* - #define FUNCTION_EPILOGUE(FILE, SIZE)  */
+ 
+ #define EXIT_IGNORE_STACK                   0
+ 
+ /* - #define DELAY_SLOTS_FOR_EPILOGUE */
+ /* - #define ELIGIBLE_FOR_EPILOGUE_DELAY(INSN, N) */
+ 
+ 
+ /*** Generating Code for Profiling **************************/
+ 
+ /* For the first time, put stubs here */
+ 
+ #define FUNCTION_PROFILER(FILE, LABELNO)                        {}
+ /* #define PROFILE_BEFORE_PROLOGUE */
+ #define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)                  {}
+ #define BLOCK_PROFILER(FILE, BLOCKNO)                           {}
+ 
+ 
+ /*************************************************************
+  Implementing the Varargs Macros
+ *************************************************************/
+ 
+ /* This is no problem on T800, since all the args are incoming
+    on stack. Thus, standard implementation of VARARGS is applicable */
+ 
+ /* #define EXPAND_BUILTIN_SAVEREGS(ARGS) */
+ #define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL) {}
+ 
+ 
+ /*************************************************************
+  Trampolines for Nested Functions
+ *************************************************************/
+ 
+ /* Not implemented -- standard C/C++ should not need those */
+ 
+ #define TRAMPOLINE_TEMPLATE(FILE)                               abort ();
+ /* #define TRAMPOLINE_SECTION */
+ #define TRAMPOLINE_SIZE                                         1
+ /* #define TRAMPOLINE_ALIGNMENT */
+ #define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN)       abort ();
+ /* - #define ALLOCATE_TRAMPOLINE(FP) */
+ /* #define INSN_CACHE_SIZE */
+ /* #define INSN_CACHE_LINE_WIDTH */
+ /* #define INSN_CACHE_DEPTH */
+ /* #define TRANSFER_FROM_TRAMPOLINE */
+ 
+ 
+ /*************************************************************
+  Implicit Calls to Library Routines
+ *************************************************************/
+ 
+ /* #define MULSI3_LIBCALL */
+ /* #define DIVSI3_LIBCALL */
+ /* #define UDIVSI3_LIBCALL */
+ /* #define MODSI3_LIBCALL */
+ /* #define UMODSI3_LIBCALL */
+ /* #define MULDI3_LIBCALL */
+ /* #define DIVDI3_LIBCALL */
+ /* #define UDIVDI3_LIBCALL */
+ /* #define MODDI3_LIBCALL */
+ /* #define UMODDI3_LIBCALL */
+ /* #define TARGET_EDOM */
+ /* #define GEN_ERRNO_RTX */
+ 
+ /* Use mem{set,cpy} rather than b{zero,copy}. */
+ #define TARGET_MEM_FUNCTIONS
+ 
+ /* ? #define LIBGCC_NEEDS_DOUBLE */
+ /* ? #define FLOAT_ARG_TYPE */
+ /* ? #define FLOATIFY(@var{passed-value}) */
+ /* ? #define FLOAT_VALUE_TYPE */
+ /* ? #define INTIFY(@var{float-value}) */
+ 
+ /* - #define nongcc_SI_type */
+ 
+ /* perform_@dots{} */
+ /* #define NEXT_OBJC_RUNTIME */
+ 
+ 
+ /*************************************************************
+  Addressing Modes
+ *************************************************************/
+ 
+ /* - #define HAVE_POST_INCREMENT */
+ /* - #define HAVE_PRE_INCREMENT */
+ /* - #define HAVE_POST_DECREMENT */
+ /* - #define HAVE_PRE_DECREMENT */
+ 
+ /* The only T800 commands permitting constant address are `j',
+    `cj' and `call'.  The address in this case is a code label
+     or a function symref.
+ 
+    ??? This used to accept LABEL_REF's only.  Do those extra
+    checks make any difference?  */
+ 
+ #if 0  /* Looks like 0 works just as well... */
+ #define CONSTANT_ADDRESS_P(X) \
+   (GET_CODE (X) == LABEL_REF				\
+    || (GET_CODE (X) == SYMBOL_REF			\
+        && SYMBOL_REF_FLAG (X) == 0)			\
+    || (GET_CODE (X) == CONST				\
+        && ! t800_dataseg_symrefs_mentioned_p (X)))
+ #else
+ #define CONSTANT_ADDRESS_P(X)  0
+ #endif
+ 
+ 
+ #define MAX_REGS_PER_ADDRESS  1
+ 
+ /* This is not made a function since it uses REG_OK_FOR_BASE_P,
+    which is call-place-sensitive.
+ 
+    We accept Wreg-based addresses even in floating modes for the sake
+    of ABCreg loads/stores in floating modes.
+ 
+    We accept Wreg-based addresses and addresses with index in QI and
+    HI modes, because a few patterns are able to handle such addresses
+    with multi-insn sequences; this tends to make better code than
+    standard reloading.  */
+ 
+ #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL) \
+   switch (GET_CODE (X))							\
+     {									\
+      rtx X1;								\
+ 									\
+      case REG:								\
+        if (REG_OK_FOR_BASE_P (X))					\
+ 	 goto LABEL;							\
+        break;								\
+ 									\
+      case PLUS:								\
+        if (GET_CODE (XEXP (X, 0)) != REG				\
+ 	   || ! REG_OK_FOR_BASE_P (XEXP (X, 0)))			\
+ 	 break;								\
+ 									\
+        X1 = XEXP (X, 1);						\
+ 									\
+        /* instruction set supports word offsets only */			\
+ 									\
+        if (GET_CODE (X1) == CONST_INT					\
+ 	   && (INTVAL (X1) % UNITS_PER_WORD) == 0)			\
+ 	 goto LABEL;							\
+ 									\
+        /* In dataseg-by-pointer model, constant expressions		\
+ 	  involving data segment symbols are valid offsets */		\
+ 									\
+        if (! TARGET_DATASEG_BY_POINTER)					\
+ 	 break;								\
+ 									\
+        if (GET_CODE (X1) == SYMBOL_REF					\
+ 	   && SYMBOL_REF_FLAG (X1) == 1)				\
+ 	 goto LABEL;							\
+ 									\
+        if (GET_CODE (X1) == CONST)					\
+ 	 {								\
+ 	   X1 = XEXP (X1, 0);						\
+ 	   if (GET_CODE (X1) == PLUS					\
+ 	       && GET_CODE (XEXP (X1, 1)) == CONST_INT			\
+ 	       && (INTVAL (XEXP (X1, 1)) % UNITS_PER_WORD) != 0) 	\
+ 	     break;							\
+ 									\
+ 	   /* The rest may be arbitrarily complex expression		\
+ 	      of symrefs.  Assuming data and code segment labels 	\
+ 	      never mix in CONST, a simple check for presence		\
+ 	      of data segment symref should be enough.  */		\
+ 									\
+ 	   if (t800_dataseg_symrefs_mentioned_p (X1))			\
+ 	     goto LABEL;						\
+ 	 }								\
+        }
+ 
+ #ifdef REG_OK_STRICT
+ #define REG_OK_FOR_INDEX_P(X)  0
+ #define REG_OK_FOR_BASE_P(X)   (REGNO_OK_FOR_BASE_P (REGNO (X)))
+ #else /* ! REG_OK_STRICT */
+ #define REG_OK_FOR_INDEX_P(X)  0
+ #define REG_OK_FOR_BASE_P(X) \
+   (REGNO (X) >= FIRST_PSEUDO_REGISTER \
+    || TEST_HARD_REG_BIT (reg_class_contents[(int) BASE_REGS], REGNO (X)))
+ #endif /* REG_OK_STRICT */
+ 
+ /* Make it a function for the sake of debugging */
+ 
+ #define LEGITIMIZE_ADDRESS(x, oldx, mode, win) \
+   do {									\
+     extern rtx t800_legitimize_address (rtx, rtx, enum machine_mode);	\
+     rtx newx =  t800_legitimize_address (x, oldx, mode);		\
+     if (newx != x)							\
+       {									\
+         x = newx;							\
+         goto win;							\
+       }									\
+   } while (0)
+ 
+ /* ? maybe access to uneven address in word mode? */
+ 
+ #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)
+ 
+ /* The only immediate floating constant we can handle is 0.0 (with
+    fpldzero{sn,db}).  Turn all others into memory constants.
+    We could have a define_expand to load immediate DImode.  But I
+    suspect we'll get better code by forcing them to memory, too,
+    because DImode operations are done by parts, anyway.  */
+ 
+ #define LEGITIMATE_CONSTANT_P(X) \
+   ((GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT \
+     || (X) == CONST0_RTX (GET_MODE (X))) \
+    && GET_CODE (X) != CONST_DOUBLE)
+ 
+ 
+ /*************************************************************
+  Condition Code Status
+ *************************************************************/
+ 
+ /*-#define CC_STATUS_MDEP */
+ /*-#define CC_STATUS_MDEP_INIT */
+ /*-#define NOTICE_UPDATE_CC(@var{exp}, @var{insn}) */
+ /*-#define EXTRA_CC_MODES */
+ /*-#define EXTRA_CC_NAMES */
+ /*-#define SELECT_CC_MODE(OP, X, Y) */
+ 
+ /* ??? probably we could make use of this */
+ 
+ /* #define CANONICALIZE_COMPARISON (code, op0, op1) */
+ 
+ /* #define REVERSIBLE_CC_MODE (mode) */
+ 
+ 
+ /*************************************************************
+  Describing Relative Costs of Operations
+ *************************************************************/
+ 
+ /* ??? this is still very raw... */
+ 
+ /* Tell the truth about integer contant cost by computing the number
+    of pfix insns required to load it.  Scale the cost down in order to
+    ecourage the use of consts instead of pseudos which are likely to
+    spill.  */
+ 
+ #define CONST_COSTS(X,CODE,OUTER_CODE) \
+   case CONST_INT:                               \
+     return t800_const_cost (INTVAL (X)) / 3;    \
+   case LABEL_REF:                               \
+   case SYMBOL_REF:                              \
+   case CONST:                                   \
+   case CONST_DOUBLE:                            \
+     /* 0 makes the same effect as 4             \
+        with current test suite */               \
+     return 1;
+ 
+ /* #define RTX_COSTS(X, CODE, OUTER_CODE) */
+ 
+ /* Strange as it is, this seems to have no effect on the result
+    of compilation of all the test cases.  */
+ #define ADDRESS_COST(ADDRESS) 0     /* t800_address_cost (ADDRESS) */
+ 
+ /* On the T800, copying between floating-point and fixed-point
+    registers is expensive.  */
+ extern char register_move_cost[][FIRST_PSEUDO_REGISTER];
+ 
+ #define REGISTER_MOVE_COST(CLASS1, CLASS2) \
+   (register_move_cost[CLASS1][CLASS2])
+ 
+ /* SImode move between reg of general reg-stack and stack slot is sometimes
+    as fast as a reg-to-reg move. Byte and float-point moves require
+    address reloading and are therefore declared more costly (is it the
+    right way?).  */
+ #define MEMORY_MOVE_COST(MODE) \
+   ((MODE) == SImode? 4 : 8)
+ 
+ /* With BRANCH_COST == 1, the compiler tries to use conditional jumps
+    in logical expressions extensively, which is not too good since
+    it may turn out being inv_cj comprising two insns.  Try making it
+    a bit coster...  */
+ 
+ #define BRANCH_COST  2
+ 
+ /* Do word access whenever possible.  */
+ #define SLOW_BYTE_ACCESS  1
+ 
+ /* #define SLOW_ZERO_EXTEND */
+ /* #define SLOW_UNALIGNED_ACCESS */
+ /* #define DONT_REDUCE_ADDR */
+ 
+ /* Since `lb/sb' and `ldnl/stnl' pop the addresses, it's better to use
+    `move' when more than one load+store is required.  Note that expr.c
+    actually copies by pieces only if move_by_pieces_ninsns() < MOVE_RATIO,
+    though the documentation makes to think this ought to be <=.
+    So increase it by 1...  */
+ 
+ #define MOVE_RATIO                          (1+1)
+ 
+ /* `call' is better than `gcall' */
+ #define NO_FUNCTION_CSE  1
+ #define NO_RECURSIVE_FUNCTION_CSE  1
+ 
+ /* #define ADJUST_COST (@var{insn}, @var{link}, @var{dep_insn}, @var{cost}) */
+ 
+ /*************************************************************
+  Dividing the Output into Sections (Texts, Data, @dots{})
+ *************************************************************/
+ 
+ #define TEXT_SECTION_ASM_OP  ".text"
+ #define DATA_SECTION_ASM_OP  ".data"
+ 
+ /* #define SHARED_SECTION_ASM_OP */
+ /* #define INIT_SECTION_ASM_OP */
+ 
+ #define BSS_SECTION_ASM_OP  ".bss"
+ 
+ /* Define the .bss section for ASM_OUTPUT_LOCAL to use. */
+ 
+ #define EXTRA_SECTIONS in_bss
+ 
+ #define EXTRA_SECTION_FUNCTIONS \
+ void								\
+ bss_section ()							\
+ {								\
+   if (in_section != in_bss)					\
+     {								\
+       fprintf (asm_out_file, "%s\n", BSS_SECTION_ASM_OP);	\
+       in_section = in_bss;					\
+     }								\
+ }
+ 
+ /* #define READONLY_DATA_SECTION */
+ /* #define SELECT_SECTION(EXP, RELOC) */
+ /* #define SELECT_RTX_SECTION(MODE, RTX) */
+ /* #define JUMP_TABLES_IN_TEXT_SECTION */
+ 
+ /* This macro is called just after making RTX for data object whose
+    declaration is DECL.  We use it to mark SYMBOL_REF with `1' in
+    SYMBOL_REF_FLAG if is belongs to data segment, `0' if it is in text
+    segment.  This info is useful in dataseg-by-pointer model; see movM
+    patterns for details.  */
+ 
+ #define ENCODE_SECTION_INFO(decl)					\
+   do {									\
+     int data_symbol;                                                    \
+                                                                         \
+     if (TREE_CODE (decl) == FUNCTION_DECL)                              \
+       data_symbol = 0;                                                  \
+     else if (TREE_CODE (decl) == STRING_CST && flag_writable_strings)	\
+       data_symbol = 1;                                                  \
+     else if (TREE_CONSTANT (decl))                                      \
+       data_symbol = 0;                                                  \
+     else                                                                \
+       data_symbol = 1;                                                  \
+                                                                         \
+     if (data_symbol)                                                    \
+       {                                                                 \
+         rtx rtl = (TREE_CODE_CLASS (TREE_CODE (decl)) != 'd'		\
+                    ? TREE_CST_RTL (decl) : DECL_RTL (decl));		\
+         SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;				\
+       }                                                                 \
+   } while (0)
+ 
+ /* #define STRIP_NAME_ENCODING (@var{var}, @var{sym_name}) */
+ 
+ 
+ /*************************************************************
+  Position Independent Code
+ *************************************************************/
+ 
+ /* #define PIC_OFFSET_TABLE_REGNUM */
+ /* #define FINALIZE_PIC */
+ 
+ /* do not bother for the first time */
+ #define LEGITIMATE_PIC_OPERAND_P(X)         0
+ 
+ 
+ /*************************************************************
+  Defining the Output Assembler Language
+ *************************************************************/
+ 
+ /*** The Overall Framework of an Assembler File *************/
+ 
+ #define ASM_FILE_START(STREAM)              {}
+ #define ASM_FILE_END(STREAM)                {}
+ #define ASM_IDENTIFY_GCC(FILE)              {}
+ #define ASM_COMMENT_START                   "//"
+ #define ASM_APP_ON                          ""
+ #define ASM_APP_OFF                         ""
+ /* #define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME) */
+ /* #define ASM_OUTPUT_SOURCE_LINE(STREAM, LINE) */
+ /* #define ASM_OUTPUT_IDENT(@var{stream}, @var{string}) */
+ /* #define ASM_OUTPUT_SECTION_NAME (stream, string) */
+ /* #define OBJC_PROLOGUE */
+ 
+ 
+ /*** Output of Data *****************************************/
+ 
+ /* T800 does not have a float format wider that DOUBLE.  */
+ 
+ /*-#define ASM_OUTPUT_LONG_DOUBLE(STREAM, VALUE) */
+ 
+ #ifdef HOST_WORDS_BIG_ENDIAN
+   /* Doubles on host are stored in memory with the high order word first. */		\
+ #define ASM_OUTPUT_DOUBLE(STREAM, VALUE) \
+   do { union { double d; int i[2];} u;                          	\
+     u.d = (VALUE);                                              	\
+     fprintf (STREAM, "\t.word 0x%x, 0x%x\t// double %.20g\n",   	\
+              u.i[1], u.i[0], u.d);					\
+   } while (0)
+ #else
+ #define ASM_OUTPUT_DOUBLE(STREAM, VALUE) \
+   do { union { double d; int i[2];} u;                          	\
+     u.d = (VALUE);                                              	\
+     fprintf (STREAM, "\t.word 0x%x, 0x%x\t// double %.20g\n",   	\
+              u.i[0], u.i[1], u.d);                              	\
+   } while (0)
+ #endif
+ 
+ #define ASM_OUTPUT_FLOAT(STREAM, VALUE) \
+   do { union { float f; int i[2];} u;                           \
+     u.f = (VALUE);                                              \
+     fprintf (STREAM, "\t.word 0x%x\t// float %.12g\n",          \
+              u.i[0], u.f);                                      \
+   } while (0)
+ 
+ /*-#define ASM_OUTPUT_THREE_QUARTER_FLOAT (stream, value) */
+ /*-#define ASM_OUTPUT_SHORT_FLOAT (stream, value) */
+ /*-#define ASM_OUTPUT_BYTE_FLOAT (stream, value) */
+ /*-#define ASM_OUTPUT_QUADRUPLE_INT(STREAM, EXP) */
+ /*-#define ASM_OUTPUT_DOUBLE_INT(STREAM, EXP) */
+ 
+ #define ASM_OUTPUT_INT(STREAM, EXP) \
+   (fprintf (STREAM, "\t.word "),        \
+    output_addr_const (STREAM, EXP),		\
+    putc ('\n', STREAM))
+ 
+ #define ASM_OUTPUT_SHORT(STREAM, EXP) \
+   (GET_CODE (EXP) == CONST_INT                          		\
+     ? fprintf (STREAM, TARGET_SHORT16? "\t.half %u\n": "\t.word %u\n",	\
+ 	       INTVAL (EXP))    					\
+     : (abort (),0))
+ 
+ #define ASM_OUTPUT_CHAR(STREAM, EXP) \
+   (GET_CODE (EXP) == CONST_INT						\
+     ? fprintf (STREAM,							\
+                (unsigned char) INTVAL (EXP) >= ' '			\
+                && INTVAL (EXP) != '\177'				\
+                  ? "\t.byte '%c'\n"					\
+                  : "\t.byte '\\%o'\n", (unsigned char) INTVAL (EXP))	\
+     : (abort (),0))
+ 
+ #define ASM_OUTPUT_BYTE(STREAM, VALUE) \
+   fprintf (STREAM, "\t.byte %u\n", (char) VALUE)
+ 
+ #define ASM_BYTE_OP                         ".byte"
+ 
+ /* Rely on defaults.h for this */
+ 
+ /*-#define ASM_OUTPUT_ASCII(STREAM, PTR, LEN) */
+ 
+ /* #define ASM_OUTPUT_POOL_PROLOGUE(FILE, FUNNAME, FUNDECL, SIZE) */
+ /* #define ASM_OUTPUT_SPECIAL_POOL_ENTRY (FILE, X, MODE, ALIGN, LABELNO, JUMPTO) */
+ /* #define IS_ASM_LOGICAL_LINE_SEPARATOR (C) */
+ 
+ #define ASM_OPEN_PAREN                      "("
+ #define ASM_CLOSE_PAREN                     ")"
+ 
+ 
+ /*** Output of Uninitialized Variables **********************/
+ 
+ /* #define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED) */
+ 
+ #define ASM_OUTPUT_ALIGNED_COMMON(STREAM, NAME, SIZE, ALIGNMENT) \
+   do {                                                              \
+     if ((ALIGNMENT) > BITS_PER_UNIT)				    \
+       fprintf (STREAM, "\t.align %u\n", (ALIGNMENT)/BITS_PER_UNIT); \
+     fprintf (STREAM, ".comm ");                                     \
+     assemble_name (STREAM, NAME);                                   \
+     fprintf (STREAM, ", %u;\n", SIZE);                              \
+   } while (0)
+ 
+ /* #define ASM_OUTPUT_SHARED_COMMON(STREAM, NAME, SIZE, ROUNDED) */
+ /* #define ASM_OUTPUT_LOCAL(STREAM, NAME, SIZE, ROUNDED) */
+ 
+ #define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGNMENT) \
+   do {                                                              \
+     bss_section ();                                                 \
+     if ((ALIGNMENT) > BITS_PER_UNIT)				    \
+       fprintf (STREAM, "\t.align %u\n", (ALIGNMENT)/BITS_PER_UNIT); \
+     ASM_OUTPUT_LABEL (STREAM, NAME);                                \
+     fprintf (STREAM, "\t.byte ?[%u]\n", SIZE);                      \
+   } while (0)
+ 
+ /* #define ASM_OUTPUT_SHARED_LOCAL(STREAM, NAME, SIZE, ROUNDED) */
+ 
+ 
+ /*** Output and Generation of Labels ************************/
+ 
+ #define ASM_OUTPUT_LABEL(STREAM, NAME) \
+   do {                                                          \
+     assemble_name (STREAM, NAME);                               \
+     fprintf (STREAM, ":\n");                                    \
+   } while (0)
+ 
+ /* #define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL) */
+ /* #define ASM_DECLARE_FUNCTION_SIZE(STREAM, NAME, DECL) */
+ /* #define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL) */
+ /* #define ASM_FINISH_DECLARE_OBJECT (stream, decl, toplevel, atend) */
+ 
+ #define ASM_GLOBALIZE_LABEL(STREAM, NAME) \
+   do {                                                          \
+     fprintf (STREAM, ".globl ");                                \
+     assemble_name (STREAM, NAME);                               \
+     fprintf (STREAM, ";\n");                                    \
+   } while (0)
+ 
+ #define ASM_OUTPUT_EXTERNAL(STREAM, DECL, NAME) \
+   do {                                                          \
+     fprintf (STREAM, ".globl ");                                \
+     assemble_name (STREAM, NAME);                               \
+     fprintf (STREAM, ";\n");                                    \
+   } while (0)
+ 
+ #define ASM_OUTPUT_EXTERNAL_LIBCALL(STREAM, SYMREF) \
+   do {                                                          \
+     fprintf (STREAM, ".globl ");                                \
+     assemble_name (STREAM, XSTR (SYMREF, 0));                   \
+     fprintf (STREAM, ";\n");                                    \
+   } while (0)
+ 
+ #define ASM_OUTPUT_LABELREF(STREAM, NAME) \
+   fprintf (STREAM, "_%s", NAME)
+ 
+ #define ASM_OUTPUT_INTERNAL_LABEL(STREAM, PREFIX, NUM) \
+   fprintf (STREAM, "%s@%u:\n", PREFIX, NUM)
+ 
+ #define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM) \
+   sprintf (STRING, "*%s@%u", PREFIX, NUM)
+ 
+ #define ASM_FORMAT_PRIVATE_NAME(OUTVAR, NAME, NUMBER) \
+   sprintf ((OUTVAR) = (char *) alloca (strlen (NAME) + 12),     \
+            "%s@@%u", NAME, NUMBER)
+ 
+ /* #define OBJC_GEN_METHOD_LABEL(BUF, IS_INST, CLASS_NAME, CAT_NAME, SEL_NAME) */
+ 
+ 
+ /*** Macros Controlling Initialization Routines ************/
+ 
+ /* #define INIT_SECTION_ASM_OP */
+ /* #define HAS_INIT_SECTION */
+ /* #define INVOKE__main */
+ /* #define ASM_OUTPUT_CONSTRUCTOR(STREAM, NAME) */
+ /* #define ASM_OUTPUT_DESTRUCTOR(STREAM, NAME) */
+ /* #define OBJECT_FORMAT_COFF */
+ /* #define OBJECT_FORMAT_ROSE */
+ /* #define REAL_NM_FILE_NAME */
+ 
+ 
+ /*** Output of Assembler Instructions ***********************/
+ 
+ /* As the T800 is a stack machine, assembler has no syntax
+    for register names. Nevertheless, we should provide
+    register names, eg for use in clobber section of `asm' statement */
+ 
+ #define REGISTER_NAMES \
+   {"Areg","Breg","Creg","FAreg","FBreg","FCreg","Wreg","Fake1","Fake2"}
+ 
+ /* "Wreg[0]" may be mentioned in the clobbers section of asm_operands
+    to indicate that the asm clobbers the word at the top of workspace.
+    See ASM_SPECIAL_CLOBBER below for how this is handled.  */
+ 
+ #define ADDITIONAL_REGISTER_NAMES \
+   {"Wreg[0]", -10}
+ 
+ /* ASM_SPECIAL_CLOBBER allows you to handle clobbers of something other
+    than registers of their pseudonyms in the clobbers section of
+    asm_operands.  Make ADDITIONAL_REGISTER_NAMES return some weird
+    register number for the special clobber, and define
+    ASM_SPECIAL_CLOBBER do something special when this number is seen in
+    expand_asm_operands.  */
+ 
+ /* Some instructions that can be used in `asm' clobber the word near
+    the stack top (Wreg[0]).  This word belongs to the outgoing
+    arguments area, so the clobberage won't harm unless the asm occurs
+    in one of the function's arguments.  ??? It should not occur in such
+    context, because `asm's are statements, not expressions---but with
+    GNU extensions one *can* put statements within expressions, so the
+    danger exists.  But what the hell, people using asm are supposed
+    to be conscious enough to avoid this.
+ 
+    When such asm is seen we want to ensure that the outgoing arguments
+    area is at least one word large; otherwise, the asm would clobber
+    one of local variables or even the function return address.  This is
+    what this macro is doing.  */
+ 
+ #define ASM_SPECIAL_CLOBBER(REGNO) \
+   if (REGNO == -10)							\
+     {									\
+       if (current_function_outgoing_args_size < UNITS_PER_WORD)		\
+ 	current_function_outgoing_args_size = UNITS_PER_WORD;		\
+     }
+ 
+   
+ /* #define ASM_OUTPUT_OPCODE(STREAM, PTR) */
+ /* #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) */
+ 
+ /* On T800, there is no diversity of possible operands. An operand
+    may be either an integer constant or symbol/label ref, that's all.
+    The last case is in the competence of PRINT_OPERAND_ADDRESS, so that
+    the former is the only one we should process here.
+    Valid CODE characters are:
+    w - scale byte offset down to word offset (divide by word size);
+    */
+ #define PRINT_OPERAND(STREAM, X, CODE)  print_operand(STREAM, X, CODE)
+ 
+ /* No punctuation chars currently used in t800.md */
+ /* #define PRINT_OPERAND_PUNCT_VALID_P(CODE) */
+ 
+ /* The only valid address operands are symbol and label refs */
+ #define PRINT_OPERAND_ADDRESS(STREAM, X) \
+   output_addr_const (STREAM, X);
+ 
+ /* #define DBR_OUTPUT_SEQEND(FILE) */
+ 
+ /* #define REGISTER_PREFIX */
+ /* #define LOCAL_LABEL_PREFIX */
+ /* #define USER_LABEL_PREFIX */
+ /* #define IMMEDIATE_PREFIX */
+ 
+ /* #define ASSEMBLER_DIALECT */
+ 
+ /* ???, only for profiling. Put a stub... */
+ #define ASM_OUTPUT_REG_PUSH(STREAM, REGNO)                      abort ()
+ #define ASM_OUTPUT_REG_POP(STREAM, REGNO)                       abort ()
+ 
+ 
+ /*** Output of Dispatch Tables ******************************/
+ 
+ #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, VALUE, REL) \
+   do {								\
+     extern int t800_expected_table_label;			\
+ 								\
+     if ((REL) == t800_expected_table_label)			\
+       fprintf (STREAM, "\t.word L@%u-L@%ua\n", VALUE, REL);	\
+   } while (0)
+ 
+ #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \
+   abort ();
+ 
+ #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE) \
+   do {								\
+     ASM_OUTPUT_ALIGN (FILE, 2);					\
+     ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);		\
+   } while (0)
+ 
+ /* - #define ASM_OUTPUT_CASE_END(STREAM, NUM, TABLE) */
+ 
+ 
+ /*** Assembler Commands for Alignment ***********************/
+ 
+ /* #define ASM_OUTPUT_ALIGN_CODE(FILE) */
+ /* #define ASM_OUTPUT_LOOP_ALIGN(FILE) */
+ 
+ #define ASM_OUTPUT_SKIP(STREAM, NBYTES) \
+   fprintf (STREAM, "\t.byte 0[%u];\n", NBYTES);
+   
+ /* - #define ASM_NO_SKIP_IN_TEXT */
+ 
+ #define ASM_OUTPUT_ALIGN(STREAM, POWER) \
+   fprintf (STREAM, "\t.align %u;\n", 1 << (POWER));
+ 
+ 
+ /*************************************************************
+  Controlling Debugging Information Format
+ *************************************************************/
+ 
+ 
+ /*** Macros Affecting All Debugging Formats ****************/
+ 
+ #define DBX_REGISTER_NUMBER(REGNO)  (REGNO)
+ 
+ /* Leave those undefined for now, so that default computation be used.
+    We will probably have to correct this, as we always eliminate the
+    frame pointer  */
+ /* #define DEBUGGER_AUTO_OFFSET (@var{x}) */
+ /* #define DEBUGGER_ARG_OFFSET (@var{offset}, @var{x}) */
+ /* #define PREFERRED_DEBUGGING_TYPE */
+ 
+ /*** Specific Options for DBX Output ***********************/
+ 
+ /* Leave this disabled until ast learns to undersatnd stabs  */
+ /* #define DBX_DEBUGGING_INFO */
+ /* - #define XCOFF_DEBUGGING_INFO */
+ 
+ /* For the following, defaults seems to be OK for us.  */
+ /* #define DEFAULT_GDB_EXTENSIONS */
+ /* #define DEBUG_SYMS_TEXT */
+ /* #define ASM_STABS_OP */
+ /* #define ASM_STABD_OP */
+ /* #define ASM_STABN_OP */
+ /* #define DBX_NO_XREFS */
+ /* #define DBX_CONTIN_LENGTH */
+ /* #define DBX_CONTIN_CHAR */
+ /* #define DBX_STATIC_STAB_DATA_SECTION */
+ /* #define DBX_TYPE_DECL_STABS_CODE */
+ /* #define DBX_STATIC_CONST_VAR_CODE */
+ /* #define DBX_REGPARM_STABS_CODE */
+ /* #define DBX_REGPARM_STABS_LETTER */
+ /* #define DBX_MEMPARM_STABS_LETTER */
+ /* #define DBX_FUNCTION_FIRST */
+ /* #define DBX_LBRAC_FIRST */
+ 
+ /*** Open-Ended Hooks for DBX Format ***********************/
+ 
+ /* #define DBX_OUTPUT_LBRAC (@var{stream}, @var{name}) */
+ /* #define DBX_OUTPUT_RBRAC (@var{stream}, @var{name}) */
+ /* #define DBX_OUTPUT_ENUM (@var{stream}, @var{type}) */
+ /* #define DBX_OUTPUT_FUNCTION_END(STREAM, FUNCTION) */
+ /* #define DBX_OUTPUT_STANDARD_TYPES(SYMS) */
+ 
+ /*** File Names in DBX Format ******************************/
+ 
+ /* #define DBX_WORKING_DIRECTORY */
+ /* #define DBX_OUTPUT_MAIN_SOURCE_FILENAME(STREAM, NAME) */
+ /* #define DBX_OUTPUT_MAIN_SOURCE_DIRECTORY(STREAM, NAME) */
+ /* #define DBX_OUTPUT_MAIN_SOURCE_FILE_END(STREAM, NAME) */
+ /* #define DBX_OUTPUT_SOURCE_FILENAME(STREAM, NAME) */
+ 
+ /*** Macros for SDB and DWARF Output ***********************/
+ 
+ /* #define SDB_DEBUGGING_INFO */
+ /* #define DWARF_DEBUGGING_INFO */
+ /* #define PUT_SDB_@dots{} */
+ /* #define SDB_DELIM */
+ /* #define SDB_GENERATE_FAKE */
+ /* #define SDB_ALLOW_UNKNOWN_REFERENCES */
+ /* #define SDB_ALLOW_FORWARD_REFERENCES */
+ 
+ 
+ /*************************************************************
+  Cross Compilation and Floating Point Format
+ *************************************************************/
+ 
+ /* Fortunately, both Besta and T800 use IEEE floating-point format.
+    As it is, we have nothing to do with this section */
+ 
+ /* #define REAL_VALUE_TYPE */
+ /* #define REAL_VALUES_EQUAL(X, Y) */
+ /* #define REAL_VALUES_LESS(X, Y) */
+ /* #define REAL_VALUE_LDEXP(X, SCALE) */
+ /* #define REAL_VALUE_FIX(X) */
+ /* #define REAL_VALUE_UNSIGNED_FIX(X) */
+ /* #define REAL_VALUE_FIX_TRUNCATE(X) */
+ /* #define REAL_VALUE_UNSIGNED_FIX_TRUNCATE(X) */
+ /* #define REAL_VALUE_ATOF(STRING) */
+ /* #define REAL_INFINITY */
+ /* #define REAL_VALUE_ISINF(X) */
+ /* #define REAL_VALUE_ISNAN(X) */
+ /* #define REAL_ARITHMETIC(OUTPUT, CODE, X, Y) */
+ /* #define REAL_VALUE_NEGATE(X) */
+ /* #define REAL_VALUE_TRUNCATE (@var{mode}, @var{x})
+ /* #define REAL_VALUE_TO_INT(LOW, HIGH, X) */
+ /* #define REAL_VALUE_FROM_INT(X, LOW, HIGH) */
+ 
+ 
+ /*************************************************************
+  Miscellaneous Parameters
+ *************************************************************/
+ 
+ #if 0 /* Wait for predicates to stabilize... */
+ #define PREDICATE_CODES \
+   {"local_operand", {SUBREG, MEM}},         \
+   {"ABCreg_operand", {SUBREG, REG}},        \
+   {"FABCreg_operand", {SUBREG, REG}},       \
+   {"Wreg_operand", {SUBREG, REG}},          \
+   {"word_offset_operand", {CONST_INT}},
+ #endif
+ 
+ #define CASE_VECTOR_MODE                    SImode
+ 
+ /* PC-relative case vector avoids a lot of fixup when loading the
+    program and reduces fixup table size as well.  A couple of extra
+    instructions for tablejump seems a reasonable price for this.  */
+ 
+ #define CASE_VECTOR_PC_RELATIVE
+ 
+ /* #define CASE_DROPS_THROUGH */
+ /* #define CASE_VALUES_THRESHOLD */
+ 
+ /* Define if operations between registers always perform the operation
+    on the full register even if a narrower mode is specified.  */
+ 
+ #define WORD_REGISTER_OPERATIONS
+ 
+ /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD
+    will either zero-extend or sign-extend.  The value of this macro should
+    be the code that says which one of the two operations is implicitly
+    done, NIL if none.  */
+ 
+ #define LOAD_EXTEND_OP(MODE)  ZERO_EXTEND
+ 
+ /* On T800, default mode is "round to nearest" for all commands */
+ 
+ #define IMPLICIT_FIX_EXPR  FIX_ROUND_EXPR
+ 
+ /* ?? #define FIXUNS_TRUNC_LIKE_FIX_TRUNC */
+ 
+ /* On T800, default mode is "round to nearest" for all commands */
+ 
+ #define EASY_DIV_EXPR  ROUND_DIV_EXPR
+ 
+ /* We do this with lb/sb or ld[n]l/st[n]l, ie maximum a word at a time.  */
+ 
+ #define MOVE_MAX  UNITS_PER_WORD
+ 
+ /* #define MAX_MOVE_MAX */
+ 
+ /* T800 uses shift conts "as is". Large counts make processor to
+    hang for a long time (e.g. 0x7fffffff yields hang for as long
+    as 4 min on T800/20). So, truncating user-specified count to
+    reasonable value is a good job, let compiler do it. */
+ 
+ /*-#define SHIFT_COUNT_TRUNCATED */
+ 
+ /* ??? try and see... */
+ 
+ #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)  1
+ 
+ #define STORE_FLAG_VALUE  1
+ 
+ /* #define FLOAT_STORE_FLAG_VALUE */
+ 
+ #define Pmode          SImode
+ 
+ #define FUNCTION_MODE  QImode
+ 
+ /* #define INTEGRATE_THRESHOLD(DECL) */
+ 
+ #define SCCS_DIRECTIVE
+ 
+ /* #define HANDLE_PRAGMA(STREAM) */
+ /* #define DOLLARS_IN_IDENTIFIERS */
+ /* #define NO_DOLLAR_IN_LABEL */
+ /* #define DEFAULT_MAIN_RETURN */
+ /* #define HAVE_ATEXIT */
+ /* #define EXIT_BODY */
+ /* #define INSN_SETS_ARE_DELAYED(insn) */
+ /* #define INSN_REFERENCES_ARE_DELAYED(insn) */
+ /* #define MACHINE_DEPENDENT_REORG(insn)  */
+ 
+ 
+ 
+ /*************************************************************
+  Custom additions
+ *************************************************************/
+ 
+ /* Is the reg a floating reg? */
+ /* ??? is it used ? */
+ #define FP_REGNO_P(regno)   ((regno) >= 3 && (regno) <= 5)
+ #define FP_REG_P(X)         (REG_P (X) && FP_REGNO_P (REGNO (X)))
+ 
+ /* How much bytes below Wreg are used by transputer firmware.  Note
+    that stack converter also uses 6 words below Wreg as scratch
+    locations while rotating the stack, so the should not be set lower
+    than that. */
+ #define WORKSPACE_RESERVED_BYTES  (7 * UNITS_PER_WORD)
+ 
+ /* Is the reg a stack reg? */
+ #define STACK_REG_P(X)      (REG_P (X) && REGNO(X) <= 5)
+ 
+ /* Convert size in bytes to size in words */
+ #define IN_WORDS(SIZE_IN_BYTES) \
+   (((SIZE_IN_BYTES) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+ 
+ #define WORD_ROUND(VALUE) \
+   (((VALUE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD)
+ 
+ /* Check that an operand has a floating mode; used in condition
+    of DEFINE_{INSN,EXPAND}s */
+ 
+ #define FLOAT_OPERAND(N) \
+   (GET_MODE_CLASS (GET_MODE (operands[N])) == MODE_FLOAT)
+ 
+ /* This is where cmpM pattern saves its arguments so that
+    following sCC or bCC can use them */
+ extern
+ struct t800_compare {
+   struct rtx_def *op[2];   /* comparison operands */
+   int fp;                  /* floating comparison required */
+ } t800_compare;
+ 
+ /* Point that a function's arguments should be processed (in calls.c)
+    from last to first, so that the integer regstack will be in the
+    proper order before a call insn; no stack rearrangement will be needed.
+    It is not quite right to define this macro here as it was not
+    intended for user redefinition, but this yields the desired effect. */
+ 
+ #define PUSH_ARGS_REVERSED	/* If it's last to first */
+ 
+ /* Define the order in which it is preferable to load registers onto a
+    reg-stack.  Used from reg-stack.new when reordering load atoms.  */
+ #define STACK_REG_LOAD_ORDER(CLASS) \
+   ((CLASS) == AB_REGS ?  AREG*2 + 1     :       \
+    (CLASS) == FAB_REGS ? FAREG*2 + 1    :       \
+    (CLASS)*2)
+ 
+ /* Temporary hack: tell if an insn is OK for reg-stack.new:check_rules()
+    despite its having a non-popped input and a non-earlyclobbered output.
+    Get rid of this eventually.  */
+ 
+ #define INSN_OK_FOR_RULE_3(insn) \
+    (INSN_CODE (insn) == CODE_FOR__dup           \
+     || INSN_CODE (insn) == CODE_FOR__fpdup      \
+     || INSN_CODE (insn) == CODE_FOR__fpdup + 1)
+ 
+ 
+ /* This tells local-alloc not to tie registers, as it usually does. 
+    This affects the distribution of registers: the regs that are
+    first by allocation order are used more, the regs that are last by
+    allocation order are used less. The final effect of this is that
+    when reload spills the least used hard regno, this affects less
+    pseudos, ie the spilling becomes less painful.
+ 
+    Note that this makes local-alloc harder, since more qantities are
+    generated. Also, tying is useless only for stack-like registers.  */
+ 
+ #define DONT_TIE_REGS
+ 
+ 
+ /* Enable use of free registers for reloading.  */
+ 
+ #define SMARTER_RELOAD_PASS
+ 
+ 
+ /* This means that jump insn clobbers some registers (rather unusual
+    thing for a jump to do...). This tells reg-stack convertor to use
+    an alternative technique when emitting reg-stack argeeing
+    sequences. Besides, it inhibits jump optimization after the
+    register allocation has been done. Maybe really only certain parts
+    of jump_optimize need to be skipped on such machines--consider it
+    later...  */
+ 
+ #define JUMP_CLOBBERS_REGS
+ 
+ 
+ /* Enable optional EXOTIC pass */
+ 
+ #define EXOTIC_PASS
+ 
+ 
+ /* This is called before generating rtl for every function.  */
+ 
+ #define INIT_EXPANDERS \
+   { t800_temp_slot_init ();		\
+     init_fp_specval ();			\
+     t800_init_once_completed = 1; }
+ 
+ /* This allows instruction patterns to find out whether we're doing
+    initialization (such as expr_init_once) or the actual RTL generation.  */
+ 
+ extern int t800_init_once_completed;
+ 
+ /* Tell combiner that we do not actually have some insns, in spite of the
+    presence of the code in optab.  */
+ 
+ #define ABSENT_INSN_CODE(CODE) \
+   ((CODE) == CODE_FOR_nothing   \
+    || (CODE) == CODE_FOR_cmpqi	\
+    || (CODE) == CODE_FOR_cmphi	\
+   )
+ 
+ /* This is used as a condition in binary insn patterns, like add or
+    mul, to theck that input operands are not the same register, which
+    is illegal on t800.  x and y are the input operands.
+ 
+    We allow operands to be in the same register prior to exotic to
+    leave maximum freedom to optimizers.  Exotic will fix the things up. */
+ 
+ #define T800_DISTINCT_REGS(x, y) \
+   (exotic_completed == 0 || ! reg_overlap_mentioned_p (x, y))
+ 
+ /* Generate RTX for data segment memory location to be used instead of
+    plain SYMBOL_REF.  */
+ 
+ /* ??? This is currently for testing only.  The offset is
+    intentionally weird */
+ 
+ #define T800_DATASEG_START_RTX \
+   t800_gen_local (SImode, 4444444)
+ 
+ /* In ast, symbol always stands for absolute address, regardless of
+    context.  But in dataseg-by-pointer mode we access data by adding
+    segment start address to symbol's offset from the segment start;
+    machine description arranges for data segment symbols appearing in
+    this context only.  So when we are asked to print a data segment
+    symbol, we print the expression for that symbol's offset from data
+    segment start instead. */
+ 
+ #define T800_PRINT_OPERAND_SYMREF(file, x, code) \
+   do {							\
+     if (TARGET_DATASEG_BY_POINTER			\
+ 	&& SYMBOL_REF_FLAG (x) == 1)			\
+       {							\
+ 	fputc ('(', file);				\
+ 	output_addr_const (file, x);			\
+ 	fputs ("-@@_DATA@start)", file);		\
+       }							\
+     else						\
+       output_addr_const (file, x);			\
+     if ((code) != 0 && (code) != 'w')			\
+       abort ();						\
+     if ((code) == 'w')					\
+       fprintf (file, "/%d", UNITS_PER_WORD);		\
+   } while (0)
+ 
+ /* Indicate that assembler can handle things like `adc .LL1-.LL2'. */
+ 
+ #define T800_AS_ADC_LABELDIFF_OK  1
+ 
+ /* C statements to output code for `return' pattern.  */
+ 
+ #define T800_OUTPUT_RETURN \
+   {									\
+     int totsize = IN_WORDS (get_frame_size ()) +			\
+                   IN_WORDS (current_function_outgoing_args_size);	\
+   									\
+     if (current_function_pretend_args_size)				\
+       abort ();								\
+   									\
+     if (totsize)							\
+       {									\
+         rtx xop[1] = { GEN_INT (totsize) };				\
+         output_asm_insn ("ajw +%0", xop);				\
+       }									\
+     return "ret";							\
+  }
+ 
+ /* Predicate expression which valid asm operands should conform to.
+    If this macro is not defined, general_operand is used.
+ 
+    We want something more restrictive than general_operand, because
+    otherwise we may wind up needing to reload from/to nonlocal memory,
+    and that is hard to handle.  First, we may run out of spills
+    ("fixed or forbidden register was spilled").  Second, nonlocal
+    output reloads are troublesome because store instruction pops the
+    memory address, which is likely to be required for a later insn,
+    which gets unhappy in the reg-stack pass.  */
+ 
+ #define ASM_OPERAND_PREDICATE(X, MODE) \
+   (register_operand (X, MODE) || local_operand (X, MODE))
+ 
+ #define PSEUDO_STACK_POINTER
+ 
+ 
+ 
+ 
+ /* Prototypes for functions in t800.c */
+ 
+ #ifndef PROTO
+ #if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
+ #define PROTO(ARGS) ARGS
+ #else
+ #define PROTO(ARGS) ()
+ #endif
+ #endif
+ 
+ /* `rtx' is not defined yet, because this file is processed before
+    rtl.h. Define it temporarily for use in the prototypes.  */
+ 
+ #define rtx     struct rtx_def *
+ 
+ int t800_address_cost PROTO((rtx));
+ int t800_const_cost PROTO((int));
+ 
+ /* Cannot tell about enum machine_mode in prototype for it is not
+    declared yet, and enum predefinition is forbidden.   */
+ 
+ rtx t800_gen_local ();
+ rtx t800_gen_local_address PROTO((int));
+ rtx t800_get_reloaded_address PROTO((rtx));
+ rtx force_ABCreg ();
+ 
+ #undef rtx
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/config/t800/t800.md gcc-2.7.2-t800.12/config/t800/t800.md
*** gcc-2.7.2/config/t800/t800.md	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/config/t800/t800.md	Mon Apr 28 16:31:29 1997
***************
*** 0 ****
--- 1,3710 ----
+ ;; GCC machine description for INMOS transputer family
+ ;; Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
+ ;;
+ ;; Written by Yury Shevchuk <sizif@botik.ru>
+ ;;
+ ;; This file is part of GNU CC.
+ ;;
+ ;; GNU CC is free software; you can redistribute it and/or modify
+ ;; it under the terms of the GNU General Public License as published by
+ ;; the Free Software Foundation; either version 2, or (at your option)
+ ;; any later version.
+ ;;
+ ;; GNU CC is distributed in the hope that it will be useful,
+ ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+ ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ ;; GNU General Public License for more details.
+ ;;
+ ;; You should have received a copy of the GNU General Public License
+ ;; along with GNU CC; see the file COPYING.  If not, write to
+ ;; the Free Software Foundation, 59 Temple Place - Suite 330,
+ ;; Boston, MA 02111-1307, USA.  */
+ 
+ 
+ /* This file is divided into sections that correspond to the standard
+    pattern names.  Sections are ordered along the manual (Using and
+    Porting GNU CC, "14.7 Standard Names for Patterns Used in Generation").  */
+ 
+ /* Now that this file wants to be run through CPP, we use C style
+    comments: CPP doesn't honor LISP-style comments and so gets upset
+    by unpaired ', like the one above. */
+ 
+ /* Operand classes for the register allocator:
+      'r' any register of integer reg-stack
+      'a' Areg (reg 0)
+      'b' Breg (reg 1)
+      'c' Creg (reg 2)
+      'f' any register of floating reg-stack
+      't' FAreg (reg 3)
+      'u' FBreg (reg 4)
+      'v' FCreg (reg 5)  */
+ 
+ /* Output template additional format letters are:
+      'w' convert byte offset to word offset (divide by UNITS_PER_WORD);
+      the offset is checked to be a multiple of UNITS_PER_WORD;
+ 
+      'q' result of division of the operand by UNITS_PER_WORD; this is
+      the same as 'w' except that this will not abort if given an
+      operand which is not a multiple of UNITS_PER_WORD;
+ 
+      'r' remainder from division the operand by UNITS_PER_WORD;  */
+ 
+ /* Notes:
+ 
+  * `fpu...' instructions are doubly indirect; opcode for them
+ should be pushed onto the integer reg-stack and then `fpentry'
+ command executed. This is done implicitly by assembler; however, we
+ should ensure that there is room in the reg-stack for push to be safe.
+ We achieve this by adding (clobber (match_scratch:SI "=&r")) in
+ patterns for such commands.
+ 
+ (T9000 does not need this)
+ 
+  * Using (clobber (reg ...)) should be avoided, especially when
+ this reg is also an input for the insn: an ugliest code results. Use
+ (clobber (match_scratch:SI N "=&r")) instead.  */
+ 
+ 
+ /* POPPED_INPUTS attribute shows whether the insn pops some input
+    register. Its value is the bit mask for operand numbers; e.g.
+    get_attr_popped_inputs() == 6 means that registers that are operand
+    1 and operand 2 are implicitly popped by this insn.  This is used
+    from INSN_CLOBBERS_REGNO_P macro.  */
+ 
+ (define_attr "popped_inputs" "" (const_int 0))
+ 
+ /* POPPED_INPUTS_ON_JUMP attribute shows what inputs are popped by a
+    jump insn when the jump is taken. The behaviour in the case when
+    the jump is not taken is described by POPPED_INPUTS attribute.  If
+    you do not use POPPED_INPUTS_ON_JUMP attribute at all, jump insns
+    are supposed to pop identically in either case.  */
+ 
+ (define_attr "popped_inputs_on_jump" "" (const_int 0))
+ 
+ 
+ ;;------------------------------
+ ;; movM
+ ;;------------------------------
+ 
+ /* Instructions used for SImode moves 
+ 
+  src\dest             REG     local mem    nonlocal mem
+ REG                   dup      stl          stnl
+ CONST_INT             ldc       -            -
+ SYMBOL_REF, LABEL_REF ldpi      -            -
+ local memory          ldl       -            -
+ nonlocal memory       ldnl      -            -
+ Wreg                  ldlp      -            -
+ 
+ - Loading Wreg unsupported, being within the competence of
+   prologue/epilogue only;
+ - Moving SImode to/from float-point registers unsupported;
+   HARD_REGNO_MODE_OK rejects MODE_INT for float-point registers.  */
+ 
+ 
+ (define_expand "movsi"
+   [(set (match_operand:SI 0 "general_operand" "")
+         (match_operand:SI 1 "general_operand" ""))]
+   ""
+   "{
+     /* transputers can move to memory only from a general reg */
+     if (GET_CODE (operands[0]) == MEM)
+       {
+ 	if (! ABCreg_operand (operands[1], VOIDmode))
+           operands[1] = copy_to_mode_reg (SImode, operands[1]);
+       }
+ 
+     /* In dataseg-by-pointer model, if src is a SYMBOL_REF/v
+        (i.e. referring to data segment), it needs to be added the
+        dataseg start pointer */
+ 
+     if (TARGET_DATASEG_BY_POINTER
+         && ((GET_CODE (operands[1]) == SYMBOL_REF
+              && SYMBOL_REF_FLAG (operands[1]) == 1)
+             || (GET_CODE (operands[1]) == CONST
+                 && t800_dataseg_symrefs_mentioned_p (XEXP (operands[1], 0)))))
+         {
+ 	  rtx temp;
+ 
+           /* Don't use pseudo for temp when dest is a hard register,
+              to make the generated sequence reload-safe. */
+ 
+ 	  if (reload_in_progress
+               || ((GET_CODE (operands[0]) == REG
+                    && REGNO (operands[0]) <= R_CREG)
+                   || (GET_CODE (operands[0]) == SUBREG
+                       && GET_CODE (SUBREG_REG (operands[0])) == REG
+                       && REGNO (SUBREG_REG (operands[0])) < R_CREG)))
+             temp = operands[0];
+           else
+             temp = gen_reg_rtx (Pmode);
+ 
+           emit_move_insn (temp, T800_DATASEG_START_RTX);
+ 	  operands[1] = gen_rtx (PLUS, Pmode, temp, operands[1]);
+ 	  /* to match ldnlp or adc */
+ 	}
+ 
+     /* If dst is a hard register prior to reload, we must be loading
+        register arguments before a call or return.  The compiler
+        assumes that the insns we generate for this never need
+        reloading; being unaware about what is already loaded in
+        registers, reload pass can use one of them for reloading, thus
+        breaking the loaded value.  So take care to generate
+        reload-safe insns here, sigh.  */
+ 
+     else if (!reload_in_progress && !reload_completed
+              && ((GET_CODE (operands[0]) == REG
+                   && REGNO (operands[0]) <= R_CREG)
+                  || (GET_CODE (operands[0]) == SUBREG
+                      && GET_CODE (SUBREG_REG (operands[0])) == REG
+                      && REGNO (SUBREG_REG (operands[0])) < R_CREG))
+              && nonlocal_plus_operand (operands[1], SImode))
+       {
+ 
+         /* We make sure the insn will need no reloading by copying the
+            nonlocal memory address register into a *hard* register --
+            the one we are asked to load into.  */
+ 
+ 	rtx temp = operands[0];
+ 
+ 	if (GET_CODE (temp) == SUBREG)
+           temp = alter_subreg (temp);
+ 
+         if (GET_CODE (XEXP (operands[1], 0)) == REG)
+           {
+             emit_move_insn (temp, XEXP (operands[1], 0));
+             operands[1] = gen_rtx (MEM, SImode, temp);
+           }
+         else if (GET_CODE (XEXP (operands[1], 0)) == PLUS)
+           {
+             emit_move_insn (temp, XEXP (XEXP (operands[1], 0), 0));
+             operands[1] = gen_rtx (MEM, SImode,
+                                    gen_rtx (PLUS, SImode,
+                                             temp,
+                                             XEXP (XEXP (operands[1], 0), 1)));
+           }
+         else
+           abort ();
+       }
+ 
+     /* No special care is taken for the case when either of operands
+        is a pseudo and reload is in progress (which means the pseudo
+        is actually a stack slot).  We're sure the default pattern we
+        generate will match either `ldl' or `stl', because in the moves
+        generated by reload one of the operands is always a hard register.  */
+ }")
+ 
+ 
+ (define_expand "movhi"
+   [(set (match_operand:HI 0 "general_operand" "")
+         (match_operand:HI 1 "general_operand" ""))]
+   ""
+   "if (TARGET_HAVE_SIXTEEN) {
+ 
+     /* Transputers can move to memory only from a reg */
+     if (GET_CODE (operands[0]) == MEM)
+       {
+         if (! reg_p (operands[1]))
+           {
+             rtx temp = gen_reg_rtx (HImode);
+             emit_move_insn (temp, operands[1]);
+             operands[1] = temp;
+           }
+ 
+         /* Now source is a HImode REG, dest is a HImode MEM.
+            This will match `ss', but ensure that destination
+            MEM address is an ABCreg.  */
+         if (! ABCreg_operand (XEXP (operands[0], 0), SImode))
+           operands[0] = gen_rtx (MEM, HImode,
+                                  copy_addr_to_reg (XEXP (operands[0], 0)));
+       }
+     else
+       {
+         /* Destination is a REG. All loading insns yield a SImode
+            value, so change dest to SImode.  */
+ 
+         operands[0] = gen_lowpart (SImode, operands[0]);
+ 
+         if (GET_CODE (operands[1]) == MEM)
+           {
+             rtx addr = XEXP (operands[1], 0);
+ 
+             /* If we are loading a local half-word aligned on a word
+                boundary, we may use `ldl' instead of `ls'.  */
+ 
+             if (local_operand_address (addr, SImode))
+               operands[1] = change_address (operands[1], SImode, addr);
+             else
+               /* Otherwise, arrange to match `ls'.  */
+               {
+                 if (! ABCreg_operand (addr, Pmode))
+                   {
+                     rtx temp = reload_in_progress? operands[0]
+                                                  : gen_reg_rtx (Pmode);
+                     emit_move_insn (temp, addr);
+                     operands[1] = change_address (operands[1], VOIDmode, temp);
+                   }
+                 operands[1] = gen_rtx (ZERO_EXTEND, SImode, operands[1]);
+               }
+           }
+         else
+           {
+             /* Src is CONST_INT or REG; just change src to SImode, and
+                word insns will match */
+             operands[1] = gen_lowpart (SImode, operands[1]);
+             /* to match `ldc' or `dup' */
+           }
+ 
+         /* Failed pseudos during reload end up with
+              (set (reg:SI hard) (subreg:SI (reg:HI pseudo))),
+            which matches `ldl', or with
+              (set (subreg:SI (reg:HI pseudo)) (reg:SI hard)),
+            which matches `stl'.  */
+       }
+    }
+    else {
+     if (GET_CODE (operands[0]) == MEM)
+       {
+         rtx addr = XEXP (operands[0], 0);
+         rtx addr2, store_byte, addr_plus_one;
+ 
+ 	/* Storing HImode.  On transputers without 16-bit support, we
+ 	   have to do this by shifts and byte stores. */
+ 
+         /* Examine src first.  If it is CONST_INT, we can shift it in
+            compile time; otherwise, we force it to register and generate
+            runtime shift later.  */
+ 
+         if (GET_CODE (operands[1]) != CONST_INT
+        	    && ! ABCreg_operand (operands[1], HImode))
+           operands[1] = copy_to_reg (operands[1]);
+ 
+ 	/* Get the address of destination MEM into ABCreg, if it is
+            not in one.  We don't try to keep symbol_ref addresses to
+            compute address of the second byte in compile time, because
+            loading symbol_ref is more expensive than run-time constant
+            addition.  */
+ 
+         if ( ! ABCreg_operand (addr, Pmode))
+           addr = copy_to_reg (addr);
+ 
+         /* Make a copy of the address in yet another pseudo for use in
+            second `sb'; the first one will be popped by the first `sb' */
+ 
+         addr2 = copy_to_reg (addr);
+ 
+         /* Get src into a reg now.  We don't attempt to make a copy of
+           it like we did for the dest address, because there's no enough
+           room on integer reg-stack so it would go to stack slot
+           anyway. */
+ 
+         if (GET_CODE (operands[1]) == CONST_INT)
+           {
+             /* We mask the constant to make it cheaper. */
+             int val = INTVAL (operands[1]) & 0xff;
+             store_byte = copy_to_mode_reg (QImode, GEN_INT (val));
+           }
+         else
+           store_byte = gen_lowpart (QImode, operands[1]);
+ 
+         /* Emit the first `sb' */
+ 
+         emit_move_insn (change_address (operands[0], QImode, addr2),
+                         store_byte);
+ 
+         /* Prepare the value for second `sb' by shifting the original
+            src right by 8 bits. */
+ 
+         if (GET_CODE (operands[1]) == CONST_INT)
+           {
+             /* We mask the constant to make it cheaper. */
+             int val = (INTVAL (operands[1]) >> 8) & 0xff;
+             store_byte = copy_to_mode_reg (QImode, GEN_INT (val));
+           }
+         else
+           {
+             rtx temp = gen_reg_rtx (SImode);
+             emit_insn (gen_lshrsi3 (temp,
+                                     gen_lowpart (SImode, operands[1]),
+                                     copy_to_mode_reg (SImode, GEN_INT (8))));
+             store_byte = gen_lowpart (QImode, temp);
+           }
+ 
+         /* Prepare address for 2nd `sb' by incrementing address by 1 */
+       
+         addr_plus_one = gen_reg_rtx (SImode);
+         emit_insn (gen__adc (addr_plus_one, addr, GEN_INT (1)));
+ 
+         /* Emit the 2nd `sb' */
+ 
+         emit_move_insn (change_address (operands[0], QImode, addr_plus_one),
+                         store_byte);
+         DONE;
+       }
+     else
+       {
+         /* Destination is a REG. All loading insns yield a SImode
+            value, so make it into SImode subreg */
+ 
+         operands[0] = gen_lowpart (SImode, operands[0]);
+ 
+         if (GET_CODE (operands[1]) == MEM)
+           {
+             rtx addr = XEXP (operands[1], 0);
+ 
+             /* If we are loading a local halfword aligned on the word
+                boundary, we may use `ldl'.  */
+ 
+             if (local_operand_address (addr, SImode))
+               {
+                 operands[1] = change_address (operands[1], SImode, addr);
+                 /* to match `ldl' */
+               }
+ 
+             /* If we are loading a halfword addressed by symbol_ref,
+                we can go with word load (ldnl) as well, because we
+                assume symbol_refs to be word-aligned.
+ 
+                ??? should accept word-aligned CONSTs, too, but it
+                requires a predicate to distingwish them from unaligned
+                CONSTs.  */
+ 
+             else if (GET_CODE (addr) == SYMBOL_REF)
+               {
+                 operands[1] = change_address (operands[1], SImode,
+                                               copy_to_reg (addr));
+                 /* to match `ldnl' */
+               }
+ 
+             /* Otherwise, do the load in two `lb's */
+ 
+             else
+               {
+                 rtx byte1 = gen_reg_rtx (SImode);
+                 rtx byte2 = gen_reg_rtx (SImode);
+                 rtx temp  = gen_reg_rtx (SImode);
+                 rtx addr_plus_one;
+                 rtx addr2;
+ 
+ 		/* Get the address of destination MEM into ABCreg, if
+                    it is not in one.  We don't try to keep symbol_ref
+                    addresses to compute address of the second byte in
+                    compile time, because loading symbol_ref is more
+                    expensive than run-time constant addition.  */
+ 
+ 		if ( ! ABCreg_operand (addr, Pmode))
+ 		  addr = copy_to_reg (addr);
+ 
+ 		/* Make a copy of the address in yet another pseudo
+                    for use in second `lb'; the first one will be
+                    popped by the first `lb' */
+ 
+ 		addr2 = copy_to_reg (addr);
+ 
+ 		emit_insn (gen__lb (byte1,
+                   change_address (operands[1], QImode, addr2)));
+                 addr_plus_one = gen_reg_rtx (SImode);
+ 		emit_insn (gen__adc (addr_plus_one, addr, GEN_INT (1)));
+                 emit_insn (gen__lb (byte2,
+                   change_address (operands[1], QImode, addr_plus_one)));
+                 emit_insn (gen_ashlsi3 (temp, byte2,
+                   copy_to_mode_reg (SImode, GEN_INT (8))));
+                 emit_insn (gen_iorsi3 (gen_lowpart (SImode, operands[0]),
+                                        temp, byte1));
+ 		DONE;
+               }
+           }
+         else
+           {
+             /* Src is CONST_INT or REG; just change src to SImode, and
+                word insns will match */
+             operands[1] = gen_lowpart (SImode, operands[1]);
+             /* to match `ldc' or `dup' */
+           }
+ 
+         /* Failed pseudos during reload end up with
+              (set (reg:SI hard) (subreg:SI (reg:HI pseudo))),
+            which matches `ldl', or with
+              (set (subreg:SI (reg:HI pseudo)) (reg:SI hard)),
+            which matches `stl'.  */
+       }
+   }
+ ")
+ 
+ 
+ /* Instructions used for QImode moves
+ 
+                       REG              local mem    nonlocal mem
+ REG                   dup    (SI>SI)     sb (QI>QI)   sb (QI>QI)
+ CONST_INT             ldc    (VOID>SI)   -            -
+ SYMBOL_REF, LABEL_REF ldpi   (SI>SI)     -            -
+ local memory          lb/ldl (QI/SI>SI)  -            -
+ nonlocal memory       lb     (QI>SI)     -            -
+ 
+ */
+ 
+ (define_expand "movqi"
+   [(set (match_operand:QI 0 "general_operand" "")
+         (match_operand:QI 1 "general_operand" ""))]
+   ""
+   "{
+     /* transputers can move to memory only from a reg */
+     if (GET_CODE (operands[0]) == MEM)
+       {
+         if (! reg_p (operands[1]))
+           {
+             rtx temp = gen_reg_rtx (QImode);
+             emit_move_insn (temp, operands[1]);
+             operands[1] = temp;
+           }
+ 
+         /* Now source is a QImode REG, dest is a QImode MEM.
+            This will match `sb', but ensure that destination
+            MEM address is an ABCreg.  */
+         if (! ABCreg_operand (XEXP (operands[0], 0), SImode))
+           operands[0] = gen_rtx (MEM, QImode,
+                                  copy_addr_to_reg (XEXP (operands[0], 0)));
+       }
+     else
+       {
+         /* Destination is a REG. All loading insns yield a SImode
+            value, so change dest to SImode.  */
+ 
+         operands[0] = gen_lowpart (SImode, operands[0]);
+ 
+         if (GET_CODE (operands[1]) == MEM)
+           {
+             rtx addr = XEXP (operands[1], 0);
+ 
+             /* If we are loading a local byte aligned on a word
+                boundary, we may use `ldl' instead of `lb'.  */
+             if (local_operand_address (addr, Pmode))
+               operands[1] = change_address (operands[1], SImode, addr);
+             else
+               /* Otherwise, arrange to match `lb'.  */
+               {
+                 if (! ABCreg_operand (addr, Pmode))
+                   {
+                     rtx temp = reload_in_progress? operands[0]
+                                                  : gen_reg_rtx (Pmode);
+                     emit_move_insn (temp, addr);
+                     operands[1] = change_address (operands[1], VOIDmode, temp);
+                   }
+                 operands[1] = gen_rtx (ZERO_EXTEND, SImode, operands[1]);
+               }
+           }
+         else
+           {
+             /* Src is CONST_INT or REG; just change src to SImode, and
+                word insns will match */
+             operands[1] = gen_lowpart (SImode, operands[1]);
+             /* to match `ldc' or `dup' */
+           }
+ 
+         /* Failed pseudos during reload end up with
+              (set (reg:SI hard) (subreg:SI (reg:QI pseudo))),
+            which matches `ldl', or with
+              (set (subreg:SI (reg:QI pseudo)) (reg:SI hard)),
+            which matches `stl'.  */
+       }
+ }")
+ 
+ 
+ /* Instructions for FP moves
+ 
+  src\dest             REG              nonlocal mem
+ REG                   fpdup             fpstnl{sn,db}
+ CONST_DOUBLE (== 0)   fpldzero{sn,db}   -
+ nonlocal memory       fpldnl{sn,db}[i]  -     */
+ 
+ (define_expand "movsf"
+   [(set (match_operand:SF 0 "general_operand" "")
+         (match_operand:SF 1 "general_operand" ""))]
+   ""
+   "{
+     rtx t800_temp_slot (enum machine_mode);
+     rtx t800_force_nonlocal (rtx);
+ 
+     switch (t800_fp_reg_p (operands[0]) | t800_fp_reg_p (operands[1]) << 1)
+       {
+       case 0:
+ 
+         /* Neither operand is an fp register. Do the move with SImode
+            insn(s) */
+ 
+         emit_move_insn (operand_subword (operands[0], 0, 1, SFmode),
+                         operand_subword (operands[1], 0, 1, SFmode));
+         DONE;
+ 
+       case 1:
+ 
+         /* dest is an fp register, src is not.  See if src is an
+            integer register: there is no insn to do such move
+            directly, so use a temporary stack slot.  */
+ 
+         if (REG_P (operands[1]))
+           {
+             rtx temp = t800_temp_slot (SFmode);
+ 
+             emit_move_insn (temp, operands[1]);
+             operands[1] = temp;
+           }
+ 	
+         /* if src is a MEM, make sure it is a valid nonlocal MEM
+            (i.e. address in a general reg) */
+ 
+ 	if (GET_CODE (operands[1]) == MEM)
+           operands[1] = t800_force_nonlocal (operands[1]);
+ 
+         break;
+ 
+       case 2:
+ 
+         /* src is an fp register, dest is not.  Likewise...  */
+         
+         if (REG_P (operands[0]))
+           {
+ 	    emit_insn (gen_sf_to_ABCreg (operands[0], operands[1],
+                                          t800_temp_slot (SFmode)));
+             DONE;
+           }
+ 	else if (GET_CODE (operands[0]) == MEM)
+           operands[0] = t800_force_nonlocal (operands[0]);
+         break;
+ 
+       case 3:
+ 
+         /* both src and dst are fp registers.  Default pattern will do... */
+ 
+         break;
+       }
+ 
+     /* Now it should be OK with the default pattern. */
+ }")
+ 
+ (define_expand "movdf"
+   [(set (match_operand:DF 0 "general_operand" "")
+         (match_operand:DF 1 "general_operand" ""))]
+   ""
+   "{
+     rtx t800_temp_slot (enum machine_mode);
+     rtx t800_force_nonlocal (rtx);
+ 
+     switch (t800_fp_reg_p (operands[0]) | t800_fp_reg_p (operands[1]) << 1)
+       {
+       case 0:
+ 
+         /* Neither operand is an fp register. Do the move with SImode
+            insn(s) */
+ 
+         emit_move_insn (operand_subword (operands[0], 0, 1, DFmode),
+                         operand_subword (operands[1], 0, 1, DFmode));
+         emit_move_insn (operand_subword (operands[0], 1, 1, DFmode),
+                         operand_subword (operands[1], 1, 1, DFmode));
+         DONE;
+ 
+       case 1:
+ 
+         /* dest is an fp register, src is not.  See if src is an
+            integer register: there is no insn to do such move
+            directly, so use a temporary stack slot.  */
+ 
+         if (REG_P (operands[1]))
+           {
+             rtx temp = t800_temp_slot (DFmode);
+ 
+             emit_move_insn (temp, operands[1]);
+             operands[1] = temp;
+           }
+ 	
+         /* if src is a MEM, make sure it is a valid nonlocal MEM
+            (i.e. address in a general reg) */
+ 
+ 	if (GET_CODE (operands[1]) == MEM)
+           {
+             operands[1] = t800_force_nonlocal (operands[1]);
+           }
+         break;
+ 
+       case 2:
+ 
+         /* src is an fp register, dest is not. */
+         
+         if (REG_P (operands[0]))
+           {
+ 	    emit_insn (gen_df_to_ABCreg (operands[0], operands[1],
+                                          t800_temp_slot (DFmode)));
+             DONE;
+           }
+ 	else if (GET_CODE (operands[0]) == MEM)
+           {
+             operands[0] = t800_force_nonlocal (operands[0]);
+           }
+         break;
+       }
+ 
+     /* Now it should be OK with the default pattern. */
+ }")
+ 
+ 
+ 
+ 
+ /* ldc */
+ 
+ /* {symbol,label}_ref's are not loaded by this, since it would yield
+    utterly position-dependent code with a lot of load-time patches.
+ 
+    ??? rewrite to make more use from mint */
+ 
+ (define_insn "_ldc"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (match_operand 1 "const_int_operand" ""))]
+   ""
+   "*return INTVAL (operands[1]) == 0x80000000
+       ? \"mint\"
+       : \"ldc %1\";")
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (match_operand 1 "const_offset_operand" ""))]
+   ""
+   "ldc %1")
+ 
+ /* The following two patterns are never generated by anything in
+    mov_optab, but they can occasionally pop up as a result of fixing
+    rtl after putting a variable into stack (fixup_var_refs_1()).  It
+    seems better to kludge aroung the problem here than to hack
+    function.c with risk to disturb other machines.
+ 
+    (The problem exposes on enquire.c when compiling with -O). */
+ 
+ (define_insn ""
+   [(set (match_operand:HI 0 "ABCreg_operand" "=a")
+         (match_operand 1 "const_int_operand" ""))]
+   ""
+   "ldc %1")
+ 
+ (define_insn ""
+   [(set (match_operand:QI 0 "ABCreg_operand" "=a")
+         (match_operand 1 "const_int_operand" ""))]
+   ""
+   "ldc %1")
+ 
+ 
+ /* ldpi */
+ 
+ (define_insn "_ldpi"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (match_operand:SI 1 "ldpi_operand" ""))]
+   ""
+   "*{
+ #ifdef T800_LDC_SYMBOL_PC_RELATIVE
+   return \"ldc %1-2\;ldpi\";
+ #else
+   return \"ldc %1-LF%=\;ldpi\\nLF%=:\";
+ #endif
+ }")
+ 
+ (define_insn "_ldpi2"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (plus:SI (match_operand:SI 1 "ABCreg_operand" "0")
+                  (match_operand:SI 2 "ldpi_operand" "")))]
+   "T800_AS_ADC_LABELDIFF_OK"
+   "adc %2-LF%=\;ldpi\\nLF%=:")
+ 
+ 
+ /* `ldl' and `stl' should come ahead of `dup'; otherwise a move
+    between a pseudo and hard reg when reload_in_progress could match
+    `dup' because ABCreg_operand accepts pseudos even then.  */
+ 
+ /* ldl */
+ 
+ (define_insn "_ldl"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (match_operand:SI 1 "local_operand" ""))]
+   ""
+   "ldl %w1")
+ 
+ 
+ /* stl */
+ 
+ (define_insn "_stl"
+   [(set (match_operand:SI 0 "local_operand" "")
+         (match_operand:SI 1 "ABCreg_operand" "a"))]
+   ""
+   "stl %w0"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ 
+ /* dup */
+ 
+ /* This matches any inter-general-reg move.
+ 
+   ??? `&' constraint for operand 0 is currently required by reg-stack2.c
+   to present for any output if the insn has non-popped inputs. (*** &)
+ 
+   Now, _dup is allowed to have no earlyclobber by INSN_OK_FOR_RULE_3.
+   It is actually safe, since the case when the input and output are the same
+   register, having a potential of a reg-stack overflow for other insns,
+   is just a no-op move here that is removed at all in reg-stack2.c.  */
+ 
+ (define_insn "_dup"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (match_operand:SI 1 "ABCreg_operand" "a"))]
+   ""
+   "dup")
+ 
+ (define_insn "_rev"
+   [(set (match_operand:SI 0 "ABCreg_operand" "+a")
+         (match_operand:SI 1 "ABCreg_operand" "+b"))
+    (set (match_dup 1)
+         (match_dup 0))]
+   ""
+   "rev")
+ 
+ /* This insn is only generated by the reg-stack converter. */
+ 
+ (define_insn "_pop"
+   [(unspec [(match_operand:SI 0 "ABCreg_operand" "a")] 0)]
+   "TARGET_HAVE_POP"
+   "pop"
+   [(set (attr "popped_inputs") (const_int 1))])
+ 
+ /* Unlike the hardware ldlp, this pattern takes an arbitrary offset
+    and handles it with an additional adc, if needed.  */
+ 
+ (define_insn "_ldlp"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a,a")
+ 	(plus:SI (match_operand:SI 2 "Wreg_operand" "")
+                  (match_operand:SI 1 "const_int_operand" "I,?n")))]
+   ""
+   "@
+    ldlp %q1
+    ldlp %q1\;adc %r1")
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (match_operand:SI 1 "Wreg_operand" ""))]
+   ""
+   "ldlp 0")
+ 
+ /* `ajw' should come ahead of `adc'. */
+ 
+ (define_insn "_ajw"
+   [(set (match_operand:SI 0 "Wreg_operand" "")
+         (match_operand:SI 1 "local_operand_address" ""))]
+   ""
+   "ajw %w1")
+ 
+ (define_insn "_gajw"
+   [(set (match_operand:SI 0 "Wreg_operand" "")
+         (match_operand:SI 1 "ABCreg_operand" "a"))
+    (set (match_dup 1)
+         (match_dup 0))]
+   ""
+   "gajw")
+ 
+ (define_insn "_ldnl"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (match_operand:SI 1 "nonlocal_plus_operand" "U"))]
+   ""
+   "ldnl %w1"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_insn "_stnl"
+   [(set (match_operand:SI 0 "nonlocal_plus_operand" "=U")
+         (match_operand:SI 1 "ABCreg_operand" "b"))]
+   ""
+   "stnl %w0"
+   [(set (attr "popped_inputs") (const_int 3))])
+ 
+ (define_insn "_ldnlp"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (plus:SI (match_operand:SI 1 "ABCreg_operand" "0")
+                  (match_operand:SI 2 "word_offset_operand" "")))]
+   ""
+   "ldnlp %w2")
+ 
+ /* ldnlp 0 is a no-op -- omitted */
+ 
+ 
+ (define_insn "_ls"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (zero_extend:SI (match_operand:HI 1 "nonlocal_operand" "R")))]
+   "TARGET_HAVE_SIXTEEN"
+   "ls"
+   [(set (attr "popped_inputs") (const_int 2))])                       
+ 
+ (define_insn "_ss"
+   [(set (match_operand:HI 0 "nonlocal_operand" "=R")
+         (match_operand:HI 1 "ABCreg_operand" "b"))]
+   "TARGET_HAVE_SIXTEEN"
+   "ss"
+   [(set (attr "popped_inputs") (const_int 3))])
+ 
+ 
+ (define_insn "_lb"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (zero_extend:SI (match_operand:QI 1 "nonlocal_operand" "R")))]
+   ""
+   "lb"
+   [(set (attr "popped_inputs") (const_int 2))])                       
+ 
+ (define_insn "_sb"
+   [(set (match_operand:QI 0 "nonlocal_operand" "=R")
+         (match_operand:QI 1 "ABCreg_operand" "b"))]
+   ""
+   "sb"
+   [(set (attr "popped_inputs") (const_int 3))])
+ 
+ 
+ /* This strange pattern plays an important part of making it clear to
+    expr.c that we CAN load a value from memory in QImode. We support
+    QImode loads with (define_expand "movqi"), but the insn that
+    actually does the loading (`lb') yields a SImode value, so that
+    init_expr_once() fails to detect it.
+ 
+    Without it we got restricted to SImode loads, which leads to extra
+    pseudos and worse code.
+ 
+    We prevent this pattern from matching ever except in the test
+    mentioned by using `t800_init_once_completed' in the condition.  */
+ 
+ (define_insn ""
+   [(set (reg:QI 0) (mem:QI (reg:SI 6)))]
+   "! t800_init_once_completed"
+   "*abort ();")
+ 
+ 
+ 
+ (define_insn "_fpdup"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (match_operand:SF 1 "FABCreg_operand" "t"))]
+   "TARGET_HAVE_FPU"
+   "fpdup")
+ 
+ (define_insn ""
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (match_operand:DF 1 "FABCreg_operand" "t"))]
+   "TARGET_HAVE_FPU"
+   "fpdup")
+ 
+ (define_insn "_fprev"
+   [(set (match_operand:SF 0 "FABCreg_operand" "+t")
+         (match_operand:SF 1 "FABCreg_operand" "+u"))
+    (set (match_dup 1)
+         (match_dup 0))]
+   "TARGET_HAVE_FPU"
+   "fprev")
+ 
+ (define_insn ""
+   [(set (match_operand:DF 0 "FABCreg_operand" "+t")
+         (match_operand:DF 1 "FABCreg_operand" "+u"))
+    (set (match_dup 1)
+         (match_dup 0))]
+   "TARGET_HAVE_FPU"
+   "fprev")
+ 
+ 
+ (define_insn "_fpldzerosn"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (match_operand:SF 1 "zero_operand" ""))]
+   "TARGET_HAVE_FPU"
+   "fpldzerosn")
+ 
+ (define_insn "_fpldzerodb"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (match_operand:DF 1 "zero_operand" ""))]
+   "TARGET_HAVE_FPU"
+   "fpldzerodb")
+ 
+ 
+ (define_insn "_fpldnlsn"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (match_operand:SF 1 "nonlocal_operand" "R"))]
+   "TARGET_HAVE_FPU"
+   "fpldnlsn"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_insn "_fpldnldb"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (match_operand:DF 1 "nonlocal_operand" "R"))]
+   "TARGET_HAVE_FPU"
+   "fpldnldb"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ 
+ (define_insn "_fpldnlsni"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (mem:SF (plus:SI (mult:SI (match_operand:SI 1 "ABCreg_operand" "b")
+                                   (const_int 4))
+                          (match_operand:SI 2 "ABCreg_operand" "a"))))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpldnlsni"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_insn "_fpldnldbi"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (mem:DF (plus:SI (mult:SI (match_operand:SI 1 "ABCreg_operand" "b")
+                                   (const_int 8))
+                          (match_operand:SI 2 "ABCreg_operand" "a"))))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpldnldbi"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ (define_insn "_fpstnlsn"
+   [(set (match_operand:SF 0 "nonlocal_operand" "=R")
+         (match_operand:SF 1 "FABCreg_operand" "t"))]
+   "TARGET_HAVE_FPU"
+   "fpstnlsn"
+   [(set (attr "popped_inputs") (const_int 3))])
+ 
+ (define_insn "_fpstnldb"
+   [(set (match_operand:DF 0 "nonlocal_operand" "=R")
+         (match_operand:DF 1 "FABCreg_operand" "t"))]
+   "TARGET_HAVE_FPU"
+   "fpstnldb"
+   [(set (attr "popped_inputs") (const_int 3))])
+ 
+ 
+ ; Move from floating to integer register.  We have this redundant
+ ; pattern for such moves, as it lets us to avoid reloading for such
+ ; moves -- important because reloading is harmful in register function
+ ; arguments preloading sequence.
+ ;
+ (define_insn "sf_to_ABCreg"
+   [(set (match_operand:SF 0 "ABCreg_operand" "=a,a,a")
+         (match_operand:SF 1 "FABCreg_operand" "t,m,a"))
+    (use (match_operand:SF 2 "local_operand" ""))]
+   "TARGET_HAVE_FPU"
+   "@
+    ldlp %w2\;fpstnlsn\;ldl %w2
+    ldl %w1
+    OOPS -- this insn should have been deleted in reg-stack pass"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_insn "df_to_ABCreg"
+   [(set (match_operand:DF 0 "ABCreg_operand" "=a,a,a")
+         (match_operand:DF 1 "FABCreg_operand" "t,m,a"))
+    (use (match_operand:DF 2 "local_operand" ""))]
+   "TARGET_HAVE_FPU"
+   "@
+    ldlp %w2\;fpstnldb\;ldl %w2+1\;ldl %w2
+    ldl %w1+1\;ldl %w1
+    OOPS -- this insn should have been deleted in reg-stack pass"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ 
+ ;;------------------------------
+ ;; reload_inM
+ ;; reload_outM
+ ;;------------------------------
+ 
+ /* We have to use secondary reloads when we are asked to reload a
+    failed pseudo to/from an FP stack register, or from an integer
+    reg-stack register in QImode.  These operations (fpldnlsn,
+    fpldnldb, fpstnlsn, fpldnldb, sb) require a general register for
+    memory address to reload to/from.  Input reloads in QImode are
+    implemented with SImode load instruction (ldl) and therefore do not
+    need an additional register.  Moreover, QImode pseudos get
+    word-wide stack slot allocated, so we can always do QImode reloads
+    with SImode insns which don't need scratch registers. */
+ 
+ ;/* Sometimes, very rarely, we may need to do output reload from a
+ ;   general register and into nonlocal memory.  The problem is that
+ ;   default handling of this case in gen_reload() doesn't account for
+ ;   the fact that stnl pops its address argument off the regstack, and
+ ;   so a later insn that needs this address causes abort in reg-stack
+ ;   converter.  So we define reload_outM to be able to copy the address
+ ;   before stnl.
+ ;
+ ;   ??? Handling this for HImode is processor dependent and so pushed
+ ;   aside for now.  */
+ ;
+ ;(define_expand "reload_outqi"
+ ;  [(set (match_operand:QI 0 "nonlocal_operand" "=m")
+ ;        (match_operand:QI 1 "ABCreg_operand" "r"))
+ ;   (clobber (match_operand:SI 2 "" "=&r"))]
+ ;  ""
+ ;  "{
+ ;    /* dup memory address to the scratch reg */
+ ;    emit_insn (gen_rtx (SET, VOIDmode, operands[2], XEXP (operands[0],0)));
+ ;    emit_insn (gen__sb (gen_rtx (MEM, QImode, operands[2]), operands[1]));
+ ;    DONE;
+ ;}")
+ ;
+ ;(define_expand "reload_outsi"
+ ;  [(set (match_operand:SI 0 "nonlocal_operand" "=m")
+ ;        (match_operand:SI 1 "ABCreg_operand" "r"))
+ ;   (clobber (match_operand:SI 2 "" "=&r"))]
+ ;  ""
+ ;  "{
+ ;    /* dup memory address to the scratch reg */
+ ;    emit_insn (gen_rtx (SET, VOIDmode, operands[2], XEXP (operands[0],0)));
+ ;    emit_insn (gen__stnl (gen_rtx (MEM, SImode, operands[2]), operands[1]));
+ ;    DONE;
+ ;}")
+ 
+ 
+ /* operand1 can be a stack slot
+      (mem (Wreg)) or (mem (plus Wreg const_int))
+    or memory constant
+      (mem (symbol_ref))
+    or even ABCreg
+ 
+    We don't have a predicate handy to recognize all -- and probably we
+    can do without a predicate, as we always want those patterns to be
+    used when SECONDARY_RELOAD_CLASS says we need a secondary register.
+    Same for reload_indf.  */
+ 
+ (define_expand "reload_insf"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=f")
+         (match_operand:SF 1 "" "m"))
+    (clobber (match_operand:SI 2 "" "=&r"))]
+   "TARGET_HAVE_FPU"
+   "{
+     rtx base;
+ 
+     /* If src is an ABCreg, we cannot move directly, so go
+        through an intermediate stack slot. */
+ 
+     if (t800_ABCreg_p (operands[1]))
+       {
+         rtx t800_temp_slot (enum machine_mode);
+         rtx temp = t800_temp_slot (SFmode);
+         emit_move_insn (temp, operands[1]);
+         base = XEXP (temp, 0);
+       }
+     else
+       {
+         base = t800_get_reloaded_address (operands[1]);
+       }
+     emit_insn (gen_rtx (SET, VOIDmode, operands[2], base));
+     emit_insn (gen__fpldnlsn (operands[0], gen_rtx (MEM, SFmode, operands[2])));
+     DONE;
+ }")
+ 
+ (define_expand "reload_outsf"
+   [(set (match_operand:SF 0 "" "=m")
+         (match_operand:SF 1 "FABCreg_operand" "f"))
+    (clobber (match_operand:SI 2 "" "=&r"))]
+   "TARGET_HAVE_FPU"
+   "{
+     rtx temp = 0;
+     rtx base;
+ 
+     /* If dst is an ABCreg, we cannot move directly, so go through an
+        intermediate stack slot.  We cannot use ABCreg_operand here, because it accepts pseudos*/
+ 
+     if (t800_ABCreg_p (operands[0], SFmode))
+       {
+         rtx t800_temp_slot (enum machine_mode);
+         temp = t800_temp_slot (SFmode);
+         base = XEXP (temp, 0);
+       }
+     else
+       {
+         base = t800_get_reloaded_address (operands[0]);
+       }
+ 
+     emit_insn (gen_rtx (SET, VOIDmode, operands[2], base));
+     emit_insn (gen__fpstnlsn (gen_rtx (MEM, SFmode, operands[2]), operands[1]));
+ 
+     if (temp != 0)
+       emit_move_insn (operands[0], temp);
+ 
+     DONE;
+ }")
+ 
+ (define_expand "reload_indf"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=f")
+         (match_operand:DF 1 "" "m"))
+    (clobber (match_operand:SI 2 "" "=&r"))]
+   "TARGET_HAVE_FPU"
+   "{
+     rtx base;
+ 
+     /* If src is an ABCreg, we cannot move directly, so go
+        through an intermediate stack slot. */
+ 
+     if (t800_ABCreg_p (operands[1], DFmode))
+       {
+         rtx t800_temp_slot (enum machine_mode);
+         rtx temp = t800_temp_slot (DFmode);
+         emit_move_insn (temp, operands[1]);
+         base = XEXP (temp, 0);
+       }
+     else
+       {
+         base = t800_get_reloaded_address (operands[1]);
+       }
+     emit_insn (gen_rtx (SET, VOIDmode, operands[2], base));
+     emit_insn (gen__fpldnldb (operands[0], gen_rtx (MEM, DFmode, operands[2])));
+     DONE;
+ }")
+ 
+ (define_expand "reload_outdf"
+   [(set (match_operand:DF 0 "" "=m")
+         (match_operand:DF 1 "FABCreg_operand" "f"))
+    (clobber (match_operand:SI 2 "" "=&r"))]
+   "TARGET_HAVE_FPU"
+   "{
+     rtx temp = 0;
+     rtx base;
+ 
+     /* If dst is an ABCreg, we cannot move directly, so go
+        through an intermediate stack slot. */
+ 
+     if (t800_ABCreg_p (operands[0], DFmode))
+       {
+         rtx t800_temp_slot (enum machine_mode);
+         temp = t800_temp_slot (DFmode);
+         base = XEXP (temp, 0);
+       }
+     else
+       {
+         base = t800_get_reloaded_address (operands[0]);
+       }
+ 
+     emit_insn (gen_rtx (SET, VOIDmode, operands[2], base));
+     emit_insn (gen__fpstnldb (gen_rtx (MEM, DFmode, operands[2]), operands[1]));
+ 
+     if (temp != 0)
+       emit_move_insn (operands[0], temp);
+ 
+     DONE;
+ }")
+ 
+ 
+ ;;------------------------------
+ ;; movstrictM
+ ;;------------------------------
+ ;; N/A
+ 
+ 
+ ;;------------------------------
+ ;; addM3
+ ;;------------------------------
+ 
+ (define_expand "addsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (plus:SI (match_operand:SI 1 "general_operand" "")
+                  (match_operand:SI 2 "general_operand" "")))]
+   ""
+   "
+ 	/* In dataseg-by-pointer model, if src is a SYMBOL_REF/v
+ 	   (i.e. referring to data segment), it needs to be added the
+ 	   dataseg start pointer first. */
+ 
+ 	if (TARGET_DATASEG_BY_POINTER
+             && ((GET_CODE (operands[2]) == SYMBOL_REF
+                  && SYMBOL_REF_FLAG (operands[2]) == 1)
+                 || (GET_CODE (operands[2]) == CONST
+                     && t800_dataseg_symrefs_mentioned_p (XEXP (operands[2], 0)))))
+           {
+ 	    rtx temp = gen_reg_rtx (Pmode);
+ 	    rtx temp2 = gen_reg_rtx (Pmode);
+ 
+ 	    emit_move_insn (temp, T800_DATASEG_START_RTX);
+ 	    emit_insn (gen_rtx (SET, VOIDmode, temp2,
+ 	                        gen_rtx (PLUS, Pmode, temp, operands[2])));
+ 	       /* will match ldnlp or adc */
+             operands[2] = temp2;
+           }
+ 
+ 	if (GET_CODE (operands[2]) == CONST_INT)
+           {
+             /* This is going to be either adc or ldlp; operands[1] should
+                be ABCreg or Wreg respectively.
+ 
+                _ldlp pattern accepts arbitrary constants (not
+                word_offset only), so we can play simple here.  */
+ 
+             operands[1] = force_reg (SImode, operands[1]);
+           }
+         else
+           {
+             operands[1] = force_ABCreg (SImode, operands[1]);
+ 	    if (HAVE__ldpi2 && ldpi_operand (operands[2], SImode))
+               ;  /* ldpi2 */
+             else if (word_offset_operand (operands[2], SImode))
+               ;  /* ldnlp */
+             else
+               operands[2] = force_ABCreg (SImode, operands[2]);
+           }
+ ")
+ /* to match _adc/_ldlp/ldnlp/_ldpi2/_add */
+ 
+ 
+ (define_insn "_adc"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (plus:SI (match_operand:SI 1 "ABCreg_operand" "0")
+                  (match_operand:SI 2 "adc_operand" "")))]
+   ""
+   "adc %2")
+ 
+ 
+ /* Use `add' rather than `sum' since it is shorter (opcode #05 vs. #52).
+    We couldn't keep error flag from being set occasionally anyway,
+    since we want to use `adc', which does checking...  */
+ 
+ (define_insn "_add"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (plus:SI (match_operand:SI 1 "ABCreg_operand" "%b")
+                  (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "add"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ /* wsub, wsubdb, (if available) ssub */
+ 
+ (define_insn "_wsub"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (plus:SI (mult:SI (match_operand:SI 2 "ABCreg_operand" "b")
+                           (match_operand:SI 3 "wsub_scale_operand" ""))
+                  (match_operand:SI 1 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "*return
+     INTVAL (operands[3]) == UNITS_PER_WORD    ? \"wsub\"  :
+     INTVAL (operands[3]) == UNITS_PER_WORD*2  ? \"wsubdb\":
+     TARGET_HAVE_SIXTEEN
+       && INTVAL (operands[3]) == UNITS_PER_WORD/2  ? \"ssub\":
+     (char *) abort();"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ /* expand_binop tries to commute input operands to make the first one a
+    register, so we don't need to expect nonlocal_operand at operands[1].  */
+ 
+ (define_expand "addsf3"
+   [(set (match_operand:SF 0 "FABCreg_operand" "")
+         (plus:SF (match_operand:SF 1 "FABCreg_operand" "")
+                  (match_operand:SF 2 "FABCreg_or_nonlocal_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t,t")
+         (plus:SF (match_operand:SF 1 "FABCreg_operand" "%u,t")
+                  (match_operand:SF 2 "FABCreg_or_nonlocal_operand" "t,R")))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "@
+    fpadd
+    fpldnladdsn"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_expand "adddf3"
+   [(set (match_operand:DF 0 "FABCreg_operand" "")
+         (plus:DF (match_operand:DF 1 "FABCreg_operand" "")
+                  (match_operand:DF 2 "FABCreg_or_nonlocal_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t,t")
+         (plus:DF (match_operand:DF 1 "FABCreg_operand" "%u,t")
+                  (match_operand:DF 2 "FABCreg_or_nonlocal_operand" "t,R")))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "@
+    fpadd
+    fpldnladddb"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ ;;------------------------------
+ ;; subM3
+ ;;------------------------------
+ 
+ /* `diff' and `sub' are both short, and both take 1 cycle. */
+ 
+ (define_expand "subsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (minus:SI (match_operand:SI 1 "ABCreg_operand" "")
+                   (match_operand:SI 2 "ABCreg_operand" "")))]
+   ""
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (minus:SI (match_operand:SI 1 "ABCreg_operand" "b")
+                   (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "diff"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ (define_expand "subsf3"
+   [(set (match_operand:SF 0 "FABCreg_operand" "")
+         (minus:SF (match_operand:SF 1 "FABCreg_operand" "")
+                   (match_operand:SF 2 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (minus:SF (match_operand:SF 1 "FABCreg_operand" "u")
+                   (match_operand:SF 2 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpsub"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_expand "subdf3"
+   [(set (match_operand:DF 0 "FABCreg_operand" "")
+         (minus:DF (match_operand:DF 1 "FABCreg_operand" "")
+                   (match_operand:DF 2 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (minus:DF (match_operand:DF 1 "FABCreg_operand" "u")
+                   (match_operand:DF 2 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpsub"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ ;;------------------------------
+ ;; mulM3
+ ;;------------------------------
+ 
+ (define_expand "mulsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (mult:SI (match_operand:SI 1 "ABCreg_operand" "")
+                   (match_operand:SI 2 "nonmemory_operand" "")))]
+   ""
+   "{
+     if (GET_CODE (operands[2]) == CONST_INT
+         && INTVAL (operands[2]) == UNITS_PER_WORD)
+       {
+         emit_insn (gen__bcnt (operands[0],operands[1]));
+         DONE;
+       }
+     else if (! ABCreg_operand (operands[2], VOIDmode))
+       operands[2] = force_reg (SImode, operands[2]);
+     /* to match _prod */
+ }")
+ 
+ (define_insn "_prod"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (mult:SI (match_operand:SI 1 "ABCreg_operand" "%b")
+                   (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "prod"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_insn "_bcnt"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (mult:SI (match_operand:SI 1 "ABCreg_operand" "0")
+                  (const_int 4)))]
+   ""
+   "bcnt")
+ 
+ 
+ (define_expand "mulsf3"
+   [(set (match_operand:SF 0 "FABCreg_operand" "")
+         (mult:SF (match_operand:SF 1 "FABCreg_operand" "")
+                  (match_operand:SF 2 "whatever_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "{
+   if (fp_specval_operand (operands[2], SFmode))
+     {
+       emit_insn (gen__fpmul_by_specval (operands[0], operands[1], operands[2]));
+       DONE;
+     }
+   if (! FABCreg_operand (operands[2], SFmode))
+     operands[2] = copy_to_reg (operands[2]);
+ 
+   /* to match _fpmul_fpldnlmulsn */
+ }")
+ 
+ (define_expand "muldf3"
+   [(set (match_operand:DF 0 "FABCreg_operand" "")
+         (mult:DF (match_operand:DF 1 "FABCreg_operand" "")
+                  (match_operand:DF 2 "whatever_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "{
+   if (fp_specval_operand (operands[2], DFmode))
+     {
+       emit_insn (gen__fpmul_by_specval_df (operands[0], operands[1],
+                                            operands[2]));
+       DONE;
+     }
+   if (! FABCreg_operand (operands[2], DFmode))
+     operands[2] = copy_to_reg (operands[2]);
+ 
+   /* to match _fpmul_fpldnlmuldb */
+ }")
+ 
+ (define_insn "_fpmul_fpldnlmulsn"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t,t")
+         (mult:SF (match_operand:SF 1 "FABCreg_operand" "%u,t")
+                  (match_operand:SF 2 "FABCreg_or_nonlocal_operand" "t,R")))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "@
+    fpmul
+    fpldnlmulsn"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_insn "_fpmul_fpldnlmuldb"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t,t")
+         (mult:DF (match_operand:DF 1 "FABCreg_operand" "%u,t")
+                  (match_operand:DF 2 "FABCreg_or_nonlocal_operand" "t,R")))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "@
+    fpmul
+    fpldnlmuldb"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_insn "_fpmul_by_specval"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t,t")
+         (mult:SF (match_operand:SF 1 "FABCreg_operand" "t,t")
+                  (match_operand:SF 2 "fp_specval_operand" "G,H")))
+    (clobber (match_scratch:SI 3 "=&r,&r"))]
+   "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
+   "@
+    fpumulby2
+    fpuexpinc32"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_insn ""
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t,t")
+         (mult:SF (match_operand:SF 1 "FABCreg_operand" "t,t")
+                  (match_operand:SF 2 "fp_specval_operand" "G,H")))]
+   "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
+   "@
+    fpmulby2
+    fpexpinc32"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_insn "_fpmul_by_specval_df"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t,t")
+         (mult:DF (match_operand:DF 1 "FABCreg_operand" "t,t")
+                  (match_operand:DF 2 "fp_specval_operand" "G,H")))
+    (clobber (match_scratch:SI 3 "=&r,&r"))]
+   "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
+   "@
+    fpumulby2
+    fpuexpinc32"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_insn ""
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t,t")
+         (mult:DF (match_operand:DF 1 "FABCreg_operand" "t,t")
+                  (match_operand:DF 2 "fp_specval_operand" "G,H")))]
+   "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
+   "@
+    fpmulby2
+    fpexpinc32"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ ;;------------------------------
+ ;; divM3
+ ;;------------------------------
+ 
+ (define_expand "divsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (div:SI (match_operand:SI 1 "ABCreg_operand" "")
+                 (match_operand:SI 2 "ABCreg_operand" "")))]
+   ""
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (div:SI (match_operand:SI 1 "ABCreg_operand" "b")
+                 (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "div"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ (define_expand "divsf3"
+   [(set (match_operand:SF 0 "FABCreg_operand" "")
+         (div:SF (match_operand:SF 1 "FABCreg_operand" "")
+                  (match_operand:SF 2 "whatever_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "{
+   if (fp_specval_operand (operands[2], SFmode))
+     {
+       emit_insn (gen__fpdiv_by_specval (operands[0], operands[1], operands[2]));
+       DONE;
+     }
+   if (! FABCreg_operand (operands[2], SFmode))
+     operands[2] = copy_to_reg (operands[2]);
+ 
+   /* to match _fpdiv */
+ }")
+ 
+ (define_insn "_fpdiv"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (div:SF (match_operand:SF 1 "FABCreg_operand" "u")
+                  (match_operand:SF 2 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpdiv"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_insn "_fpdiv_by_specval"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t,t")
+         (div:SF (match_operand:SF 1 "FABCreg_operand" "t,t")
+                 (match_operand:SF 2 "fp_specval_operand" "G,H")))
+    (clobber (match_scratch:SI 3 "=&r,&r"))]
+   "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
+   "@
+    fpudivby2
+    fpuexpdec32"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_insn ""
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t,t")
+         (div:SF (match_operand:SF 1 "FABCreg_operand" "t,t")
+                 (match_operand:SF 2 "fp_specval_operand" "G,H")))]
+   "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
+   "@
+    fpdivby2
+    fpexpdec32"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ 
+ (define_expand "divdf3"
+   [(set (match_operand:DF 0 "FABCreg_operand" "")
+         (div:DF (match_operand:DF 1 "FABCreg_operand" "")
+                  (match_operand:DF 2 "whatever_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "{
+   if (fp_specval_operand (operands[2], DFmode))
+     {
+       emit_insn (gen__fpdiv_by_specval_df (operands[0], operands[1],
+                                            operands[2]));
+       DONE;
+     }
+   if (! FABCreg_operand (operands[2], DFmode))
+     operands[2] = copy_to_reg (operands[2]);
+ 
+   /* to match _fpdiv_df */
+ }")
+ 
+ (define_insn "_fpdiv_df"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (div:DF (match_operand:DF 1 "FABCreg_operand" "u")
+                  (match_operand:DF 2 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpdiv"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_insn "_fpdiv_by_specval_df"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t,t")
+         (div:DF (match_operand:DF 1 "FABCreg_operand" "t,t")
+                 (match_operand:DF 2 "fp_specval_operand" "G,H")))
+    (clobber (match_scratch:SI 3 "=&r,&r"))]
+   "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
+   "@
+    fpudivby2
+    fpuexpdec32"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_insn ""
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t,t")
+         (div:DF (match_operand:DF 1 "FABCreg_operand" "t,t")
+                 (match_operand:DF 2 "fp_specval_operand" "G,H")))]
+   "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
+   "@
+    fpdivby2
+    fpexpdec32"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ ;;------------------------------
+ ;; udivM3
+ ;;------------------------------
+ ;; udivmodM4 is used instead
+ 
+ 
+ ;;------------------------------
+ ;; modM3
+ ;;------------------------------
+ 
+ (define_expand "modsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (mod:SI (match_operand:SI 1 "ABCreg_operand" "")
+                 (match_operand:SI 2 "ABCreg_operand" "")))]
+   ""
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (mod:SI (match_operand:SI 1 "ABCreg_operand" "b")
+                 (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "rem"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ (define_expand "modsf3"
+   [(set (match_operand:SF 0 "FABCreg_operand" "")
+         (mod:SF (match_operand:SF 1 "FABCreg_operand" "")
+                 (match_operand:SF 2 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (mod:SF (match_operand:SF 1 "FABCreg_operand" "u")
+                 (match_operand:SF 2 "FABCreg_operand" "t")))
+    (clobber (match_scratch:SI 3 "=&r"))
+    (clobber (match_scratch:SI 4 "=&r"))
+    (clobber (match_scratch:SI 5 "=&r"))
+    (clobber (match_scratch:SF 6 "=&f"))]
+   "TARGET_HAVE_FPU
+    && TARGET_HAVE_FPENTRY
+    && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpremfirst
+ 	eqc 0
+ 	cj LF%=2
+ LF%=1
+ 	fpremstep
+ 	cj LF%=1
+ LF%=2"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ (define_expand "moddf3"
+   [(set (match_operand:DF 0 "FABCreg_operand" "")
+         (mod:DF (match_operand:DF 1 "FABCreg_operand" "")
+                 (match_operand:DF 2 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (mod:DF (match_operand:DF 1 "FABCreg_operand" "u")
+                 (match_operand:DF 2 "FABCreg_operand" "t")))
+    (clobber (match_scratch:SI 3 "=&r"))
+    (clobber (match_scratch:SI 4 "=&r"))
+    (clobber (match_scratch:SI 5 "=&r"))
+    (clobber (match_scratch:SF 6 "=&f"))]
+   "TARGET_HAVE_FPU
+    && TARGET_HAVE_FPENTRY
+    && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpremfirst
+ 	eqc 0
+ 	cj LF%=2
+ LF%=1
+ 	fpremstep
+ 	cj LF%=1
+ LF%=2"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_insn ""
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (mod:SF (match_operand:SF 1 "FABCreg_operand" "u")
+                 (match_operand:SF 2 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU
+    && ! TARGET_HAVE_FPENTRY
+    && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fprem"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_insn ""
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (mod:DF (match_operand:DF 1 "FABCreg_operand" "u")
+                 (match_operand:DF 2 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU
+    && ! TARGET_HAVE_FPENTRY
+    && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fprem"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ ;;------------------------------
+ ;; umodM3
+ ;;------------------------------
+ ;; udivmodM4 is used instead
+ 
+ 
+ ;;------------------------------
+ ;; sminM3
+ ;; smaxM3
+ ;; uminM3
+ ;; umaxM3
+ ;;------------------------------
+ ;; N/A
+ 
+ ;;------------------------------
+ ;; andM3
+ ;;------------------------------
+ 
+ (define_expand "andsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (and:SI (match_operand:SI 1 "ABCreg_operand" "")
+                 (match_operand:SI 2 "ABCreg_operand" "")))]
+   ""
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (and:SI (match_operand:SI 1 "ABCreg_operand" "%b")
+                 (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "and"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ ;;------------------------------
+ ;; iorM3
+ ;;------------------------------
+ 
+ (define_expand "iorsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (ior:SI (match_operand:SI 1 "ABCreg_operand" "")
+                 (match_operand:SI 2 "ABCreg_operand" "")))]
+   ""
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (ior:SI (match_operand:SI 1 "ABCreg_operand" "%b")
+                 (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "or"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ ;;------------------------------
+ ;; xorM3
+ ;;------------------------------
+ 
+ (define_expand "xorsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (xor:SI (match_operand:SI 1 "ABCreg_operand" "")
+                 (match_operand:SI 2 "ABCreg_operand" "")))]
+   ""
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (xor:SI (match_operand:SI 1 "ABCreg_operand" "%b")
+                 (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "xor"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ ;;------------------------------
+ ;; mulhisi3
+ ;; mulqihi3
+ ;;------------------------------
+ ;; N/A
+ 
+ 
+ ;;------------------------------
+ ;; mulsidi3
+ ;;------------------------------
+ 
+ (define_expand "mulsidi3"
+   [(set (match_operand:DI 0 "ABCreg_operand" "")
+         (plus:DI
+           (mult:DI (sign_extend:DI (match_operand:SI 1 "ABCreg_operand" ""))
+                    (sign_extend:DI (match_operand:SI 2 "ABCreg_operand" "")))
+           (sign_extend:DI (match_dup 3))))]
+   "TARGET_HAVE_SLMUL"
+   "{operands[3] = force_reg (SImode, CONST0_RTX (SImode));
+    /* to match _slmul */
+ }")
+ 
+ (define_insn "_slmul"
+   [(set (match_operand:DI 0 "ABCreg_operand" "=a")
+         (plus:DI
+           (mult:DI (sign_extend:DI (match_operand:SI 1 "ABCreg_operand" "%b"))
+                    (sign_extend:DI (match_operand:SI 2 "ABCreg_operand" "a")))
+           (sign_extend:DI (match_operand:SI 3 "ABCreg_operand" "c"))))]
+   "TARGET_HAVE_SLMUL
+    && T800_DISTINCT_REGS (operands[1], operands[2])
+    && T800_DISTINCT_REGS (operands[2], operands[3])
+    && T800_DISTINCT_REGS (operands[1], operands[3])"
+   "slmul"
+   [(set (attr "popped_inputs") (const_int 14))])
+ 
+ /* sulmul is not directly usable for code generation.  Yeah, tell GCC
+    about it and see if it will manage to use it... */
+ 
+ (define_insn "_sulmul"
+   [(set (match_operand:DI 0 "ABCreg_operand" "=a")
+         (plus:DI
+           (mult:DI (zero_extend:DI (match_operand:SI 1 "ABCreg_operand" "b"))
+                    (sign_extend:DI (match_operand:SI 2 "ABCreg_operand" "a")))
+           (sign_extend:DI (match_operand:SI 3 "ABCreg_operand" "c"))))]
+   "TARGET_HAVE_SLMUL
+    && T800_DISTINCT_REGS (operands[1], operands[2])
+    && T800_DISTINCT_REGS (operands[2], operands[3])
+    && T800_DISTINCT_REGS (operands[1], operands[3])"
+   "sulmul"
+   [(set (attr "popped_inputs") (const_int 14))])
+ 
+ 
+ ;;------------------------------
+ ;; umulhisi3
+ ;; umulqihi3
+ ;;------------------------------
+ ;; N/A
+ 
+ ;;------------------------------
+ ;; umulsidi3
+ ;;------------------------------
+ 
+ (define_expand "umulsidi3"
+   [(set (match_operand:DI 0 "ABCreg_operand" "")
+         (plus:DI
+           (mult:DI (zero_extend:DI (match_operand:SI 1 "ABCreg_operand" ""))
+                    (zero_extend:DI (match_operand:SI 2 "ABCreg_operand" "")))
+           (zero_extend:DI (match_dup 3))))]
+   ""
+   "{operands[3] = force_reg (SImode, CONST0_RTX (SImode));
+    /* to match _lmul */
+ }")
+ 
+ (define_insn "_lmul"
+   [(set (match_operand:DI 0 "ABCreg_operand" "=a")
+         (plus:DI
+           (mult:DI (zero_extend:DI (match_operand:SI 1 "ABCreg_operand" "%b"))
+                    (zero_extend:DI (match_operand:SI 2 "ABCreg_operand" "a")))
+           (zero_extend:DI (match_operand:SI 3 "ABCreg_operand" "c"))))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])
+    && T800_DISTINCT_REGS (operands[2], operands[3])
+    && T800_DISTINCT_REGS (operands[1], operands[3])"
+   "lmul"
+   [(set (attr "popped_inputs") (const_int 14))])
+ 
+ 
+ ;;------------------------------
+ ;; divmodM4
+ ;;------------------------------
+ 
+ /* This is available only for divsor == UNITS_PER_WORD. */
+ 
+ (define_expand "divmodsi4"
+   [(parallel
+     [(set (match_operand:SI 0 "ABCreg_operand" "")
+           (div:SI (match_operand:SI 1 "ABCreg_operand" "")
+                   (match_operand:SI 2 "nonmemory_operand" "")))
+      (set (match_operand:SI 3 "ABCreg_operand" "")
+           (mod:SI (match_dup 1)
+                   (match_dup 2)))])]
+   ""
+   "{
+   if (GET_CODE (operands[3]) != CONST_INT
+       || INTVAL (operands[3]) != UNITS_PER_WORD)
+     FAIL;
+   /* to match _wcnt */
+ }")
+ 
+ (define_insn "_wcnt"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (div:SI (match_operand:SI 1 "ABCreg_operand" "0")
+                 (const_int 4)))
+    (set (match_operand:SI 2 "ABCreg_operand" "=b")
+         (mod:SI (match_dup 1)
+                 (const_int 4)))]
+   ""
+   "wcnt")
+ 
+ 
+ ;;------------------------------
+ ;; udivmodM4
+ ;;------------------------------
+ 
+ (define_expand "udivmodsi4"
+   [(parallel
+     [(set (match_operand:SI 0 "ABCreg_operand" "")
+           (truncate:SI
+             (udiv:DI (match_operand:SI 1 "ABCreg_operand" "")
+                      (zero_extend:DI
+                        (match_operand:SI 2 "ABCreg_operand" "")))))
+     (set (match_operand:SI 3 "ABCreg_operand" "")
+          (truncate:SI (umod:DI (match_dup 1)
+                                (zero_extend:DI (match_dup 2)))))])]
+   ""
+   "{
+   operands[1] = convert_to_mode (DImode, operands[1], 1 /*unsigned_p*/);
+   /* to match _ldiv */
+ }")
+ 
+ (define_insn "_ldiv"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (truncate:SI (udiv:DI (match_operand:DI 1 "ABCreg_operand" "b")
+                               (zero_extend:DI
+                                 (match_operand:SI 2 "ABCreg_operand" "a")))))
+    (set (match_operand:SI 3 "ABCreg_operand" "=b")
+         (truncate:SI (umod:DI (match_dup 1)
+                      (zero_extend:DI (match_dup 2)))))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "ldiv"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ ;;------------------------------
+ ;; ashlM3
+ ;;------------------------------
+ (define_expand "ashlsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (ashift:SI (match_operand:SI 1 "ABCreg_operand" "")
+                    (match_operand:SI 2 "ABCreg_operand" "")))]
+   ""
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (ashift:SI (match_operand:SI 1 "ABCreg_operand" "b")
+                    (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "shl"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_expand "ashldi3"
+   [(set (match_operand:DI 0 "ABCreg_operand" "")
+         (ashift:DI (match_operand:DI 1 "ABCreg_operand" "")
+                    (match_operand:SI 2 "ABCreg_operand" "")))]
+   ""
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:DI 0 "ABCreg_operand" "=a")
+         (ashift:DI (match_operand:DI 1 "ABCreg_operand" "b")
+                    (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "lshl"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ ;;------------------------------
+ ;; ashrM3
+ ;;------------------------------
+ 
+ /* We use whatever_operand here to obtain the right operand evaluation
+    order; this tends to save us some reg-stack shuffling aferwards.  */
+ 
+ (define_expand "ashrsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (ashiftrt:SI (match_operand:SI 1 "whatever_operand" "")
+                      (match_operand:SI 2 "whatever_operand" "")))]
+   ""
+   "{
+      rtx tmp = gen_reg_rtx(DImode);
+ 
+      operands[1] = convert_to_mode (DImode, operands[1], 0/*!unsigned_p*/);
+ 
+      if (! ABCreg_operand (operands[1], DImode))
+        operands[1] = force_reg (DImode, operands[1]);
+ 
+      if (! ABCreg_operand (operands[2], SImode))
+        operands[2] = force_reg (SImode, operands[2]);
+ 
+      /* Tried to avoid the final move insn by getting the output of
+         _lshr into (SUBREG:DI operands[0]). This fails, since operands[0]
+         is a SImode pseudo and gets a single hard register only; it seems
+         illegal to assign to it in DImode (?).  */
+ 
+      emit_insn (gen_ashrdi3 (tmp, operands[1], operands[2]));
+      emit_move_insn (operands[0], gen_rtx (SUBREG, SImode, tmp, 0));
+      DONE;
+ }")
+ 
+ (define_expand "ashrdi3"
+   [(set (match_operand:DI 0 "ABCreg_operand" "")
+         (lshiftrt:DI (match_operand:DI 1 "ABCreg_operand" "")
+                      (match_operand:SI 2 "ABCreg_operand" "")))]
+   ""
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:DI 0 "ABCreg_operand" "=a")
+         (lshiftrt:DI (match_operand:DI 1 "ABCreg_operand" "b")
+                      (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "lshr"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ ;;------------------------------
+ ;; lshlM3
+ ;;------------------------------
+ ;; This is the same as ashlM3.  Needs not be defined if negative shift
+ ;; count is not allowed.
+ 
+ ;;------------------------------
+ ;; lshrM3
+ ;;------------------------------
+ 
+ (define_expand "lshrsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (lshiftrt:SI (match_operand:SI 1 "ABCreg_operand" "")
+                      (match_operand:SI 2 "ABCreg_operand" "")))]
+   ""
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (lshiftrt:SI (match_operand:SI 1 "ABCreg_operand" "b")
+                      (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "shr"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ ;;------------------------------
+ ;; rotlM3
+ ;; rotrM3
+ ;;------------------------------
+ (define_expand "rotlsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (rotate:SI (match_operand:SI 1 "whatever_operand" "")
+                    (match_operand:SI 2 "whatever_operand" "")))]
+   ""
+   "{
+      rtx tmp = gen_reg_rtx(DImode);
+ 
+      /* Evaluate operands in the desired order */
+      emit_move_insn (gen_rtx (SUBREG, SImode, tmp, 1), operands[1]);
+      emit_move_insn (gen_rtx (SUBREG, SImode, tmp, 0), GEN_INT (0));
+ 
+      if (! ABCreg_operand (operands[2], SImode))
+        operands[2] = force_reg (SImode, operands[2]);
+ 
+      emit_insn (gen_ashldi3 (tmp, tmp, operands[2]));
+      emit_insn (gen_iorsi3 (operands[0], gen_rtx (SUBREG, SImode, tmp, 0),
+                                          gen_rtx (SUBREG, SImode, tmp, 1)));
+      DONE;
+ }")
+ 
+ (define_expand "rotrsi3"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (rotatert:SI (match_operand:SI 1 "whatever_operand" "")
+                      (match_operand:SI 2 "whatever_operand" "")))]
+   ""
+   "{
+      rtx tmp = gen_reg_rtx(DImode);
+ 
+      operands[1] = convert_to_mode (DImode, operands[1], 1/*unsigned_p*/);
+ 
+      if (! ABCreg_operand (operands[1], DImode))
+        operands[1] = force_reg (DImode, operands[1]);
+      if (! ABCreg_operand (operands[2], SImode))
+        operands[2] = force_reg (SImode, operands[2]);
+ 
+      emit_insn (gen_ashrdi3 (tmp, operands[1], operands[2]));
+      emit_insn (gen_iorsi3 (operands[0], gen_rtx (SUBREG, SImode, tmp, 0),
+                                          gen_rtx (SUBREG, SImode, tmp, 1)));
+      DONE;
+ }")
+ 
+ 
+ ;;------------------------------
+ ;; negM2
+ ;;------------------------------
+ 
+ (define_expand "negsi2"
+   [(set (match_dup 2)
+         (not:SI (match_operand:SI 1 "ABCreg_operand" "")))
+    (set (match_operand:SI 0 "ABCreg_operand" "")
+         (plus:SI (match_dup 2)
+                  (const_int 1)))]
+   ""
+   "operands[2] = gen_reg_rtx (SImode);
+    /* to match `not; adc 1' */
+ ")
+ 
+ /* Floating point negation.  It is now implemented as (0 - x), and so
+    requires the operand to be in an fp register.
+ 
+    ??? We could also do it with XOR, if the operand is in an integer
+    reg or in memory.  */
+ 
+ (define_expand "negsf2"
+   [(set (match_dup 2)
+         (match_dup 3))
+    (set (match_operand:SF 0 "FABCreg_operand" "")
+         (minus:SF (match_dup 2)
+                 (match_operand:SF 1 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "operands[2] = gen_reg_rtx (SFmode);
+    operands[3] = CONST0_RTX (SFmode);
+    /* to match `fpldzerosn; fpsub' */
+ ")
+ 
+ (define_expand "negdf2"
+   [(set (match_dup 2)
+         (match_dup 3))
+    (set (match_operand:DF 0 "FABCreg_operand" "")
+         (minus:DF (match_dup 2)
+                 (match_operand:DF 1 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "operands[2] = gen_reg_rtx (DFmode);
+    operands[3] = CONST0_RTX (DFmode);
+    /* to match `fpldzerosn; fpsub' */
+ ")
+ 
+ 
+ ;;------------------------------
+ ;; absM2
+ ;;------------------------------
+ 
+ (define_insn "abssf3"
+   [(set (match_operand:SF 0 "FABCreg_operand" "")
+         (abs:SF (match_operand:SF 1 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "")
+ 
+ (define_insn "absdf3"
+   [(set (match_operand:DF 0 "FABCreg_operand" "")
+         (abs:DF (match_operand:DF 1 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "")
+ 
+ (define_insn ""
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (abs:SF (match_operand:SF 1 "FABCreg_operand" "0")))
+    (clobber (match_scratch:SI 2 "=&r"))]
+   "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
+   "fpuabs")
+ 
+ (define_insn ""
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (abs:SF (match_operand:SF 1 "FABCreg_operand" "0")))]
+   "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
+   "fpabs")
+ 
+ (define_insn ""
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (abs:DF (match_operand:DF 1 "FABCreg_operand" "0")))
+    (clobber (match_scratch:SI 2 "=&r"))]
+   "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
+   "fpuabs")
+ 
+ (define_insn ""
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (abs:DF (match_operand:DF 1 "FABCreg_operand" "0")))]
+   "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
+   "fpabs")
+ 
+ 
+ ;;------------------------------
+ ;; sqrtM2
+ ;;------------------------------
+ 
+ (define_expand "sqrtsf3"
+   [(set (match_operand:SF 0 "FABCreg_operand" "")
+         (sqrt:SF (match_operand:SF 1 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "if (TARGET_HAVE_FPENTRY) {
+      emit_insn (gen__fpusqrt_sequence_sf (operands[0], operands[1]));
+      DONE;
+    }
+ ")
+ 
+ (define_expand "sqrtdf3"
+   [(set (match_operand:DF 0 "FABCreg_operand" "")
+         (sqrt:DF (match_operand:DF 1 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "if (TARGET_HAVE_FPENTRY) {
+      emit_insn (gen__fpusqrt_sequence_df (operands[0], operands[1]));
+      DONE;
+    }
+ ")
+ 
+ (define_insn "_fpusqrt_sequence_sf"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (sqrt:SF (match_operand:SF 1 "FABCreg_operand" "0")))
+    (clobber (match_scratch:SI 3 "=&r"))
+    (clobber (match_scratch:SF 4 "=&f"))
+    (clobber (match_scratch:SF 5 "=&f"))]
+   "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
+   "fpusqrtfirst\;fpusqrtstep\;fpusqrtstep\;fpusqrtlast")
+ 
+ (define_insn ""
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (sqrt:SF (match_operand:SF 1 "FABCreg_operand" "0")))]
+   "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
+   "fpsqrt")
+ 
+ (define_insn "_fpusqrt_sequence_df"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (sqrt:DF (match_operand:DF 1 "FABCreg_operand" "0")))
+    (clobber (match_scratch:SI 3 "=&r"))
+    (clobber (match_scratch:SF 4 "=&f"))
+    (clobber (match_scratch:SF 5 "=&f"))]
+   "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
+   "fpusqrtfirst\;fpusqrtstep\;fpusqrtstep\;fpusqrtstep\;fpusqrtstep\;fpusqrtstep\;fpusqrtlast")
+ 
+ (define_insn ""
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (sqrt:DF (match_operand:DF 1 "FABCreg_operand" "0")))]
+   "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
+   "fpsqrt")
+ 
+ 
+ ;;------------------------------
+ ;; ffsM2
+ ;;------------------------------
+ 
+ ; bet this will never be used  :-)
+ 
+ (define_insn "ffssi2"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (ffs:SI (match_operand:DI 1 "ABCreg_operand" "a")))
+    (clobber (match_scratch:SI 2 "=&r"))]
+   ""
+   "bitrevword\;rev\;bitrevword\;norm\;diff\;rev\;adc 1\;ldc 65\;rem"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ 	
+ ;;------------------------------
+ ;; one_cmplM2
+ ;;------------------------------
+ 
+ (define_insn "one_cmplsi2"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (not:SI (match_operand:SI 1 "ABCreg_operand" "0")))]
+   ""
+   "not")
+ 
+ ;;------------------------------
+ ;; cmpM
+ ;;------------------------------
+ 
+ /* For compare operations, we simply store the comparison operands and
+    generate no insns.  The following bCC or sCC insn will output
+    whatever is needed.  */
+ 
+ /* Compare in QImode can sometimes be better that convert to SImode
+    plus compare in SImode.  For example, SImode unsigned comparisons
+    are based on `ldiff', while in QImode a cheap `gt' is sufficient.
+    Therefore we declare the QImode comparisons.  */
+ 
+ (define_expand "cmpqi"
+   [(match_operand:QI 0 "general_operand" "")
+    (match_operand:QI 1 "general_operand" "")]
+   "TARGET_USE_cmpqi"
+   "{
+   t800_compare.op[0] = operands[0];
+   t800_compare.op[1] = operands[1];
+   t800_compare.fp = 0;
+   DONE;
+ }")
+ 
+ (define_expand "cmphi"
+   [(match_operand:HI 0 "general_operand" "")
+    (match_operand:HI 1 "general_operand" "")]
+   "TARGET_USE_cmpqi"
+   "{
+   t800_compare.op[0] = operands[0];
+   t800_compare.op[1] = operands[1];
+   t800_compare.fp = 0;
+   DONE;
+ }")
+ 
+ (define_expand "cmpsi"
+   [(match_operand:SI 0 "ABCreg_operand" "")
+    (match_operand:SI 1 "nonmemory_operand" "")]
+   ""
+   "{
+   t800_compare.op[0] = operands[0];
+   t800_compare.op[1] = operands[1];
+   t800_compare.fp = 0;
+   DONE;
+ }")
+ 
+ (define_expand "cmpsf"
+   [(match_operand:SF 0 "FABCreg_operand" "")
+    (match_operand:SF 1 "FABCreg_operand" "")]
+   "TARGET_HAVE_FPU"
+   "{
+   t800_compare.op[0] = operands[0];
+   t800_compare.op[1] = operands[1];
+   t800_compare.fp = 1;
+   DONE;
+ }")
+ 
+ (define_expand "cmpdf"
+   [(match_operand:DF 0 "FABCreg_operand" "")
+    (match_operand:DF 1 "FABCreg_operand" "")]
+   "TARGET_HAVE_FPU"
+   "{
+   t800_compare.op[0] = operands[0];
+   t800_compare.op[1] = operands[1];
+   t800_compare.fp = 1;
+   DONE;
+ }")
+ 
+ ;;------------------------------
+ ;; tstM
+ ;;------------------------------
+ ;; Should not be defined as transputers do not have (cc0)
+ 
+ ;;------------------------------
+ ;; movstrM
+ ;;------------------------------
+ 
+ (define_expand "movstrsi"
+   [(set (match_operand:BLK 0 "general_operand" "")
+         (match_operand:BLK 1 "general_operand" ""))
+    (use (match_operand:SI 2 "general_operand" ""))
+    (use (match_operand:SI 3 "" ""))]
+   ""
+   "{
+     rtx src, dest, len;
+ 
+     if (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)
+       abort ();
+ 
+     /* Don't use force_reg on addresses, because it wouldn't do
+        anything with Wreg, while we need ABCreg */
+ 
+     dest = XEXP (operands[0], 0);
+     if (! ABCreg_operand (dest, VOIDmode))
+ 	dest = copy_addr_to_reg (dest);
+ 
+     src = XEXP (operands[1], 0);
+     if (! ABCreg_operand (src, VOIDmode))
+ 	src = copy_addr_to_reg (src);
+ 
+     len = force_reg (SImode, operands[2]);
+ 
+     emit_insn (gen__move (dest, src, len));
+     DONE;
+ }")
+ 
+ (define_insn "_move"
+   [(set (mem:BLK (match_operand:SI 0 "ABCreg_operand" "b"))
+         (mem:BLK (match_operand:SI 1 "ABCreg_operand" "c")))
+    (use (match_operand:SI 2 "ABCreg_operand" "a"))]
+   ""
+   "move"
+   [(set (attr "popped_inputs") (const_int 7))])
+ 
+ ;;------------------------------
+ ;; cmpstrM
+ ;;------------------------------
+ ;; N/A
+ 
+ /* Conversions -----------------------------
+ 
+ Legend: 
+     -   no conversion applies
+     f   floatMN2
+     fu  floatunsMN2
+     x   fixMN2
+     xu  fixunsMN2
+     xt  fix_truncMN2
+     xtu fixuns_truncMN2
+     ft  ftruncM2
+     t   truncMN
+     e   extendMN
+     z   zero-extendMN
+ 
+ All possible conversions:
+         QI          SI          DI          SF          DF
+ QI      -           e,z         e,z         f           f
+ SI      t           -           e,z         f,fu        f,fu
+ DI      t           t           -           f,fu        f,fu
+ SF      x,xu,xt,xtu x,xu,xt,xtu x,xu,xt,xtu ft          e
+ DF      x,xu,xt,xtu x,xu,xt,xtu x,xu,xt,xtu t           ft
+ 
+ Available insns on transputer:
+         QI          SI          DI          SF          DF
+ QI      -           e,(z)       -           -           -
+ SI      (t)         -           e,(z)       f,fu        f,fu
+ DI      -           (t)         -           (f)         (f)   
+ SF      -           x           (x)         ft          e
+ DF      -           x           (x)         t           ft
+ 
+    e     (extendQISI):       xword
+    e     (extendSIDI):       xdble
+    t     (truncdfsf):        fpur64tor32
+    e     (extendsfdf):       fpur32tor64
+    ft    (ftrunc[sd]f):      fpint
+    x     (fix[sd]fsi):       fpstnli32
+    f     (floatsisf):        fpi32tor32
+    f     (floatsidf):        fpi32tor64
+    fu    (floatunssidf):     fpb32tor64
+    (x)   (fix[sd]fdi):       <sequence>
+    (f)   (floatdi[sd]f):     <sequence>
+ */
+ 
+ ;;------------------------------
+ ;; floatMN2
+ ;;------------------------------
+ 
+ /* Insns of this group on trabsputers are only able to take input from
+    memory.  Therefore, when asked to take input from a register, we
+    allocate a stack slot and copy the input register in there before
+    the insn.  Thus, we have to have an expander for every insn of this
+    group :-( */
+ 
+ (define_expand "floatsisf2"
+   [(set (match_operand:SF 0 "FABCreg_operand" "")
+         (float:SF (match_operand:SI 1 "general_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "{
+   rtx t800_temp_slot (enum machine_mode);
+   rtx t800_force_nonlocal (rtx);
+   
+   if (! nonlocal_operand (operands[1], SImode))
+     {
+       if (GET_CODE (operands[1]) != MEM)
+         {
+           rtx temp = t800_temp_slot (SImode);
+           emit_move_insn (temp, operands[1]);
+           operands[1] = temp;
+         }
+       operands[1] = t800_force_nonlocal (operands[1]);
+     }
+   /* to match _fpi32tor32 */
+ }")
+ 
+ (define_insn "_fpi32tor32"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (float:SF (match_operand:SI 1 "nonlocal_operand" "R")))]
+   "TARGET_HAVE_FPU"
+   "fpi32tor32"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ 
+ (define_expand "floatsidf2"
+   [(set (match_operand:DF 0 "FABCreg_operand" "")
+         (float:DF (match_operand:SI 1 "general_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "{
+   rtx t800_temp_slot (enum machine_mode);
+   rtx t800_force_nonlocal (rtx);
+   
+   if (! nonlocal_operand (operands[1], SImode))
+     {
+       if (GET_CODE (operands[1]) != MEM)
+         {
+           rtx temp = t800_temp_slot (SImode);
+           emit_move_insn (temp, operands[1]);
+           operands[1] = temp;
+         }
+       operands[1] = t800_force_nonlocal (operands[1]);
+     }
+   /* to match _fpi32tor64 */
+ }")
+ 
+ (define_insn "_fpi32tor64"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (float:DF (match_operand:SI 1 "nonlocal_operand" "R")))]
+   "TARGET_HAVE_FPU"
+   "fpi32tor64"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ 
+ (define_expand "floatdisf2"
+   [(parallel
+     [(set (match_operand:SF 0 "FABCreg_operand" "")
+           (float:SF (match_operand:DI 1 "general_operand" "")))
+      (clobber (match_scratch:SI 2 ""))
+      (clobber (match_scratch:SF 3 ""))])]
+   "TARGET_HAVE_FPU"
+   "{
+   rtx t800_temp_slot (enum machine_mode);
+   rtx t800_force_nonlocal (rtx);
+   
+   if (! nonlocal_operand (operands[1], DImode))
+     {
+       if (GET_CODE (operands[1]) != MEM)
+         {
+           rtx temp = t800_temp_slot (DImode);
+           emit_move_insn (temp, operands[1]);
+           operands[1] = temp;
+         }
+       operands[1] = t800_force_nonlocal (operands[1]);
+     }
+   /* to match _INT64_to_REAL32 */
+ }")
+ 
+ /* INT64 to REAL32 sequence in Round-to-Nearest mode */
+ 
+ (define_insn ""
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (float:SF (match_operand:DI 1 "nonlocal_operand" "R")))
+    (clobber (match_scratch:SI 2 "=&r"))
+    (clobber (match_scratch:SF 3 "=&f"))]
+   "TARGET_HAVE_FPU"
+   "* return TARGET_HAVE_FPENTRY ?
+      \"dup\;fpb32tor64\;fpunoround\;ldnlp 1\;fpi32tor64\;fpuexpinc32\;fpunoround\;fpadd\" :
+      \"dup\;fpb32tor64\;ldnlp 1\;fpi32tor64\;fpexpinc32\;fpadddbsn\";"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_expand "floatdidf2"
+   [(parallel
+     [(set (match_operand:DF 0 "FABCreg_operand" "")
+           (float:DF (match_operand:DI 1 "general_operand" "")))
+      (clobber (match_scratch:SI 2 ""))
+      (clobber (match_scratch:SF 3 ""))])]
+   "TARGET_HAVE_FPU"
+   "{
+   rtx t800_temp_slot (enum machine_mode);
+   rtx t800_force_nonlocal (rtx);
+   
+   if (! nonlocal_operand (operands[1], DImode))
+     {
+       if (GET_CODE (operands[1]) != MEM)
+         {
+           rtx temp = t800_temp_slot (DImode);
+           emit_move_insn (temp, operands[1]);
+           operands[1] = temp;
+         }
+       operands[1] = t800_force_nonlocal (operands[1]);
+     }
+   /* to match _INT64_to_REAL64 */
+ }")
+ 
+ 
+ /* INT64 to REAL64 sequence in Round-to-Nearest mode */
+ 
+ (define_insn "_INT64_to_REAL64"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (float:DF (match_operand:DI 1 "nonlocal_operand" "R")))
+    (clobber (match_scratch:SI 2 "=&r"))
+    (clobber (match_scratch:SF 3 "=&f"))]
+   "TARGET_HAVE_FPU"
+   "* return TARGET_HAVE_FPENTRY ?
+      \"dup\;fpb32tor64\;ldnlp 1\;fpi32tor64\;fpuexpinc32\;fpadd\" :
+      \"dup\;fpb32tor64\;ldnlp 1\;fpi32tor64\;fpexpinc32\;fpadd\";"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ 
+ ;;------------------------------
+ ;; floatunsMN2
+ ;;------------------------------
+ 
+ (define_expand "floatunssidf2"
+   [(set (match_operand:DF 0 "FABCreg_operand" "")
+         (unsigned_float:DF (match_operand:SI 1 "general_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "{
+   rtx t800_temp_slot (enum machine_mode);
+   rtx t800_force_nonlocal (rtx);
+   
+   if (! nonlocal_operand (operands[1], SImode))
+     {
+       if (GET_CODE (operands[1]) != MEM)
+         {
+           rtx temp = t800_temp_slot (SImode);
+           emit_move_insn (temp, operands[1]);
+           operands[1] = temp;
+         }
+       operands[1] = t800_force_nonlocal (operands[1]);
+     }
+   /* to match _fpb32tor64 */
+ }")
+ 
+ (define_insn "_fpb32tor64"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (unsigned_float:DF (match_operand:SI 1 "nonlocal_operand" "R")))]
+   "TARGET_HAVE_FPU"
+   "fpb32tor64"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ 
+ ;;------------------------------
+ ;; fixMN2
+ ;;------------------------------
+ 
+ /* Insns of this group on transputers are only able to output to memory.
+    Therefore, when asked to generate result in a register, we use a
+    dedicated stack slot to perform conversion, and then copy the
+    result into the specified register.  */
+ 
+ (define_expand "fixsfsi2"
+   [(match_operand:SI 0 "general_operand" "")
+    (match_operand:SF 1 "FABCreg_operand" "")]
+   "TARGET_HAVE_FPU"
+   "{
+   rtx t800_temp_slot (enum machine_mode);
+   rtx t800_force_nonlocal (rtx);
+ 
+   rtx dest = operands[0];
+   
+   if (GET_CODE (dest) != MEM)
+     dest = t800_temp_slot (SImode);
+ 
+   emit_insn (gen__fpstnli32 (t800_force_nonlocal (dest), operands[1]));
+ 
+   if (dest != operands[0])
+     emit_move_insn (operands[0], dest);
+ 
+   DONE;
+ }")
+ 
+ (define_expand "fixdfsi2"
+   [(match_operand:SI 0 "general_operand" "")
+    (match_operand:DF 1 "FABCreg_operand" "")]
+   "TARGET_HAVE_FPU"
+   "emit_insn (gen_fixsfsi2 (operands[0], operands[1])); DONE;")
+ 
+ (define_expand "fixsfdi2"
+   [(match_operand:DI 0 "general_operand" "")
+    (match_operand:SF 1 "FABCreg_operand" "")]
+   "TARGET_HAVE_FPU"
+   "{
+   rtx t800_temp_slot (enum machine_mode);
+   rtx t800_force_nonlocal (rtx);
+ 
+   rtx dest = operands[0];
+   
+   if (GET_CODE (dest) != MEM)
+     dest = t800_temp_slot (DImode);
+ 
+   emit_insn (gen__REAL_to_INT64 (t800_force_nonlocal (dest), operands[1]));
+ 
+   if (dest != operands[0])
+     emit_move_insn (operands[0], dest);
+ 
+   DONE;
+ }")
+ 
+ (define_expand "fixdfdi2"
+   [(match_operand:DI 0 "general_operand" "")
+    (match_operand:DF 1 "FABCreg_operand" "")]
+   "TARGET_HAVE_FPU"
+   "emit_insn (gen_fixsfdi2 (operands[0], operands[1])); DONE;")
+ 
+ 
+ (define_insn "_fpstnli32"
+   [(set (match_operand:SI 0 "nonlocal_operand" "=R")
+         (fix:SI (match_operand:SF 1 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU"
+   "fpstnli32"
+   [(set (attr "popped_inputs") (const_int 3))])
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "nonlocal_operand" "=R")
+         (fix:SI (match_operand:DF 1 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU"
+   "fpstnli32"
+   [(set (attr "popped_inputs") (const_int 3))])
+ 
+ 
+ (define_insn "_REAL_to_INT64"
+   [(set (match_operand:DI 0 "nonlocal_operand" "=R")
+         (fix:DI (match_operand:SF 1 "FABCreg_operand" "t")))
+    (clobber (match_scratch:SF 2 "=&f"))
+    (clobber (match_scratch:SI 3 "=&r"))]
+   "TARGET_HAVE_FPU"
+   "* return TARGET_HAVE_FPENTRY ?
+     \"fpdup\;dup\;fpstnli32\;ldnlp 1\;fpuexpdec32\;fpstnli32\" :
+     \"fpdup\;dup\;fpstnli32\;ldnlp 1\;fpexpdec32\;fpstnli32\";
+ ")
+ 
+ (define_insn ""
+   [(set (match_operand:DI 0 "nonlocal_operand" "=R")
+         (fix:DI (match_operand:DF 1 "FABCreg_operand" "t")))
+    (clobber (match_scratch:SF 2 "=&f"))
+    (clobber (match_scratch:SI 3 "=&r"))]
+   "TARGET_HAVE_FPU"
+   "* return TARGET_HAVE_FPENTRY ?
+    \"fpdup\;dup\;fpstnli32\;ldnlp 1\;fpuexpdec32\;fpstnli32\" :
+    \"fpdup\;dup\;fpstnli32\;ldnlp 1\;fpexpdec32\;fpstnli32\";"
+   [(set (attr "popped_inputs") (const_int 3))])
+ 
+ 
+ ;;------------------------------
+ ;; fixunsMN2
+ ;;------------------------------
+ ;; N/A
+ 
+ ;;------------------------------
+ ;; ftruncM2
+ ;;------------------------------
+ 
+ /* Note that the RTL code <fix:xF> represents a "round-to-zero"
+    conversion.  Therefore we should override the default rounding mode
+    of transputers, which is "round-to-nearest".  */
+ 
+ (define_expand "ftruncsf2"
+   [(set (match_operand:SF 0 "FABCreg_operand" "")
+         (fix:SF (match_operand:SF 1 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "if (TARGET_HAVE_FPENTRY) {
+      emit_insn (gen__fpurz_fpint_sf (operands[0], operands[1]));
+      DONE;
+    }
+ ")
+ 
+ (define_expand "ftruncdf2"
+   [(set (match_operand:DF 0 "FABCreg_operand" "")
+         (fix:DF (match_operand:DF 1 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "if (TARGET_HAVE_FPENTRY) {
+      emit_insn (gen__fpurz_fpint_df (operands[0], operands[1]));
+      DONE;
+    }
+ ")
+ 
+ (define_insn "_fpurz_fpint_sf"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (fix:SF (match_operand:SF 1 "FABCreg_operand" "0")))
+    (clobber (match_scratch:SI 2 "=&r"))]
+   "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
+   "fpurz\;fpint")
+ 
+ (define_insn "_fpurz_fpint_df"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (fix:DF (match_operand:DF 1 "FABCreg_operand" "0")))
+    (clobber (match_scratch:SI 2 "=&r"))]
+   "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
+   "fpurz\;fpint")
+ 
+ (define_insn ""
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (fix:SF (match_operand:SF 1 "FABCreg_operand" "0")))]
+   "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
+   "fprz\;fpint")
+ 
+ (define_insn ""
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (fix:DF (match_operand:DF 1 "FABCreg_operand" "0")))]
+   "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
+   "fprz\;fpint")
+ 
+ 
+ ;;------------------------------
+ ;; fix_truncMN2
+ ;; fixuns_truncMN2
+ ;;------------------------------
+ ;; N/A
+ 
+ 
+ ;;------------------------------
+ ;; truncMN2
+ ;;------------------------------
+ 
+ (define_expand "truncdfsf2"
+   [(set (match_operand:SF 0 "FABCreg_operand" "")
+         (float_truncate:SF (match_operand:DF 1 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "if (TARGET_HAVE_FPENTRY) {
+      emit_insn (gen__fpur64tor32 (operands[0], operands[1]));
+      DONE;
+    }
+ ")
+ 
+ (define_insn "_fpur64tor32"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (float_truncate:SF (match_operand:DF 1 "FABCreg_operand" "0")))
+    (clobber (match_scratch:SI 2 "=&r"))]
+   "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
+   "fpur64tor32")
+ 
+ (define_insn "_fpr64tor32"
+   [(set (match_operand:SF 0 "FABCreg_operand" "=t")
+         (float_truncate:SF (match_operand:DF 1 "FABCreg_operand" "0")))]
+   "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
+   "fpr64tor32")
+ 
+ 
+ ;;------------------------------
+ ;; extendMN
+ ;;------------------------------
+ 
+ (define_expand "extendqisi2"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (sign_extend:SI (match_operand:QI 1 "general_operand" "")))]
+   ""
+   "if (! TARGET_HAVE_XTEND) {
+      emit_insn (gen__ldc0x80_xword (operands[0], operands[1]));
+      DONE;
+    }
+ ")
+ 
+ (define_expand "extendhisi2"
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (sign_extend:SI (match_operand:HI 1 "general_operand" "")))]
+   ""
+   "if (! TARGET_HAVE_XTEND) {
+      if (TARGET_HAVE_SIXTEEN) {
+        emit_insn (gen__ls_ldc0x8000_xword (operands[0], operands[1]));
+      }
+      else {
+        emit_insn (gen__ldc0x8000_xword (operands[0], 
+                                         force_ABCreg (HImode, operands[1])));
+      }
+      DONE;
+    }
+ ")
+ 
+ /* xword requires its argument to be zero-extended to operate
+    correctly.  Real trap!  We don't have an easy way to tell if our
+    input has been zero-extended already, so we zero-extend here to be
+    safe.  Of course, we may end up zero-extending twice; the most
+    common case where this can happen is after an `lb', which already
+    zero-extends the byte.  We catch these common cases by providing
+    special alternatives for them --- works pretty well.  We still get
+    superfluous zero extending sometimes, especially when indexing
+    signed char arrays (920501-14.c, t800-unknown-parix), but such
+    cases are rare.  And modern processors (T450) don't have this
+    problem at all, using xbword. */
+ 
+ (define_insn "_ldc0x80_xword"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a,a,a")
+         (sign_extend:SI (match_operand:QI 1 "general_operand" "?a,S,R")))
+    (clobber (match_scratch:SI 2 "=&r,&r,&r"))]
+   "! TARGET_HAVE_XTEND"
+   "@
+    ldc 0xff\;and\;ldc 0x80\;xword
+    ldlp %w1\;lb\;ldc 0x80\;xword
+    lb\;ldc 0x80\;xword"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_insn "_ls_ldc0x8000_xword"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a,a,a")
+         (sign_extend:SI (match_operand:HI 1 "general_operand" "?a,S,R")))
+    (clobber (match_scratch:SI 2 "=&r,&r,&r"))]
+   "! TARGET_HAVE_XTEND && TARGET_HAVE_SIXTEEN"
+   "@
+    ldc 0xffff\;and\;ldc 0x8000\;xword
+    ldlp %w1\;ls\;ldc 0x8000\;xword
+    ls\;ldc 0x8000\;xword"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_insn "_ldc0x8000_xword"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (sign_extend:SI (match_operand:HI 1 "ABCreg_operand" "0")))
+    (clobber (match_scratch:SI 2 "=&r"))]
+   "! TARGET_HAVE_XTEND && ! TARGET_HAVE_SIXTEEN"
+   "ldc 0xffff\;and\;ldc 0x8000\;xword")
+ 
+ /* I think we can go with general_operand in insns which load
+    something onto regstack: reload should be able to use Areg (which
+    is the dest of the insn) for input reload, if one is necessary, so
+    this sloppiness won't cause extra spills.  */
+ 
+ (define_insn "_xbword_lbx"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a,a")
+         (sign_extend:SI (match_operand:QI 1 "general_operand" "?a,R")))]
+   "TARGET_HAVE_XTEND"
+   "@
+    xbword
+    lbx"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_insn "_xsword_lsx"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a,a")
+         (sign_extend:SI (match_operand:HI 1 "general_operand" "?a,R")))]
+   "TARGET_HAVE_XTEND && TARGET_HAVE_SIXTEEN"
+   "@
+    xsword
+    lsx"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ 
+ (define_insn "extendsidi2"
+   [(set (match_operand:DI 0 "ABCreg_operand" "=a")
+         (sign_extend:DI (match_operand:SI 1 "ABCreg_operand" "a")))]
+   ""
+   "xdble"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ 
+ (define_expand "extendsfdf2"
+   [(set (match_operand:DF 0 "FABCreg_operand" "")
+         (float_extend:DF (match_operand:SF 1 "FABCreg_operand" "")))]
+   "TARGET_HAVE_FPU"
+   "if (TARGET_HAVE_FPENTRY) {
+      emit_insn (gen__fpur32tor64 (operands[0], operands[1]));
+      DONE;
+    }
+ ")
+ 
+ (define_insn "_fpur32tor64"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (float_extend:DF (match_operand:SF 1 "FABCreg_operand" "0")))
+    (clobber (match_scratch:SI 2 "=&r"))]
+   "TARGET_HAVE_FPU && TARGET_HAVE_FPENTRY"
+   "fpur32tor64")
+ 
+ (define_insn "_fpr32tor64"
+   [(set (match_operand:DF 0 "FABCreg_operand" "=t")
+         (float_extend:DF (match_operand:SF 1 "FABCreg_operand" "0")))]
+   "TARGET_HAVE_FPU && ! TARGET_HAVE_FPENTRY"
+   "fpr32tor64")
+ 
+ 
+ ;;------------------------------
+ ;; zero_extendMN
+ ;;------------------------------
+ 
+ (define_expand "zero_extendqisi2"
+   [(parallel
+     [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (zero_extend:SI (match_operand:QI 1 "general_operand" "")))
+      (clobber (match_scratch:SI 2 ""))])]
+   ""
+   "{
+     if (GET_CODE (operands[1]) == MEM
+         && ! local_operand (operands[1], QImode))
+       {
+         /* Loading from memory in QImode (`lb') zero-extends the
+            loaded byte.  `lb' wants memory address in an ABCreg; Wreg
+            and suchlike won't do.  */
+ 
+         rtx addr = XEXP (operands[1], 0);
+ 
+         if (! ABCreg_operand (addr, SImode))
+           addr = copy_addr_to_reg (addr);
+ 
+         emit_insn (gen__lb (operands[0], gen_rtx (MEM, QImode, addr)));
+         DONE;
+       }
+     /* The pattern just below will match */
+   }")
+ 
+ 
+ /* This pattern is capable of using `lb' if the source register fails
+    to get a hard reg.  Note that local operand ('S') is always
+    word-aligned, so we don't need to go into "ldlp;adc" */
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a,a,a,a")
+ ; ?? general_operand seems to give slightly worse code.
+ ;        (zero_extend:SI (match_operand:QI 1 "general_operand" "R,S,U,a")))
+         (zero_extend:SI (match_operand:QI 1 "ABCreg_or_local_operand" "R,S,U,a")))
+    (clobber (match_scratch:SI 2 "=X,X,X,&r"))]
+   ""
+   "@
+    lb
+    ldlp %w1\;lb
+    ldnlp %w1\;lb
+    ldc 255\;and"
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_expand "zero_extendhisi2"
+    [(set (match_operand:SI 0 "ABCreg_operand" "")
+ ;         (and:SI (subreg:SI (match_operand:HI 1 "ABCreg_operand" "") 0)
+          (and:SI (match_operand:HI 1 "ABCreg_operand" "")
+                  (match_dup 2)))]
+   ""
+   "/* Tried to put subreg in the pattern, but that produced multiple
+       subregs if operand1 is already a subreg.  Let gen_lowpart do it right. */
+    operands[1] = gen_lowpart (SImode, operands[1]);
+    operands[2] = force_reg (SImode, GEN_INT (65535));")
+ 
+ 
+ ;;------------------------------
+ ;; extv
+ ;; extzv
+ ;; insv
+ ;;------------------------------
+ ;; N/A
+ 
+ 
+ ;;------------------------------
+ ;; sCOND
+ ;;------------------------------
+ 
+ (define_expand "seq"
+   [(match_operand:SI 0 "ABCreg_operand" "")]
+   ""
+   "t800_expand_scond (EQ, operands[0]); DONE;")
+ 
+ (define_expand "sne"
+   [(match_operand:SI 0 "ABCreg_operand" "")]
+   ""
+   "t800_expand_scond (NE, operands[0]); DONE;")
+ 
+ (define_expand "sle"
+   [(match_operand:SI 0 "ABCreg_operand" "")]
+   ""
+   "t800_expand_scond (LE, operands[0]); DONE;")
+ 
+ (define_expand "slt"
+   [(match_operand:SI 0 "ABCreg_operand" "")]
+   ""
+   "t800_expand_scond (LT, operands[0]); DONE;")
+ 
+ (define_expand "sge"
+   [(match_operand:SI 0 "ABCreg_operand" "")]
+   ""
+   "t800_expand_scond (GE, operands[0]); DONE;")
+ 
+ (define_expand "sgt"
+   [(match_operand:SI 0 "ABCreg_operand" "")]
+   ""
+   "t800_expand_scond (GT, operands[0]); DONE;")
+ 
+ (define_expand "sleu"
+   [(match_operand:SI 0 "ABCreg_operand" "")]
+   ""
+   "t800_expand_scond (LEU, operands[0]); DONE;")
+ 
+ (define_expand "sltu"
+   [(match_operand:SI 0 "ABCreg_operand" "")]
+   ""
+   "t800_expand_scond (LTU, operands[0]); DONE;")
+ 
+ (define_expand "sgeu"
+   [(match_operand:SI 0 "ABCreg_operand" "")]
+   ""
+   "t800_expand_scond (GEU, operands[0]); DONE;")
+ 
+ (define_expand "sgtu"
+   [(match_operand:SI 0 "ABCreg_operand" "")]
+   ""
+   "t800_expand_scond (GTU, operands[0]); DONE;")
+ 
+ 
+ /*
+  * DEFINE_INSNs for compaisons
+  */
+ 
+ (define_insn "_eqc"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (eq:SI (match_operand:SI 1 "ABCreg_operand" "0")
+                (match_operand:SI 2 "const_int_operand" "")))]
+   ""
+   "eqc %2")
+ 
+ 
+ (define_insn "_gt"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (gt:SI (match_operand:SI 1 "ABCreg_operand" "b")
+                (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "T800_DISTINCT_REGS (operands[1], operands[2])"
+   "gt"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_insn "_gtu"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (gtu:SI (match_operand:SI 1 "ABCreg_operand" "b")
+                 (match_operand:SI 2 "ABCreg_operand" "a")))]
+   "TARGET_HAVE_GTU
+    && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "gtu"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ /* Substract with borrow.  Used in implementation of unsigned
+    comparisons on transputers that lack the `gtu' instruction */
+ 
+ (define_insn "_ldiff"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=b")
+         (ltu:DI
+           (zero_extend:DI (match_operand:SI 2 "ABCreg_operand" "b"))
+           (plus:DI
+             (zero_extend:DI (match_operand:SI 3 "ABCreg_operand" "a"))
+             (zero_extend:DI (and:SI
+                               (match_operand:SI 4 "ABCreg_operand" "c")
+                               (const_int 1))))))
+    (set (match_operand:SI 1 "ABCreg_operand" "=a")
+         (truncate:SI
+           (minus:DI (zero_extend:DI (match_dup 2))
+                     (plus:DI (zero_extend:DI (match_dup 3))
+                              (zero_extend:DI (and:SI (match_dup 4)
+                                                       (const_int 1)))))))]
+   "T800_DISTINCT_REGS (operands[2], operands[3])
+    && T800_DISTINCT_REGS (operands[3], operands[4])
+    && T800_DISTINCT_REGS (operands[2], operands[4])"
+   "ldiff"
+   [(set (attr "popped_inputs") (const_int 28))])
+ 
+ 
+ /* Used to have (eq:SF ...) here, but it would produce unrecognizable
+    insn for gen__fpeq (result, DF_operand1, DF_operand2); */
+ 
+ (define_insn "_fpeq"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (eq (match_operand:SF 1 "FABCreg_operand" "%u")
+             (match_operand:SF 2 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpeq"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (eq (match_operand:DF 1 "FABCreg_operand" "%u")
+             (match_operand:DF 2 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpeq"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ (define_insn "_fpgt"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (gt (match_operand:SF 1 "FABCreg_operand" "u")
+             (match_operand:SF 2 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpgt"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (gt (match_operand:DF 1 "FABCreg_operand" "u")
+             (match_operand:DF 2 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpgt"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ (define_insn "_fpge"
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (ge (match_operand:SF 1 "FABCreg_operand" "u")
+             (match_operand:SF 2 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU
+    && TARGET_HAVE_FPGE
+    && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpge"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ (define_insn ""
+   [(set (match_operand:SI 0 "ABCreg_operand" "=a")
+         (ge (match_operand:DF 1 "FABCreg_operand" "u")
+             (match_operand:DF 2 "FABCreg_operand" "t")))]
+   "TARGET_HAVE_FPU
+    && TARGET_HAVE_FPGE
+    && T800_DISTINCT_REGS (operands[1], operands[2])"
+   "fpge"
+   [(set (attr "popped_inputs") (const_int 6))])
+ 
+ 
+ ;;------------------------------
+ ;; bCOND
+ ;;------------------------------
+ 
+ (define_expand "beq"
+   [(match_operand 0 "" "")]
+   ""
+   "t800_expand_bcond (EQ, operands[0]); DONE;")
+ 
+ (define_expand "bne"
+   [(match_operand 0 "" "")]
+   ""
+   "t800_expand_bcond (NE, operands[0]); DONE;")
+ 
+ (define_expand "ble"
+   [(match_operand 0 "" "")]
+   ""
+   "t800_expand_bcond (LE, operands[0]); DONE;")
+ 
+ (define_expand "blt"
+   [(match_operand 0 "" "")]
+   ""
+   "t800_expand_bcond (LT, operands[0]); DONE;")
+ 
+ (define_expand "bge"
+   [(match_operand 0 "" "")]
+   ""
+   "t800_expand_bcond (GE, operands[0]); DONE;")
+ 
+ (define_expand "bgt"
+   [(match_operand 0 "" "")]
+   ""
+   "t800_expand_bcond (GT, operands[0]); DONE;")
+ 
+ (define_expand "bleu"
+   [(match_operand 0 "" "")]
+   ""
+   "t800_expand_bcond (LEU, operands[0]); DONE;")
+ 
+ (define_expand "bltu"
+   [(match_operand 0 "" "")]
+   ""
+   "t800_expand_bcond (LTU, operands[0]); DONE;")
+ 
+ (define_expand "bgeu"
+   [(match_operand 0 "" "")]
+   ""
+   "t800_expand_bcond (GEU, operands[0]); DONE;")
+ 
+ (define_expand "bgtu"
+   [(match_operand 0 "" "")]
+   ""
+   "t800_expand_bcond (GTU, operands[0]); DONE;")
+ 
+ 
+ /*
+  * DEFINE_INSNs for conditional branches
+  */
+ 
+ (define_insn "_cj"
+   [(set (pc) (if_then_else (eq:SI (match_operand:SI 1 "ABCreg_operand" "a")
+                                   (const_int 0))
+                            (label_ref (match_operand 0 "" ""))
+                            (pc)))]
+   ""
+   "cj %l0"
+   [(set (attr "popped_inputs") (const_int 2))
+    (set (attr "popped_inputs_on_jump") (const_int 0))])
+ 
+ /* Reverse-conditional branch pattern *must* be defined for
+    invert_jump() to work properly. */
+ 
+ (define_insn "_inv_cj"
+   [(set (pc) (if_then_else (eq:SI (match_operand:SI 1 "ABCreg_operand" "a")
+                                   (const_int 0))
+                            (pc)
+                            (label_ref (match_operand 0 "" ""))))]
+   ""
+   "eqc 0\;cj %l0"
+   [(set (attr "popped_inputs") (const_int 2))
+    (set (attr "popped_inputs_on_jump") (const_int 0))])
+ 
+ ;;------------------------------
+ ;; call
+ ;; call_value
+ ;;------------------------------
+ 
+ /* operands[0] is the function to call
+    operands[1] is the number of args passed on stack;
+    operands[2] is next_arg_reg.
+    operands[3] is stack_size_rtx  */
+ 
+ (define_expand "call"
+   [(match_operand:QI 0 "memory_operand" "")
+    (match_operand:SI 1 "" "")
+    (match_operand:SI 2 "" "")
+    (match_operand:SI 3 "" "")]
+   ""
+   "t800_expand_call(NULL_RTX, operands[0], operands[1], operands[2],
+                     operands[3]); DONE;")
+ 
+ (define_expand "call_value"
+ ; Operand 0 may be any register, including floating ones.
+   [(match_operand  0 "register_operand" "")
+    (match_operand:QI 1 "memory_operand" "")
+    (match_operand:SI 2 "" "")
+    (match_operand:SI 3 "" "")
+    (match_operand:SI 4 "" "")]
+   ""
+   "t800_expand_call(operands[0], operands[1], operands[2], operands[3],
+                     operands[4]); DONE;")
+ 
+ (define_insn "_call"
+   [(set (match_operand 0 "ABCreg_operand" "=a")
+         (call (mem:QI (match_operand:SI 1 "immediate_operand" ""))
+               (match_operand:SI 2 "" "")))]
+   ""
+   "*
+ #ifdef T800_OUTPUT__CALL
+   T800_OUTPUT__CALL;
+ #else
+   return \"call %1\";
+ #endif
+ ")
+ 
+ (define_insn ""
+   [(set (match_operand 0 "FABCreg_operand" "=t")
+         (call (mem:QI (match_operand:SI 1 "immediate_operand" ""))
+               (match_operand:SI 2 "" "")))]
+   ""
+   "*
+ #ifdef T800_OUTPUT__CALL
+   T800_OUTPUT__CALL;
+ #else
+   return \"call %1\";
+ #endif
+ ")
+ 
+ /* Unlike `call', `gcall' does not save the return address on the
+    stack.  Therefore we do this by hand: calculate the return address
+    and push it onto the stack.
+ 
+    Further, one cannot pass args on registers to gcall, because this
+    would leave no room for function address.  FUNCTION_ARG arranges
+    for args being passed on stack; but this has its caveat.  When
+    callee returns with `ret', it will pop return address and *three
+    more words* off the stack; so we have to `ajw' after the call to
+    compensate for this.  (Looks strange when this `ajw' happens just
+    before `ajw +NNN; ret'.  Use peephole?)
+ 
+    Note: sizeof(stl 0)==1, sizeof(gcall)==1, hence `ldc 2'.  We could
+    do this reliably with labels, but some assemblers (Parix) don't
+    handle label substraction well.
+ 
+    `unspec' in `gcall' pattern makes it differ from the `call' pattern,
+    so optimizers won't substitute the latter for the former when gcall
+    is used with symbol_ref operand: such substitution would be wrong
+    because `call' pushes registers, `gcall' does not.  */
+ 
+ (define_insn "_gcall"
+   [(set (match_operand 0 "ABCreg_operand" "=a,a")
+         (call (mem:QI (match_operand:SI 1 "nonmemory_operand" "a,i"))
+               (match_operand:SI 2 "" "")))
+    (unspec [(const_int 0)] 1)]
+   ""
+   "*
+ #ifdef T800_OUTPUT__GCALL
+   T800_OUTPUT__GCALL;
+ #else
+   return which_alternative ? \"ajw -1\;ldc 2\;ldpi\;stl 0\;j %1\;ajw -3\"
+                            : \"ajw -1\;ldc 2\;ldpi\;stl 0\;gcall\;ajw -3\";
+ #endif
+ "
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ (define_insn ""
+   [(set (match_operand 0 "FABCreg_operand" "=t,t")
+         (call (mem:QI (match_operand:SI 1 "nonmemory_operand" "a,i"))
+               (match_operand:SI 2 "" "")))
+    (unspec [(const_int 0)] 1)]
+   ""
+   "*
+ #ifdef T800_OUTPUT__GCALL
+   T800_OUTPUT__GCALL;
+ #else
+   return which_alternative ? \"ajw -1\;ldc 2\;ldpi\;stl 0\;j %1\;ajw -3\"
+                            : \"ajw -1\;ldc 2\;ldpi\;stl 0\;gcall\;ajw -3\";
+ #endif
+ "
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ /* _gcall_aggregate is a variation of normal _gcall used for models
+    which pass struct return address in Areg, so that function address
+    has to come in Breg instead. */
+ 
+ (define_insn "_gcall_aggregate"
+   [(set (match_operand 0 "ABCreg_operand" "=a,a")
+         (call:CC (mem:QI (match_operand:SI 1 "nonmemory_operand" "b,i"))
+                  (match_operand:SI 2 "" "")))
+    (unspec [(const_int 0)] 2)]
+   ""
+   "*
+ #ifdef T800_OUTPUT__GCALL
+   T800_OUTPUT__GCALL;
+ #else
+   return which_alternative ? \"ajw -1\;ldc 2\;ldpi\;stl 0\;j %1\;ajw -3\"
+                            : \"ajw -1\;ldc 2\;ldpi\;stl 0\;gcall\;ajw -3\";
+ #endif
+ "
+   [(set (attr "popped_inputs") (const_int 2))])
+ 
+ 
+ ;;------------------------------
+ ;; call_pop
+ ;; call_value_pop
+ ;;------------------------------
+ ;; N/A
+ 
+ 
+ ;;------------------------------
+ ;; return
+ ;;------------------------------
+ 
+ /* We have to use `return' pattern rather than jump to epilogue, as
+    the jump insn clobbers all stack regs, including the one that
+    carries a return value.  */
+ 
+ (define_insn "return"
+   [(return)]
+   ""
+   "*
+   T800_OUTPUT_RETURN;
+ ")
+ 
+ ;;------------------------------
+ ;; nop
+ ;;------------------------------
+ 
+ (define_insn "nop"
+   [(const_int 0)]
+   ""
+   "*
+ #ifdef T800_OUTPUT_NOP
+   T800_OUTPUT_NOP;
+ #else
+   return \"pfix 0\";
+ #endif
+ ")
+ 
+ ;;------------------------------
+ ;; jump
+ ;;------------------------------
+ 
+ /* The `j' insn may cause descheduling of current process, which does
+    not preserve any reg besides Iptr and Wreg. */
+ 
+ (define_insn "jump"
+   [(set (pc) (label_ref (match_operand 0 "" "")))
+    (clobber (reg:SI 0))
+    (clobber (reg:SI 1))
+    (clobber (reg:SI 2))
+    (clobber (reg:SF 3))
+    (clobber (reg:SF 4))
+    (clobber (reg:SF 5))]
+   ""
+   "j %l0")
+ 
+ ;;------------------------------
+ ;; indirect_jump
+ ;;------------------------------
+ 
+ /* JUMP_INSNs are not allowed to have output reloads. To be compliant
+    with this requirement, we have to use
+ 
+      (clobber (match_dup 0))  rather than
+      (set (match_dup 0) (pc))
+ 
+    The old value of (pc) isn't likely to be used anyway.  */
+ 
+ (define_insn "indirect_jump"
+   [(set (pc) (match_operand:SI 0 "ABCreg_operand" "a"))
+    (clobber (match_dup 0))]
+   ""
+   "gcall")
+ 
+ ;;------------------------------
+ ;; casesi
+ ;;------------------------------
+ 
+ /* Some points to explain why tablejumping is not so easy on transputers.
+ 
+    1. We cannot use absolute casetables because on Parix there are no
+       load-time fixups: by definition .word Lxxx initializes the word
+       with the *offset* from the beginning of the text segment to
+       Lxxx, not with the absolute address of Lxxx.  So we must use
+       relative casetables, and have `ldpi' in tablejump or equivalent
+       to convert the offset fetched from the table into an address to
+       `gcall' to.
+ 
+    2. We must insert .align 4 before the table because word accesses
+       only work at a word boundary.  Therefore we have a gap of
+       uncertain length between `ldpi;gcall' and the table label.
+       So the distance from ldpi to table_label is nonconstant (until
+       assembling, of course, but that doesn't help).
+ 
+    3. We could use `adc ldpi_label-table_label' before lpdi to
+       compensate for the gap.  But Parix assembler dives a warning on
+       label difference arguments to adc.
+ 
+    4. Output reloads can break neighbourhood of ldpi and the
+       code_label emitted just after it, if the label is made a
+       separate insn.
+ 
+    We use casesi instead of tablejump to be able to do a trick.  We
+    want to use two labels instead of single table_label.  One label
+    (table_label) is placed just before the table as usual, and is used
+    to access the table.  The other label (table_rel_label) is the label
+    which offsets are relative to, and it is placed after a ldpi in the
+    jumping code.
+ 
+    This two-label scheme saves us an adc -- in addition, an adc with a
+    label-difference argument which causes a warning (!?) on certain
+    assemblers... Parix, right.
+ 
+    Here is what we want to generate:
+ 
+         [normalize index, check bounds, scale to word offset,
+          compute table elt address and then...]
+ 	ldnl 0
+         ldpi
+ table_rel_label:
+         gcall
+         .align 4
+ table_label:
+         .word Lcase1-table_rel_label
+         .word Lcase2-table_rel_label
+ 	...
+ 
+    Note that table_rel_label does not exist as a separate insn, but is
+    generated as a permutation of table_label in final pass.  (Making
+    table_rel_label a separate insn is not good because this would cut
+    the tablejumping code in two separate basic blocks, which hinders
+    optimization).  But hiding the table_rel_label, in turn, poses a
+    problem: on some patological programs (920917-1.c is an example)
+    optimizers may delete the tablejump insn (which is responsible for
+    outputting table_rel_label) but leaving the table intact.  The
+    resulting code is not assemblable because the table refers to
+    table_rel_label, which does not exist.
+ 
+    We work around this problem by having the tablejump output routine
+    recording the label number in t800_expect_table_label, and
+    suppressing ASM_OUTPUT_ADDR_DIFF_ELT if the recorded label number
+    doesn't match one of the table being output.  The proper fix would
+    be to make GCC optimize away either both table jump and the table,
+    or none of them... but I don't feel brave enough at the moment. ;-)  */
+ 
+ (define_expand "casesi"
+   [(match_operand:SI 0 "ABCreg_operand" "a")	; index
+    (match_operand:SI 1 "const_int_operand" "")	; lower bound
+    (match_operand:SI 2 "const_int_operand" "")	; highest index in table
+    (match_operand:SI 3 "" "")			; table_label
+    (match_operand:SI 4 "" "")]			; default_label
+   ""
+   "{
+ #define INDEX operands[0]
+ #define LOWER_BOUND operands[1]
+ #define HIGHEST_INDEX operands[2]
+ #define TABLE_LABEL operands[3]
+ #define DEFAULT_LABEL operands[4]
+ 
+   rtx table_index = gen_reg_rtx (SImode);
+ 
+   emit_insn (gen__adc (table_index, INDEX, GEN_INT (- INTVAL (LOWER_BOUND))));
+ 
+   /* mimic two lines from do_tablejump */
+   emit_cmp_insn (table_index, HIGHEST_INDEX, GTU, NULL_RTX, SImode, 1, 0);
+   emit_jump_insn (gen_bgtu (DEFAULT_LABEL));
+ 
+   emit_jump_insn (gen__my_fancy_tablejump (table_index, TABLE_LABEL));
+ 
+   DONE;
+ #undef INDEX
+ #undef LOWER_BOUND
+ #undef HIGHEST_INDEX
+ #undef TABLE_LABEL
+ #undef DEFAULT_LABEL
+ }")
+ 
+ (define_insn "_my_fancy_tablejump"
+   [(set (pc)
+         (plus:SI (label_ref:SI (match_operand 1 "" ""))
+                  (mem:SI
+                    (plus:SI (label_ref:SI (match_dup 1))
+                             (mult:SI (match_operand:SI 0 "ABCreg_operand" "a")
+                                      (const_int 4))))))
+ ; The clobber below would help us to be 100% correct: this insn
+ ; actually replaces its arg with... hmmm... some other value, and we
+ ; should let the compiler know about this.  But adding this clobber
+ ; scares cse and it fails to optimize the switching code in the case
+ ; of index expression being a constant.  Therefore I leave the clobber
+ ; out; I cannot imagine a situation where the compiler could try to
+ ; reuse the table index which is allegedly left in Areg.
+ ;   (clobber (match_dup 0))
+ 
+    (clobber (match_scratch:SI 2 "=&r"))
+   ]
+   ""
+   "*{
+   /* Leave a note for ASM_OUTPUT_ADDR_DIFF_ELT */
+   extern int t800_expected_table_label;
+   t800_expected_table_label = CODE_LABEL_NUMBER (operands[1]);
+ 
+ #ifdef T800_LDC_SYMBOL_PC_RELATIVE
+   return \"ldc %1-2\;ldpi\;wsub\;ldnl 0\;ldpi\\n%1a:\;gcall\";
+ #else
+   return \"ldc %1-LF%=\;ldpi\\nLF%=:\;wsub\;ldnl 0\;ldpi\\n%1a:\;gcall\";
+ #endif
+ }")
+ 
+ ;;------------------------------
+ ;; tablejump
+ ;;------------------------------
+ 
+ ; we use casesi now
+ 
+ ;;------------------------------
+ ;; allocate_stack
+ ;;------------------------------
+ 
+ (define_expand "allocate_stack"
+   [(match_operand:SI 0 "general_operand" "")]
+   ""
+   "
+ #ifdef T800_EXPAND_ALLOCATE_STACK
+   T800_EXPAND_ALLOCATE_STACK;
+ #else /* not T800_EXPAND_ALLOCATE_STACK */
+ {
+     rtx size;
+ 
+     /* Increase the adjustment requested by the space necessary for
+        (1) firmware reserved area below Wreg (2) save slot where the
+        normal value of Wreg is saved during calls and (3) outgoing args */
+     if (GET_CODE (operands[0]) == CONST_INT) {
+       size = GEN_INT (INTVAL (operands[0])
+                       + WORKSPACE_RESERVED_BYTES
+                       + UNITS_PER_WORD  /* save slot */
+                       + WORD_ROUND (current_function_outgoing_args_size));
+     }
+     else {
+       size = gen_rtx (PLUS, Pmode,
+                       operands[0],
+                       GEN_INT (WORKSPACE_RESERVED_BYTES
+                                + UNITS_PER_WORD  /* save slot */
+                                + WORD_ROUND (current_function_outgoing_args_size)));
+     }
+     anti_adjust_stack (size);
+     DONE;
+ }
+ #endif /* not T800_EXPAND_ALLOCATE_STACK */
+ ")
+ 
+ ;;--------------------------------------------------------------------------
+ ;; peephole optimization definitions
+ ;;--------------------------------------------------------------------------
+ 
+ /* get rid of unnecessary stack reordering sometimes generated by
+    stack-reg converter.  We could try to make the converter smarter to
+    avoid generating this, but it seems simpler to leave it as it is and
+    remove the redundancy with peephole optimizer.  */
+ 
+ /* dup; ldc NNN; stl -1; rev; ldl -1  =>  dup; ldc NNN */
+ 
+ (define_peephole
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (match_operand:SI 1 "ABCreg_operand" ""))
+    (set (match_operand:SI 2 "ABCreg_operand" "")
+         (match_operand:SI 3 "const_int_operand" ""))
+    (set (mem:SI (plus:SI (reg:SI 6) (const_int -4)))
+         (match_operand:SI 4 "ABCreg_operand" ""))
+    (parallel[(set (match_operand:SI 5 "ABCreg_operand" "")
+                   (match_operand:SI 6 "ABCreg_operand" ""))
+              (set (match_dup 6)
+                   (match_dup 5))])
+    (set (match_operand:SI 7 "ABCreg_operand" "")
+         (mem:SI (plus:SI (reg:SI 6) (const_int -4))))]
+   ""
+   "*return INTVAL (operands[1]) == 0x80000000
+       ? \"dup\;mint\"
+       : \"dup\;ldc %3\";
+ ")
+ 
+ /* dup; ldl NNN; stl -1; rev; ldl -1  =>  dup; ldl NNN */
+ 
+ (define_peephole
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (match_operand:SI 1 "ABCreg_operand" ""))
+    (set (match_operand:SI 2 "ABCreg_operand" "")
+         (match_operand:SI 3 "local_operand" ""))
+    (set (mem:SI (plus:SI (reg:SI 6) (const_int -4)))
+         (match_operand:SI 4 "ABCreg_operand" ""))
+    (parallel[(set (match_operand:SI 5 "ABCreg_operand" "")
+                   (match_operand:SI 6 "ABCreg_operand" ""))
+              (set (match_dup 6)
+                   (match_dup 5))])
+    (set (match_operand:SI 7 "ABCreg_operand" "")
+         (mem:SI (plus:SI (reg:SI 6) (const_int -4))))]
+   ""
+   "dup\;ldl %w3")
+ 
+ /* ldc NNN; stl -1; rev; ldl -1  =>  rev; ldc NNN */
+ 
+ (define_peephole
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (match_operand:SI 1 "const_int_operand" ""))
+    (set (mem:SI (plus:SI (reg:SI 6) (const_int -4)))
+         (match_operand:SI 2 "ABCreg_operand" ""))
+    (parallel[(set (match_operand:SI 3 "ABCreg_operand" "")
+                   (match_operand:SI 4 "ABCreg_operand" ""))
+              (set (match_dup 4)
+                   (match_dup 3))])
+    (set (match_operand:SI 5 "ABCreg_operand" "")
+         (mem:SI (plus:SI (reg:SI 6) (const_int -4))))]
+   ""
+   "*return INTVAL (operands[1]) == 0x80000000
+       ? \"rev\;mint\"
+       : \"rev\;ldc %1\";
+ ")
+ 
+ /* ldl NNN; stl -1; rev; ldl -1  =>  rev; ldl NNN */
+ 
+ (define_peephole
+   [(set (match_operand:SI 0 "ABCreg_operand" "")
+         (match_operand:SI 1 "local_operand" ""))
+    (set (mem:SI (plus:SI (reg:SI 6) (const_int -4)))
+         (match_operand:SI 2 "ABCreg_operand" ""))
+    (parallel[(set (match_operand:SI 3 "ABCreg_operand" "")
+                   (match_operand:SI 4 "ABCreg_operand" ""))
+              (set (match_dup 4)
+                   (match_dup 3))])
+    (set (match_operand:SI 5 "ABCreg_operand" "")
+         (mem:SI (plus:SI (reg:SI 6) (const_int -4))))]
+   ""
+   "rev\;ldl %w1")
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/config/t800/xm-t800.h gcc-2.7.2-t800.12/config/t800/xm-t800.h
*** gcc-2.7.2/config/t800/xm-t800.h	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/config/t800/xm-t800.h	Mon Jan 22 11:36:24 1996
***************
*** 0 ****
--- 1,5 ----
+ /* Well, T800 seems to be long way from use as host machine for GCC
+    compilation.  Therefore, all we need to do here is to include the
+    target machine description file.  */
+ 
+ #include "tm.h"
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/config.sub gcc-2.7.2-t800.12/config.sub
*** gcc-2.7.2/config.sub	Fri Jun 16 01:01:30 1995
--- gcc-2.7.2-t800.12/config.sub	Mon Jan 22 13:23:16 1996
***************
*** 136,139 ****
--- 136,140 ----
  		| powerpc | powerpcle | sparc64 | 1750a | dsp16xx | mips64 | mipsel \
  		| pdp11 | mips64el | mips64orion | mips64orionel \
+ 		| t800 | t9000 \
  		| sparc)
  		basic_machine=$basic_machine-unknown
***************
*** 656,659 ****
--- 657,663 ----
  	-osf*)
  		os=-osf
+ 		;;
+ 	-parix*)
+ 		os=-parix
  		;;
  	-utek*)
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/configure gcc-2.7.2-t800.12/configure
*** gcc-2.7.2/configure	Sun Nov 26 22:38:56 1995
--- gcc-2.7.2-t800.12/configure	Sun Feb 11 17:03:40 1996
***************
*** 2373,2376 ****
--- 2373,2400 ----
  		use_collect2=yes
  		;;
+ 	t800-*-parix)
+ 		tm_file=t800/expert.h
+ 		tmake_file=t-parix
+ 		target_cpu_default=800
+ 		;;
+ 	t800-*-*)
+ 		target_cpu_default=800
+ 		;;
+ 	t805-*-*)
+ 		cpu_type=t800
+ 		target_cpu_default=805
+ 		;;
+ 	t425-*-*)
+ 		cpu_type=t800
+ 		target_cpu_default=425
+ 		;;
+ 	t450-*-*)
+ 		cpu_type=t800
+ 		target_cpu_default=450
+ 		;;
+ 	t9000-*-*)
+ 		cpu_type=t800
+ 		target_cpu_default=9000
+ 		;;
  	*)
  		echo "Configuration $machine not supported" 1>&2
***************
*** 2790,2802 ****
  		rm -f Makefile.xx
  	  	(if [ x$host = x$build ] ; then
! 			echo "MD_DEPS = $(md_file) cpp" ; echo "MD_CPP = ./cpp"
  		else
! 			echo "MD_DEPS = md.pre-cpp" ; echo "MD_CPP = \$(HOST_CC) -x c -E"
  		fi
! 		md_file=md
! 		echo "MD_CPPFLAGS = $md_cppflags") | \
! 		  cat - Makefile.tem | sed -e "s|^MD_FILE[ 	]*=.*|MD_FILE = md|" > Makefile.xx
  		rm -f Makefile.tem
  		mv Makefile.xx Makefile.tem
  	fi
  	
--- 2814,2830 ----
  		rm -f Makefile.xx
  	  	(if [ x$host = x$build ] ; then
! 			echo "MD_DEPS = \$(MD_PRE_CPP) cpp"
! 			echo "MD_CPP = ./cpp"
  		else
! 			echo "MD_DEPS = \$(MD_PRE_CPP)"
! 			echo "MD_CPP = \$(HOST_CC) -x c -E"
  		fi
! 		echo "MD_CPPFLAGS = $md_cppflags"
! 		echo "MD_PRE_CPP = $srcdir/config/$md_file") | \
! 		  cat - Makefile.tem | \
! 		  sed -e "s|^MD_FILE[ 	]*=.*|MD_FILE = md|" > Makefile.xx
  		rm -f Makefile.tem
  		mv Makefile.xx Makefile.tem
+ 		md_file=md
  	fi
  	
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/cp/Make-lang.in gcc-2.7.2-t800.12/cp/Make-lang.in
*** gcc-2.7.2/cp/Make-lang.in	Wed Sep 13 01:15:33 1995
--- gcc-2.7.2-t800.12/cp/Make-lang.in	Mon Jan 22 11:36:25 1996
***************
*** 190,196 ****
  # distribution anyway.  It then copies the files to the distdir directory.
  c++.distdir:
! 	mkdir tmp/cp
! 	cd cp ; $(MAKE) $(FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) parse.c hash.h
! 	cd cp; \
  	for file in *[0-9a-zA-Z+]; do \
  	  ln $$file ../tmp/cp >/dev/null 2>&1 || cp $$file ../tmp/cp; \
--- 190,196 ----
  # distribution anyway.  It then copies the files to the distdir directory.
  c++.distdir:
! 	mkdir $(srcdir)/tmp/cp
! 	cd $(srcdir)/cp ; $(MAKE) $(FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) parse.c hash.h
! 	cd $(srcdir)/cp; \
  	for file in *[0-9a-zA-Z+]; do \
  	  ln $$file ../tmp/cp >/dev/null 2>&1 || cp $$file ../tmp/cp; \
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/cse.c gcc-2.7.2-t800.12/cse.c
*** gcc-2.7.2/cse.c	Sun Nov 26 22:46:46 1995
--- gcc-2.7.2-t800.12/cse.c	Mon Jan 22 11:36:25 1996
***************
*** 7346,7349 ****
--- 7346,7358 ----
  	  dest = SUBREG_REG (XEXP (dest, 0));
  
+         /* If DEST is a paradoxical subreg, insert the true reg in its
+            natural mode rather than in the SUBREG mode, since only
+            the bits that belong to the natural mode are actually
+            stored in DEST.  */
+         if (GET_CODE (dest) == SUBREG
+             && GET_MODE_SIZE (GET_MODE (dest))
+                > GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))))
+ 	  dest = SUBREG_REG (dest);
+ 
  	if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG)
  	  /* Registers must also be inserted into chains for quantities.  */
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/emit-rtl.c gcc-2.7.2-t800.12/emit-rtl.c
*** gcc-2.7.2/emit-rtl.c	Fri Sep 15 00:09:11 1995
--- gcc-2.7.2-t800.12/emit-rtl.c	Fri Feb 16 18:55:51 1996
***************
*** 150,154 ****
     In an inline procedure, the stack and frame pointer rtxs may not be
     used for anything else.  */
! rtx stack_pointer_rtx;		/* (REG:Pmode STACK_POINTER_REGNUM) */
  rtx frame_pointer_rtx;		/* (REG:Pmode FRAME_POINTER_REGNUM) */
  rtx hard_frame_pointer_rtx;	/* (REG:Pmode HARD_FRAME_POINTER_REGNUM) */
--- 150,155 ----
     In an inline procedure, the stack and frame pointer rtxs may not be
     used for anything else.  */
! rtx stack_pointer_rtx;		/* (REG:Pmode STACK_POINTER_REGNUM or pseudo) */
! rtx hard_stack_pointer_rtx;	/* (REG:Pmode STACK_POINTER_REGNUM) */
  rtx frame_pointer_rtx;		/* (REG:Pmode FRAME_POINTER_REGNUM) */
  rtx hard_frame_pointer_rtx;	/* (REG:Pmode HARD_FRAME_POINTER_REGNUM) */
***************
*** 3376,3379 ****
--- 3377,3384 ----
      const_tiny_rtx[0][(int) mode] = const0_rtx;
  
+ #ifdef PSEUDO_STACK_POINTER
+   hard_stack_pointer_rtx
+                     = gen_rtx (REG, Pmode, STACK_POINTER_REGNUM);
+ #endif
    stack_pointer_rtx = gen_rtx (REG, Pmode, STACK_POINTER_REGNUM);
    frame_pointer_rtx = gen_rtx (REG, Pmode, FRAME_POINTER_REGNUM);
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/exotic.c gcc-2.7.2-t800.12/exotic.c
*** gcc-2.7.2/exotic.c	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/exotic.c	Mon Jan 22 11:36:26 1996
***************
*** 0 ****
--- 1,230 ----
+ /* Optional RTL-fixing pass for GNU compiler.
+    Copyright (C) 1994 Free Software Foundation, Inc.
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
+ 
+ 
+ /* This file performs a pass over the RTL code, adopting it to various
+    strange requirements of certain processors.
+ 
+    (`Certain' means T800 and relatives for now)
+ 
+    Condition 1.  Certain machines require the arguments for a binary
+    insns to be in distinct registers.  If we find an insn like `add
+    Rx,Rx', we convert it by creating new pseudo and emitting the insn
+    to copy the operand into it just before that insn.
+ 
+    Condition 2.  Certain machines require every register to be used
+    just once, as the value in a register is destroyed by the use.
+    (** we do nothing for them here now, but instead force them to
+     stack slots during register allocation.  */
+ 
+ #include <stdio.h>
+ #include "config.h"
+ #include "rtl.h"
+ #include "insn-config.h"
+ #include "recog.h"
+ 
+ static void fix_multiple_reg_references PROTO((rtx, int, int, char *const *,
+ 					       int));
+ 
+ /* Set to 1 by toplev once the exotic pass has been run. */
+ 
+ int exotic_completed = 0;
+ 
+ 
+ void
+ exotic (insns, nregs)
+      rtx insns;
+      int nregs;
+ {
+ #ifdef EXOTIC_PASS
+   rtx insn;
+ 
+   for (insn = insns; insn; insn = NEXT_INSN (insn))
+     {
+       /* Skip non-insns */
+       if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')
+ 	continue;
+ 
+       switch (GET_CODE (PATTERN (insn)))
+ 	{
+ 	case USE:
+ 	case CLOBBER:
+ 	case ASM_INPUT:
+ 	case ADDR_VEC:
+ 	case ADDR_DIFF_VEC:
+ 	  continue;
+ 	}
+ 
+       find_multiple_reg_references (insn, fix_multiple_reg_references);
+     }
+ }
+ 
+ 
+ /* Check is there is a pseudo mentioned in more than one input operand
+    of the INSN.  For every pair of operands referencing the same reg
+    FUN is called with INSN and numbers of the operands as its arguments.
+    Return 1 is multiple uses foung, 0 otherwise.
+ 
+    This is also called from recog_for_combine.  */
+ 
+ int
+ find_multiple_reg_references (insn, fun)
+      rtx insn;
+      void (*fun) PROTO((rtx, int, int, char *const *, int));
+ {
+   rtx op1, op2;
+   int i, j;
+   int found = 0;
+   char *const *constraints;
+   int n_operands, n_dups;
+ 
+   n_operands = asm_noperands (PATTERN (insn));
+   if (n_operands >= 0)
+     {
+       /* This insn is an `asm' with operands.  */
+ 
+       /* expand_asm_operands makes sure there aren't too many operands.  */
+       if (n_operands > MAX_RECOG_OPERANDS)
+ 	abort ();
+ 
+       constraints = (char **) alloca (n_operands * sizeof (char *));
+       decode_asm_operands (PATTERN (insn), recog_operand, recog_operand_loc,
+ 			   (char **)constraints, NULL_PTR);
+       n_dups = 0;
+     }
+   else
+     {
+       /* Ordinary insn */
+ 
+       int insn_code = recog_memoized (insn);
+       if (insn_code < 0)
+         fatal_insn_not_found (insn);
+ 
+       n_operands = insn_n_operands[insn_code];
+       constraints = insn_operand_constraint[insn_code];
+       insn_extract (insn);
+       n_dups = insn_n_dups[insn_code];
+     }
+ 
+   for (i = n_operands - 1; i >= 0; i--)
+     {
+       /* Don't consider output operands */
+       if (constraints[i][0] == '=')
+ 	continue;
+ 
+       op1 = recog_operand[i];
+       if (GET_CODE (op1) == SUBREG)
+ 	op1 = SUBREG_REG (op1);
+       if (GET_CODE (op1) != REG)
+ 	continue;
+ 
+       for (j = i - 1; j >= 0; j--)
+ 	{
+ 	  if (constraints[j][0] == '=')
+ 	    continue;
+ 
+ 	  op2 = recog_operand[j];
+ 	  if (GET_CODE (op2) == SUBREG)
+ 	    op2 = SUBREG_REG (op2);
+ 	  if (GET_CODE (op2) != REG)
+ 	    continue;
+ 
+ 	  if (REGNO (op1) == REGNO (op2)
+ 	      && REGNO (op1) >= FIRST_PSEUDO_REGISTER)
+ 	    {
+ 	      if (! fun)
+ 		return 1;
+ 	      (*fun) (insn, i, j, constraints, n_dups);
+ 	      found = 1;
+ 	    }
+ 	}
+     }
+ 
+   return found;
+ }
+ 
+ 
+ /* Fix insn that has two input operands in the same reg.  OI1 and OI2
+    are the numbers of conflicting operands.  recog_operands & relatives
+    are assumed to be set up for the INSN  */
+ 
+ static void
+ fix_multiple_reg_references (insn, oi1, oi2, constraints, n_dups)
+      rtx insn;
+      int oi1, oi2;
+      char *const *constraints;
+      int n_dups;
+ {
+   int chosen_oi;
+   rtx new_reg;
+   rtx *loc;
+   rtx seq;
+   int i;
+ 
+   /* Chose which of two conflictiong operands we will fix. */
+ 
+   if (constraints[oi1][0] != '+')
+     chosen_oi = oi1;
+   else if (constraints[oi2][0] != '+')
+     chosen_oi = oi2;
+   else
+     /* Two input/output operands using the same pseudo?  Imaginable (say,
+        different SUBREGs of it), but current t800 md has no such insns.  */
+     abort ();
+ 
+   loc = recog_operand_loc[chosen_oi];
+   if (GET_CODE (*loc) == SUBREG)
+     loc = &SUBREG_REG (*loc);
+   if (GET_CODE (*loc) != REG)
+     abort ();
+ 
+   /* Generate new pseudo and emit an insn to copy the duplicate reg there */
+   start_sequence ();
+   new_reg = gen_reg_rtx (GET_MODE (*loc));
+   emit_move_insn (new_reg, *loc);
+   seq = get_insns ();
+   end_sequence ();
+ 
+   emit_insns_before (seq, insn);
+ 
+   /* Change the chosen operand to use the new pseudo */
+ 
+   *loc = new_reg;
+ 
+   /* Change all DUP's of that operand, too.  */
+ 
+   for (i = n_dups - 1; i >= 0; i--)
+     {
+       if (recog_dup_num[i] != chosen_oi)
+ 	continue;
+       loc = recog_dup_loc[i];
+       if (GET_CODE (*loc) == SUBREG)
+ 	loc = &SUBREG_REG (*loc);
+       if (GET_CODE (*loc) != REG)
+ 	abort ();
+       *loc = new_reg;
+     }
+ 
+   /* We have modified the insn; mark it unrecognized to be safe */
+ 
+   INSN_CODE (insn) = -1;
+ 
+ #endif /* EXOTIC_PASS */
+ }
+ 
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/expr.c gcc-2.7.2-t800.12/expr.c
*** gcc-2.7.2/expr.c	Sun Nov 26 19:17:48 1995
--- gcc-2.7.2-t800.12/expr.c	Fri Jan 26 17:29:00 1996
***************
*** 1987,1993 ****
  	}
  #endif
! 			     
        /* Show the output dies here.  */
        emit_insn (gen_rtx (CLOBBER, VOIDmode, x));
  
        for (i = 0;
--- 1987,2000 ----
  	}
  #endif
! 
! #if 0  /* This caused trouble when upgrading t800 port to 2.7.2.
! 	  Emitting clobber for the move destination is not correct, at
! 	  least in the case of no-op move this causes the code that
! 	  produced the source to be optimized away.  I tried to
! 	  conditionalize this to avoid the no-op move case, but other
! 	  cases still caused occasional reload problem.  --sizif */
        /* Show the output dies here.  */
        emit_insn (gen_rtx (CLOBBER, VOIDmode, x));
+ #endif
  
        for (i = 0;
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/flow.c gcc-2.7.2-t800.12/flow.c
*** gcc-2.7.2/flow.c	Mon Aug 28 14:23:15 1995
--- gcc-2.7.2-t800.12/flow.c	Mon Jan 22 11:36:26 1996
***************
*** 713,717 ****
  			     would make these blocks live.  */
  			  && simplejump_p (insn)
! 			  && (label = XEXP (SET_SRC (PATTERN (insn)), 0), 1)
  			  && INSN_UID (label) != 0
  			  && BLOCK_NUM (label) == j)
--- 713,717 ----
  			     would make these blocks live.  */
  			  && simplejump_p (insn)
! 			  && (label = JUMP_LABEL (insn), 1)
  			  && INSN_UID (label) != 0
  			  && BLOCK_NUM (label) == j)
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/function.c gcc-2.7.2-t800.12/function.c
*** gcc-2.7.2/function.c	Sun Nov 26 22:50:07 1995
--- gcc-2.7.2-t800.12/function.c	Tue May  7 23:52:50 1996
***************
*** 310,314 ****
  /* Nonzero once virtual register instantiation has been done.
     assign_stack_local uses frame_pointer_rtx when this is nonzero.  */
! static int virtuals_instantiated;
  
  /* These variables hold pointers to functions to
--- 310,314 ----
  /* Nonzero once virtual register instantiation has been done.
     assign_stack_local uses frame_pointer_rtx when this is nonzero.  */
! int virtuals_instantiated;
  
  /* These variables hold pointers to functions to
***************
*** 440,444 ****
  static void instantiate_decls	PROTO((tree, int));
  static void instantiate_decls_1	PROTO((tree, int));
! static void instantiate_decl	PROTO((rtx, int, int));
  static int instantiate_virtual_regs_1 PROTO((rtx *, rtx, int));
  static void delete_handlers	PROTO((void));
--- 440,444 ----
  static void instantiate_decls	PROTO((tree, int));
  static void instantiate_decls_1	PROTO((tree, int));
! void instantiate_decl	PROTO((rtx, int, int));
  static int instantiate_virtual_regs_1 PROTO((rtx *, rtx, int));
  static void delete_handlers	PROTO((void));
***************
*** 2553,2557 ****
     changed if the new address is valid.  */
  
! static void
  instantiate_decl (x, size, valid_only)
       rtx x;
--- 2553,2557 ----
     changed if the new address is valid.  */
  
! void
  instantiate_decl (x, size, valid_only)
       rtx x;
***************
*** 3211,3214 ****
--- 3211,3215 ----
       The second time through, simply use ap to avoid generating rtx.  */
  
+ #ifndef SETUP_INCOMING_ARGS_RTX
    if ((ARG_POINTER_REGNUM == STACK_POINTER_REGNUM
         || ! (fixed_regs[ARG_POINTER_REGNUM]
***************
*** 3218,3221 ****
--- 3219,3225 ----
    else
      internal_arg_pointer = virtual_incoming_args_rtx;
+ #else
+   SETUP_INCOMING_ARGS_RTX (internal_arg_pointer, second_time);
+ #endif
    current_function_internal_arg_pointer = internal_arg_pointer;
  
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/ginclude/stdarg.h gcc-2.7.2-t800.12/ginclude/stdarg.h
*** gcc-2.7.2/ginclude/stdarg.h	Tue Sep 12 20:50:17 1995
--- gcc-2.7.2-t800.12/ginclude/stdarg.h	Wed Feb 14 10:48:45 1996
***************
*** 79,83 ****
     a warning about increasing the alignment requirement.  */
  
! #if defined (__arm__) || defined (__i386__) || defined (__i860__) || defined (__ns32000__) || defined (__vax__)
  /* This is for little-endian machines; small args are padded upward.  */
  #define va_arg(AP, TYPE)						\
--- 79,83 ----
     a warning about increasing the alignment requirement.  */
  
! #if defined (__arm__) || defined (__i386__) || defined (__i860__) || defined (__ns32000__) || defined (__vax__) || defined (__transputer__)
  /* This is for little-endian machines; small args are padded upward.  */
  #define va_arg(AP, TYPE)						\
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/ginclude/stddef.h gcc-2.7.2-t800.12/ginclude/stddef.h
*** gcc-2.7.2/ginclude/stddef.h	Sun Aug 20 00:39:03 1995
--- gcc-2.7.2-t800.12/ginclude/stddef.h	Mon Jan 22 11:36:27 1996
***************
*** 136,139 ****
--- 136,140 ----
  #ifndef _SIZE_T	/* in case <sys/types.h> has defined it. */
  #ifndef _SYS_SIZE_T_H
+ #ifndef _SIZE_T_H
  #ifndef _T_SIZE_
  #ifndef _T_SIZE
***************
*** 177,180 ****
--- 178,182 ----
  #endif /* _T_SIZE */
  #endif /* _T_SIZE_ */
+ #endif /* _SIZE_T_H */
  #endif /* _SYS_SIZE_T_H */
  #endif /* _SIZE_T */
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/ginclude/varargs.h gcc-2.7.2-t800.12/ginclude/varargs.h
*** gcc-2.7.2/ginclude/varargs.h	Mon Aug 14 02:18:36 1995
--- gcc-2.7.2-t800.12/ginclude/varargs.h	Wed Feb 14 10:48:27 1996
***************
*** 98,102 ****
  #endif
  
! #if defined (__arm__) || defined (__i386__) || defined (__i860__) || defined (__ns32000__) || defined (__vax__)
  /* This is for little-endian machines; small args are padded upward.  */
  #define va_arg(AP, TYPE)						\
--- 98,102 ----
  #endif
  
! #if defined (__arm__) || defined (__i386__) || defined (__i860__) || defined (__ns32000__) || defined (__vax__) || defined (__transputer__)
  /* This is for little-endian machines; small args are padded upward.  */
  #define va_arg(AP, TYPE)						\
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/global.c gcc-2.7.2-t800.12/global.c
*** gcc-2.7.2/global.c	Thu Jun 15 15:44:13 1995
--- gcc-2.7.2-t800.12/global.c	Mon Jan 22 11:36:27 1996
***************
*** 28,31 ****
--- 28,32 ----
  #include "regs.h"
  #include "insn-config.h"
+ #include "insn-attr.h"
  #include "output.h"
  
***************
*** 387,390 ****
--- 388,394 ----
         -2 means do make an allocno but don't allocate it.  */
      if (reg_n_refs[i] != 0 && reg_renumber[i] < 0 && reg_live_length[i] != -1
+ #ifdef HAVE_ATTR_popped_inputs
+         && reg_popped_input[i] == 0
+ #endif
  	/* Don't allocate pseudos that cross calls,
  	   if this function receives a nonlocal goto.  */
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/jump.c gcc-2.7.2-t800.12/jump.c
*** gcc-2.7.2/jump.c	Thu Oct 26 14:27:20 1995
--- gcc-2.7.2-t800.12/jump.c	Mon Jan 22 11:36:27 1996
***************
*** 2934,2941 ****
       rtx insn;
  {
!   return (GET_CODE (insn) == JUMP_INSN
! 	  && GET_CODE (PATTERN (insn)) == SET
! 	  && GET_CODE (SET_DEST (PATTERN (insn))) == PC
! 	  && GET_CODE (SET_SRC (PATTERN (insn))) == LABEL_REF);
  }
  
--- 2934,2962 ----
       rtx insn;
  {
!   register rtx x;
! 
!   if (GET_CODE (insn) != JUMP_INSN)
!     return 0;
!   
!   x = PATTERN (insn);
! 
!   /* If it is a jump in parallel with one or more clobbers, still
!      accept it. */
!   if (GET_CODE (x) == PARALLEL) {
!     int j;
! 
!     /* All components of the PARALLEL except the first must be CLOBBERSs */
!     for (j = XVECLEN (x, 0); --j > 0; ) {
!       if (GET_CODE (XVECEXP (x, 0, j)) != CLOBBER)
! 	return 0;
!     }
! 
!     /* Check the first component of the PARALLEL the usual way. */
!     x = XVECEXP (x, 0, 0);
!   }
! 
!   return (GET_CODE (x) == SET
! 	  && GET_CODE (SET_DEST (x)) == PC
! 	  && GET_CODE (SET_SRC (x)) == LABEL_REF);
  }
  
***************
*** 2948,2951 ****
--- 2969,2988 ----
  {
    register rtx x = PATTERN (insn);
+ 
+   /* If it is a jump in parallel with one or more clobbers, still
+      accept it. */
+   if (GET_CODE (x) == PARALLEL) {
+     int j;
+ 
+     /* All components of the PARALLEL except the first must be CLOBBERSs */
+     for (j = XVECLEN (x, 0); --j > 0; ) {
+       if (GET_CODE (XVECEXP (x, 0, j)) != CLOBBER)
+ 	return 0;
+     }
+ 
+     /* Check the first component of the PARALLEL the usual way. */
+     x = XVECEXP (x, 0, 0);
+   }
+ 
    if (GET_CODE (x) != SET)
      return 0;
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/local-alloc.c gcc-2.7.2-t800.12/local-alloc.c
*** gcc-2.7.2/local-alloc.c	Mon Aug 21 21:15:25 1995
--- gcc-2.7.2-t800.12/local-alloc.c	Mon Jan 22 11:36:28 1996
***************
*** 64,67 ****
--- 64,68 ----
  #include "hard-reg-set.h"
  #include "insn-config.h"
+ #include "insn-attr.h"
  #include "recog.h"
  #include "output.h"
***************
*** 216,219 ****
--- 217,233 ----
  short *reg_renumber;
  
+ #ifdef HAVE_ATTR_popped_inputs
+ 
+ /* If there is an insn which uses and pops a register, and the register
+    does not die in this insn, it must not be allocated for hard reg.
+    Let it be a stack slot, reloaded before use.
+    REG_POPPED_INPUT carries a status for such regs:
+    A value of 1 means that there is an insn that uses and pops this reg.
+    A value of 3 means that the reg does not die in that insn. */
+ 
+ char *reg_popped_input;
+ 
+ #endif
+ 
  /* Set of hard registers live at the current point in the scan
     of the instructions in a basic block.  */
***************
*** 271,274 ****
--- 285,289 ----
  static int no_conflict_p	PROTO((rtx, rtx, rtx));
  static int requires_inout	PROTO((char *));
+ static int mark_popped_reg	PROTO((rtx, rtx));
  
  /* Allocate a new quantity (new within current basic block)
***************
*** 458,461 ****
--- 473,496 ----
      reg_renumber[i] = -1;
  
+ #ifdef HAVE_ATTR_popped_inputs
+ 
+   reg_popped_input = (char *) oballoc (max_regno * sizeof (char));
+   for (i = 0; i < max_regno; i++)
+     reg_popped_input[i] = 0;
+ 
+   {
+     rtx insn = basic_block_head[0];
+ 
+     while (1)
+       {
+         note_popped_inputs (insn, mark_popped_reg);
+ 	if (insn == basic_block_end[n_basic_blocks-1])
+ 	  break;
+ 	insn = NEXT_INSN (insn);
+       }
+   }
+ 
+ #endif
+ 
    /* Determine which pseudo-registers can be allocated by local-alloc.
       In general, these are the registers used only in a single block and
***************
*** 472,476 ****
        if (reg_basic_block[i] >= 0 && reg_n_deaths[i] == 1
  	  && (reg_alternate_class (i) == NO_REGS
! 	      || ! CLASS_LIKELY_SPILLED_P (reg_preferred_class (i))))
  	reg_qty[i] = -2;
        else
--- 507,512 ----
        if (reg_basic_block[i] >= 0 && reg_n_deaths[i] == 1
  	  && (reg_alternate_class (i) == NO_REGS
! 	      || ! CLASS_LIKELY_SPILLED_P (reg_preferred_class (i)))
! 	  && reg_popped_input[i] < 3)
  	reg_qty[i] = -2;
        else
***************
*** 523,526 ****
--- 559,588 ----
      }
  }
+ 
+ #ifdef HAVE_ATTR_popped_inputs
+ 
+ /* Record information on the use of REG, which is a popped input of
+    INSN, in the vector REG_POPPED_INPUTS.
+    This is called by higher-order function NOTE_POPPED_INPUTS */
+ 
+ static int
+ mark_popped_reg (insn, reg)
+   rtx insn, reg;
+ {
+   register regno;
+ 
+   if (GET_CODE (reg) == SUBREG)
+     regno = REGNO (SUBREG_REG (reg));
+   else
+     regno = REGNO (reg);
+     
+   reg_popped_input[regno] |= 1;
+   if (!find_regno_note (insn, REG_DEAD, regno))
+     reg_popped_input[regno] |= 3;
+ 
+   return 0;
+ }
+ 
+ #endif /* HAVE_ATTR_popped_inputs */
  
  /* Depth of loops we are in while in update_equiv_regs.  */
***************
*** 1214,1217 ****
--- 1276,1282 ----
  	      && insn_operand_constraint[insn_code_number][0][0] == '='
  	      && insn_operand_constraint[insn_code_number][0][1] != '&'
+ #ifdef DONT_TIE_REGS
+ 	      && 0
+ #endif
  #else
  	      && GET_CODE (PATTERN (insn)) == SET
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/optabs.c gcc-2.7.2-t800.12/optabs.c
*** gcc-2.7.2/optabs.c	Sun Oct 22 01:15:54 1995
--- gcc-2.7.2-t800.12/optabs.c	Mon Jan 22 11:36:28 1996
***************
*** 2742,2758 ****
  #endif
  	{
  #ifdef TARGET_MEM_FUNCTIONS
! 	  emit_library_call (memcmp_libfunc, 0,
! 			     TYPE_MODE (integer_type_node), 3,
! 			     XEXP (x, 0), Pmode, XEXP (y, 0), Pmode,
! 			     size, Pmode);
  #else
! 	  emit_library_call (bcmp_libfunc, 0,
! 			     TYPE_MODE (integer_type_node), 3,
! 			     XEXP (x, 0), Pmode, XEXP (y, 0), Pmode,
! 			     size, Pmode);
  #endif
! 	  emit_cmp_insn (hard_libcall_value (TYPE_MODE (integer_type_node)),
! 			 const0_rtx, comparison, NULL_RTX,
  			 TYPE_MODE (integer_type_node), 0, 0);
  	}
--- 2742,2769 ----
  #endif
  	{
+ 	  rtx value;
  #ifdef TARGET_MEM_FUNCTIONS
! 	  value = emit_library_call_value (memcmp_libfunc, NULL_RTX, 0,
! 					   TYPE_MODE (integer_type_node), 3,
! 					   XEXP (x, 0), Pmode,
! 					   XEXP (y, 0), Pmode,
! 					   size, Pmode);
  #else
! 	  value = emit_library_call_value (bcmp_libfunc, NULL_RTX, 0,
! 					   TYPE_MODE (integer_type_node), 3,
! 					   XEXP (x, 0), Pmode,
! 					   XEXP (y, 0), Pmode,
! 					   size, Pmode);
  #endif
! 
! 	  /* If VALUE is a hard register, it must be saved right after
! 	     the call; we cannot be sure that code generated by 
! 	     emit_cmp_insn will do this.  So save it here.  */
! 
! 	  if (GET_CODE (value) == REG
! 	      && REGNO (value) < FIRST_PSEUDO_REGISTER)
! 	    value = copy_to_reg (value);
! 
! 	  emit_cmp_insn (value, const0_rtx, comparison, NULL_RTX,
  			 TYPE_MODE (integer_type_node), 0, 0);
  	}
***************
*** 2829,2832 ****
--- 2840,2844 ----
        && class != MODE_FLOAT)
      {
+       rtx value;
        rtx libfunc = cmp_optab->handlers[(int) mode].libfunc;
        /* If we want unsigned, and this mode has a distinct unsigned
***************
*** 2835,2840 ****
  	libfunc = ucmp_optab->handlers[(int) mode].libfunc;
  
!       emit_library_call (libfunc, 1,
! 			 word_mode, 2, x, mode, y, mode);
  
        /* Integer comparison returns a result that must be compared against 1,
--- 2847,2860 ----
  	libfunc = ucmp_optab->handlers[(int) mode].libfunc;
  
!       value = emit_library_call_value (libfunc, NULL_RTX, 1,
! 				       word_mode, 2, x, mode, y, mode);
! 
!       /* If VALUE is a hard register, it must be saved right after the
! 	 call; we cannot be sure that code generated by emit_cmp_insn
! 	 will do this.  So save it here.  */
! 
!       if (GET_CODE (value) == REG
! 	  && REGNO (value) < FIRST_PSEUDO_REGISTER)
! 	value = copy_to_reg (value);
  
        /* Integer comparison returns a result that must be compared against 1,
***************
*** 2842,2847 ****
  	 there is still a value that can represent the result "less than".  */
  
!       emit_cmp_insn (hard_libcall_value (word_mode), const1_rtx,
! 		     comparison, NULL_RTX, word_mode, unsignedp, 0);
        return;
      }
--- 2862,2867 ----
  	 there is still a value that can represent the result "less than".  */
  
!       emit_cmp_insn (value, const1_rtx, comparison, NULL_RTX,
! 		     word_mode, unsignedp, 0);
        return;
      }
***************
*** 3042,3050 ****
      abort ();
  
!   emit_library_call (libfunc, 1,
! 		     word_mode, 2, x, mode, y, mode);
  
!   emit_cmp_insn (hard_libcall_value (word_mode), const0_rtx, comparison,
! 		 NULL_RTX, word_mode, 0, 0);
  }
  
--- 3062,3080 ----
      abort ();
  
!   {
!     rtx value;
!     value = emit_library_call_value (libfunc, NULL_RTX, 1,
! 				     word_mode, 2, x, mode, y, mode);
! 
!     /* If VALUE is a hard register, it must be saved right after the
!        call; we cannot be sure that code generated by emit_cmp_insn
!        will do this.  So save it here.  */
! 
!     if (GET_CODE (value) == REG
! 	&& REGNO (value) < FIRST_PSEUDO_REGISTER)
!       value = copy_to_reg (value);
  
!     emit_cmp_insn (value, const0_rtx, comparison, NULL_RTX, word_mode, 0, 0);
!   }
  }
  
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/recog.c gcc-2.7.2-t800.12/recog.c
*** gcc-2.7.2/recog.c	Sat Jul  1 14:52:16 1995
--- gcc-2.7.2-t800.12/recog.c	Fri Mar 15 14:33:53 1996
***************
*** 122,126 ****
--- 122,130 ----
  
    for (i = 0; i < noperands; i++)
+ #ifdef ASM_OPERAND_PREDICATE
+     if (! ASM_OPERAND_PREDICATE (operands[i], VOIDmode))
+ #else
      if (!general_operand (operands[i], VOIDmode))
+ #endif
        return 0;
  
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/reg-stack.c gcc-2.7.2-t800.12/reg-stack.c
*** gcc-2.7.2/reg-stack.c	Fri Jun 16 01:35:46 1995
--- gcc-2.7.2-t800.12/reg-stack.c	Mon Jan 22 11:36:28 1996
***************
*** 160,163 ****
--- 160,170 ----
  #include <stdio.h>
  #include "config.h"
+ 
+ #ifdef STACK_REGS
+ 
+ #ifdef STACK_REG_FIRST  /* Machine description expects reg-stack2.c */
+ #include "reg-stack2.c"
+ #else /* STACK_REG_FIRST */
+ 
  #include "tree.h"
  #include "rtl.h"
***************
*** 167,172 ****
  #include "flags.h"
  
- #ifdef STACK_REGS
- 
  #define REG_STACK_SIZE (LAST_STACK_REG - FIRST_STACK_REG + 1)
  
--- 174,177 ----
***************
*** 3132,3134 ****
--- 3137,3140 ----
      }
  }
+ #endif /* STACK_REG_FIRST */
  #endif /* STACK_REGS */
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/reg-stack.h gcc-2.7.2-t800.12/reg-stack.h
*** gcc-2.7.2/reg-stack.h	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/reg-stack.h	Mon Jan 22 11:36:28 1996
***************
*** 0 ****
--- 1,126 ----
+ /* Declarations for reg-stack pass necessary for the implementation
+    of STACK_REG_EMIT_{DROPS,SWAPS}();
+    Copyright (C) 1992 Free Software Foundation, Inc.
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
+ 
+ 
+ #ifndef NULL_PTR
+ #define NULL_PTR 0
+ #endif
+ 
+ 
+ #define FIRST_NONSTACK_REGISTER     (STACK_REG_LAST (STACK_REG_NSTACKS-1))
+ 
+ /* This structure describes the state of all reg-stacks. TOP[k] is an
+    index into REG[] such that REG[TOP[k]] is the top of k-th stack.
+    TOP[k] > STACK_REG_LAST(k) means the stack is empty.
+ 
+                              +0  +1  +2             <<< hard regnos
+     +---+---+---+---+---+---+---+---+---+---+---
+       ^STACK_REG_FIRST(k)     ^TOP[k] ^STACK_REG_LAST(k)
+ 
+    If TOP[0] is less than 0, the stack is not yet initialized: reg_set
+    indicates which registers are live.  Stack initialization consists of
+    placing each live reg in array REG and setting TOP appropriately.
+ 
+    Size of REG is larger than actually needed. Non-stack-reg entries
+    are unused, but simplify the life slightly.
+    
+    The array MODE, indexed by a virtual regno, shows the mode of the
+    value contained in the virtual reg.  Entries for non-live registers
+    contain a garbage.  This information needs not to be very accurate,
+    since it is used only to find out the proper mode when emitting
+    stack shuffling insns.  It is necessary because on T800 there are
+    distinct instructions for loading/storing SF and DF values; the
+    manual says the result of the insn is undefined if the insn does
+    not match the value currently held in the register which is
+    loaded/stored.
+    
+    `Inaccurate' means that each register composing, say, DImode value
+    gets marked with DImode, although the proper value would be SImode.  */
+ 
+ typedef
+ struct stack_def
+ {
+   HARD_REG_SET reg_set;             /* set of live virtual registers */
+   int top[STACK_REG_NSTACKS];
+   int reg[FIRST_PSEUDO_REGISTER];
+   enum machine_mode mode[FIRST_PSEUDO_REGISTER];
+ } *stack;
+ 
+ /* Given a hard (not virtual) regno, provide access to corresponding
+    entry of the REG array in above structure.  */
+ #define REG_BY_HARD_REGNO(stack, regno) \
+   (stack)->reg[(stack)->top[STACK_REG_STACKNO (regno)]          \
+                + (regno)                                        \
+                - STACK_REG_FIRST (STACK_REG_STACKNO (regno))]
+ 
+ /* Get the depth of the given stack.  */
+ #define STACK_DEPTH(STACK, STACKNO) \
+   (STACK_REG_LAST (STACKNO) + 1 - (STACK)->top[STACKNO])
+ 
+ 
+ /* The structure containing miscellaneous useful information about an insn.
+    It is filled by ANALYSE_INSN. The info is associated mostly with
+    the stack registers the insn acts on. 
+ 
+      IN contains info on the stack regs that are input for the insn.
+    The regs that are both input and output (matching constraint) are
+    there also, because they need the same treatment as the pure
+    inputs.
+ 
+      OUT contains info on the regs that are "pushed outputs" of the
+    insn; this need to be in a separate array as the same reg may act
+    as both input and output, in different classes and modes.
+ 
+      Dimensions of IN and OUT are choosen so as to be enough for any
+    insn--rather wasteful, though.  */
+ 
+ struct insn_info {
+   int is_asm;
+ 
+   /* The set of virtual stack-regs that are outputs of the insn.
+      If the insn has a multi-register output operand, all subregs
+      of the compound register are in this set. */
+   HARD_REG_SET out_regs;
+ 
+   struct insn_info_reg {
+     rtx reg;
+     int flags;
+     enum reg_class class;
+   } in[FIRST_NONSTACK_REGISTER], *in_last,
+    out[FIRST_NONSTACK_REGISTER], *out_last;
+ };
+ 
+ enum {
+   INPUT         = 0x01,         /* reg used as input */
+   OUTPUT        = 0x02,         /* reg used as output */
+   EARLYCLOBBER  = 0x04,         /* '&' presents in operand's constraint */
+   POPPED        = 0x20,         /* input reg is implicitly popped */
+   PUSHED        = POPPED,       /* output reg is implicitly pushed */
+   JUMP_POPPED   = 0x40,         /* input reg is implicitly popped by jump
+                                    insn when the jump is taken */
+ };
+ 
+ 
+ /* This is the register file for all register after conversion */
+ extern rtx hard_reg[FIRST_PSEUDO_REGISTER][(int) MAX_MACHINE_MODE];
+ 
+ /* Declarations for some functions from reg-stack.c */
+ int print_stack     PROTO((stack));
+ 
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/reg-stack2.c gcc-2.7.2-t800.12/reg-stack2.c
*** gcc-2.7.2/reg-stack2.c	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/reg-stack2.c	Thu Nov 21 13:59:04 1996
***************
*** 0 ****
--- 1,3769 ----
+ /* Convertor to stack-like register model for GNU compiler.
+    Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ 
+ /* This is a replacement reg-stack converter.  It is build on ideas
+    and code from reg-stack.c, but is (hopefully) tunable to different
+    architectures.
+ 
+    Generalized insn operating on stack-regs affects a register stack
+    as follows:
+ 
+    (1) The insn takes some input regs, that may be (in general)
+    anywhere on the stack.
+ 
+    (2) It may pop some of the input regs off the stack. These are
+    called `popped inputs', and must be grouped near the top of stack.
+ 
+    (3) It may push some outputs onto the stack. These are called
+    `pushed outputs', and are added at the top of stack.
+ 
+    (4) It may write some outputs over the non-popped inputs. These are
+    `non-pushed' outputs.
+ 
+    Here is how the sorts of operands according to above classification
+    are determined:
+ 
+    (a) By default, the inputs are non-popped. If the insn pops some
+    input, its pattern should either have a popped_reg attribute
+    (for normal insns) or contain a `P' constraint (for ASMs).
+ 
+    (b) By default, outputs are pushed. For output to be non-pushed,
+    there should exist a non-popped input constrained to match this
+    output.
+ 
+    The converter comprises two passes over rtl.  The first pass does
+    life analysis for stack registers, collecting information which is
+    used in the second pass, which is the converter proper.
+ 
+    The second pass scans the insns, keeping track of the current state
+    of register stack(s).  For every insn mentioning stack registers,
+    it does the following:
+ 
+    (1) Brings the insns inputs to proper positions on the stack,
+    according to insn's constraints, by emitting stack shuffling
+    sequence before the insn.
+ 
+    (2) Emits code after the insn to remove the regs which are not live
+    after the insn from the stack.  This way, register stack contains
+    *only* live registers.
+ 
+    (3) Optionally replaces references to stack regs in the insn with
+    "hard" registers, whose numbers are convertable into offsets from
+    stack top, which can be necessary for assembly output.  t800 does
+    not need this, and the code for this is incomplete.
+ 
+    */
+ 
+ 
+ /* Note: all the code under #ifdef STACK_REG_STRICT or #ifdef
+    FUNCTION_EPILOGUE is untested or almost untested. */
+ 
+ 
+ /* These are already included by reg-stack.c:
+ #include <stdio.h>
+ #include "config.h"
+  */
+ 
+ #ifdef STACK_REGS
+ 
+ #include "tree.h"
+ #include "rtl.h"
+ #include "insn-config.h"
+ #include "insn-codes.h"
+ #include "insn-flags.h"         /* for gen_nop */
+ #include "insn-attr.h"
+ #include "regs.h"
+ #include "flags.h"
+ #include "recog.h"
+ #include "output.h"
+ #include "hard-reg-set.h"
+ #include "reg-stack.h"
+ 
+ /* highest instruction uid */
+ static int max_uid = 0;
+ 
+ /* Number of basic blocks in the current function.  */
+ static int blocks;
+ 
+ /* Element N is first insn in basic block N.
+    This info lasts until we finish compiling the function.  */
+ static rtx *block_begin;
+ 
+ /* Element N is last insn in basic block N.
+    This info lasts until we finish compiling the function.  */
+ static rtx *block_end;
+ 
+ /* Element N is nonzero if control can drop into basic block N.
+    Bit 0 says the control drops in from the preceding block.
+    Bit 1 says the control drops in from an agreeing sequence emitted
+    before the block.  */
+ static char *block_drops_in;
+ 
+ /* Element N is the reg-stack state at the entry of block N */
+ static stack block_stack_in;
+ 
+ /* Element N is the reg-stack registers' life at the end of block N */
+ static HARD_REG_SET *block_out_reg_set;
+ 
+ /* Element N is the mode of the registers live at the end of block N.  */
+ static enum machine_mode (*block_out_reg_mode)[FIRST_PSEUDO_REGISTER];
+ 
+ /* This is the register file for all register after conversion */
+ rtx hard_reg[FIRST_PSEUDO_REGISTER][(int) MAX_MACHINE_MODE];
+ 
+ /* This is where the BLOCK_NUM values are really stored.  This is set
+    up by find_blocks and used there and in life_analysis.  It can be used
+    later, but only to look up an insn that is the head or tail of some
+    block.  life_analysis and the stack register conversion process can
+    add insns within a block. */
+ static short *block_number;
+ 
+ /* Get the basic block number of an insn.  See the comment just above.  */
+ 
+ #define BLOCK_NUM(INSN)  \
+   ((INSN_UID (INSN) > max_uid)	\
+    ? (abort() , -1) : block_number[INSN_UID (INSN)])
+ 
+ 
+ extern rtx forced_labels;
+ 
+ struct reg_life_data;
+ struct operand_data;
+ 
+ rtx stack_reg_mentioned                 PROTO((rtx));
+ rtx stack_reg_but_one_mentioned         PROTO((rtx, rtx));
+ void reg_to_stack                       PROTO((rtx, FILE *));
+ static void record_label_references     PROTO((rtx, rtx));
+ static int analyse_constraints          PROTO((rtx, int, rtx *,
+                                                char *const *,
+                                                struct insn_info *));
+ static int letter_wins                  PROTO((int, struct operand_data *));
+ static int check_rules                  PROTO((rtx, stack,
+                                                struct insn_info *));
+ static int check_rule2                  PROTO((stack, struct insn_info *));
+ static int ior_set                      PROTO((rtx, rtx));
+ static void record_reg_life_pat         PROTO((rtx, struct reg_life_data *));
+ static int n_extra_stack_reg_operands   PROTO((rtx));
+ static int record_extra_stack_reg_operands PROTO((rtx, HARD_REG_SET *,
+                                                   enum machine_mode *));
+ static rtx skip_uses                    PROTO((rtx));
+ static rtx find_jump_table              PROTO((rtx));
+ static void record_reg_life             PROTO((rtx, stack));
+ static void find_blocks                 PROTO((rtx));
+ static int uses_reg_or_mem		PROTO((rtx));
+ static rtx stack_result                 PROTO((tree));
+ static void stack_reg_life_analysis     PROTO((rtx));
+ static void ior_regset_and_mode         PROTO((HARD_REG_SET *,
+                                                enum machine_mode *,
+                                                stack));
+ static rtx emit_zero_init_before        PROTO((HARD_REG_SET *, stack, rtx));
+ static void replace_reg                 PROTO((rtx *, int));
+ static int get_hard_regnum              PROTO((stack, rtx));
+ int stacks_equal                        PROTO((stack, stack));
+ void init_stack                         PROTO((stack));
+ int print_stack                         PROTO((stack));
+ static void delete_insn_for_stacker     PROTO((rtx));
+ static int del_stack_reg_move           PROTO((rtx, stack));
+ static void displace_reg                PROTO((stack, int, rtx));
+ static int place_reg                    PROTO((stack, int, rtx));
+ static int place_inputs                 PROTO((int, stack, stack,
+                                                struct insn_info *));
+ static int place_regs                   PROTO((stack, stack,
+                                                struct insn_info *));
+ void set_hard_reg_bits                  PROTO((HARD_REG_SET *, rtx));
+ void set_hard_reg_bits_3                PROTO((HARD_REG_SET *, int, enum machine_mode));
+ void clear_hard_reg_bits                PROTO((HARD_REG_SET *, rtx));
+ static void subst_regs_recursively      PROTO((rtx *, stack,
+                                                HARD_REG_SET *));
+ void print_insn_info                    PROTO((struct insn_info *));
+ static void analyse_insn                PROTO((rtx, struct insn_info *));
+ static int sort_insn_info_cmp           PROTO((struct insn_info_reg *,
+                                                struct insn_info_reg *));
+ static void sort_insn_info_in           PROTO((struct insn_info *));
+ static void sort_insn_info_out          PROTO((struct insn_info *));
+ static void pop_inputs                  PROTO((stack, struct insn_info *,
+                                               int));
+ static void subst_stack_regs            PROTO((rtx, stack, stack));
+ static void change_stack                PROTO((rtx, stack, stack,
+                                                rtx (*)()));
+ static void goto_block_pat              PROTO((rtx, stack, rtx));
+ static rtx subst_stack_regs_from_to     PROTO((rtx, rtx, stack, stack));
+ static rtx subst_stack_regs_in_group    PROTO((rtx, rtx, stack, stack));
+ static rtx recognize_load_atom          PROTO((rtx, rtx));
+ static void atom_force_single_reg       PROTO((rtx, rtx, rtx));
+ static void atom_force_single_reg_1     PROTO((rtx *, rtx));
+ static void convert_regs                PROTO(());
+ static void print_blocks                PROTO((FILE *, rtx, rtx));
+ static void dump_stack_info             PROTO((FILE *));
+ static rtx walk_alter_subreg            PROTO((rtx));
+ int note_popped_inputs                  PROTO((rtx, int (*)()));
+ 
+ 
+ /* Return the first stack register mentioned within PAT,
+    or NULL_RTX if no stack registers are mentioned.
+    Pseudo registers are accepted as well, since they may be assigned
+    to stack registers; thus this function can be used from
+    `note_insn_popped_input'.  */
+ 
+ rtx
+ stack_reg_mentioned (pat)
+      rtx pat;
+ {
+   register char *fmt;
+   register int i, j;
+   register rtx reg;
+ 
+   if (GET_CODE (pat) == REG
+       && (STACK_REG_P (pat)
+ 	  || REGNO (pat) >= FIRST_PSEUDO_REGISTER))
+     return pat;
+ 
+   /* Return stack registers together with enclosing subreg, if there
+      is one, for the sake of note_popped_inputs */
+ 
+   if (GET_CODE (pat) == SUBREG
+       && GET_CODE (SUBREG_REG (pat)) == REG
+       && (STACK_REG_P (SUBREG_REG (pat))
+ 	  || REGNO (SUBREG_REG (pat)) >= FIRST_PSEUDO_REGISTER))
+     return pat;
+ 
+   fmt = GET_RTX_FORMAT (GET_CODE (pat));
+   for (i = GET_RTX_LENGTH (GET_CODE (pat)); --i >= 0; )
+     if (fmt[i] == 'E')
+       {
+         for (j = XVECLEN (pat, i); --j >= 0; )
+           if (reg = stack_reg_mentioned (XVECEXP (pat, i, j)))
+             return reg;
+       }
+     else if (fmt[i] == 'e')
+       if (reg = stack_reg_mentioned (XEXP (pat, i)))
+         return reg;
+ 
+   return NULL_RTX;
+ }
+ 
+ /* Return the first stack register mentioned within PAT which is not
+    THEONE, or NULL_RTX if no stack registers other than THEONE are
+    mentioned.  */
+ 
+ rtx
+ stack_reg_but_one_mentioned (pat, theone)
+     rtx pat, theone;
+ {
+   register char *fmt;
+   register int i, j;
+   register rtx reg;
+ 
+   if (STACK_REG_P (pat))
+     return rtx_equal_p (pat, theone)? NULL_RTX : pat;
+ 
+   fmt = GET_RTX_FORMAT (GET_CODE (pat));
+   for (i = GET_RTX_LENGTH (GET_CODE (pat)); --i >= 0; )
+     if (fmt[i] == 'E')
+       {
+         for (j = XVECLEN (pat, i); --j >= 0; )
+           if (reg = stack_reg_but_one_mentioned (XVECEXP (pat, i, j), theone))
+             return reg;
+       }
+     else if (fmt[i] == 'e')
+       if (reg = stack_reg_but_one_mentioned (XEXP (pat, i), theone))
+         return reg;
+ 
+   return NULL_RTX;
+ }
+ 
+ 
+ /* Convert register usage from "flat" register file usage to a "stack
+    register file.  FIRST is the first insn in the function, FILE is the
+    dump file, if used.
+ 
+    First compute the beginning and end of each basic block.  Do a
+    register life analysis on the stack registers, recording the result
+    for the head and tail of each basic block.  Then convert each insn one
+    by one.  Run a last jump_optimize() pass, if optimizing, to eliminate
+    any cross-jumping created when the converter inserts pop insns.  */
+ 
+ void
+ reg_to_stack (first, file)
+      rtx first;
+      FILE *file;
+ {
+   register rtx insn;
+   register int i;
+   int stack_reg_seen = 0;
+   int mode;
+ 
+   for (mode = 0; mode < MAX_MACHINE_MODE; ++mode)
+     for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)
+       hard_reg[i][mode] = gen_rtx (REG, (enum machine_mode)mode, i);
+ 
+   /* Count the basic blocks.  Also find maximum insn uid.  */
+   {
+     register RTX_CODE prev_code = BARRIER;
+     register RTX_CODE code;
+ 
+     max_uid = 0;
+     blocks = 0;
+     for (insn = first; insn; insn = NEXT_INSN (insn))
+       {
+         /* Note that this loop must select the same block boundaries
+ 	   as code in find_blocks.  Also note that this code is not the
+ 	   same as that used in flow.c.  */
+ 
+         if (INSN_UID (insn) > max_uid)
+           max_uid = INSN_UID (insn);
+ 
+         /* Remember whether or not this insn mentions stack regs. */
+ 
+         code = GET_CODE (insn);
+         if ((GET_RTX_CLASS (code) == 'i'
+ 	     && stack_reg_mentioned (PATTERN (insn)))
+             || (code == CALL_INSN
+                 || (code == JUMP_INSN
+ 		    && GET_CODE (PATTERN (insn)) == RETURN))
+                && n_extra_stack_reg_operands (insn))
+           {
+             stack_reg_seen = 1;
+             PUT_MODE (insn, QImode);
+ 
+             /* Get rid of SUBREGs beforehand to simplify the code of this pass */
+             walk_alter_subreg (PATTERN (insn));
+           }
+         else
+           PUT_MODE (insn, VOIDmode);
+ 
+         switch (code)
+           {
+             case JUMP_INSN:
+               {
+                 /* Treat tablejump insn and the table following it as
+                    a whole; don't allow the table to fall into
+                    a separate block. */
+                 rtx insn2 = find_jump_table (PATTERN (insn));
+                 if (insn2)
+                   {
+                     insn = insn2;
+                     if (INSN_UID (insn) > max_uid)
+                       max_uid = INSN_UID (insn);
+                   }
+               }
+             case INSN:
+             case CALL_INSN:
+               if (prev_code != JUMP_INSN && prev_code != BARRIER)
+                 break;
+             case CODE_LABEL:
+               blocks++;
+           }
+ 
+ 	if (code == CODE_LABEL)
+ 	  LABEL_REFS (insn) = insn; /* delete old chain */
+ 
+         if (code != NOTE)
+           prev_code = code;
+       }
+   }
+ 
+   /* If no stack register reference exists in this insn, there isn't
+      anything to convert.  */
+ 
+   if (! stack_reg_seen)
+     return;
+ 
+   /* If there are stack registers, there must be at least one block. */
+ 
+   if (! blocks)
+     abort ();
+ 
+   /* Allocate some tables that last till end of compiling this function
+      and some needed only in find_blocks and life_analysis. */
+ 
+   block_begin = (rtx *) alloca (blocks * sizeof (rtx));
+   block_end = (rtx *) alloca (blocks * sizeof (rtx));
+   block_drops_in = (char *) alloca (blocks);
+ 
+   block_stack_in = (stack) alloca (blocks * sizeof (struct stack_def));
+   block_out_reg_set = (HARD_REG_SET *) alloca (blocks * sizeof (HARD_REG_SET));
+   block_out_reg_mode = (enum machine_mode (*)[FIRST_PSEUDO_REGISTER])
+     alloca (blocks * FIRST_PSEUDO_REGISTER * sizeof (enum machine_mode));
+   bzero ((char *) block_stack_in, blocks * sizeof (struct stack_def));
+   bzero ((char *) block_out_reg_set, blocks * sizeof (HARD_REG_SET));
+ 
+   block_number = (short *) alloca ((max_uid + 1) * sizeof (short));
+ 
+   find_blocks (first);
+   stack_reg_life_analysis (first);
+ 
+   /* Dump the life analysis debug information before jump
+      optimization, as that will destroy the LABEL_REFS we keep the
+      information in. */
+ 
+   if (file)
+     dump_stack_info (file);
+ 
+   convert_regs ();
+ 
+ #ifndef JUMP_CLOBBERS_REGS
+   if (optimize)
+     jump_optimize (first, 2, 0, 0);
+ #endif
+ }
+ 
+ /* Check PAT, which is in INSN, for LABEL_REFs.  Add INSN to the
+    label's chain of references, and note which insn contains each
+    reference. */
+ 
+ static void
+ record_label_references (insn, pat)
+      rtx insn, pat;
+ {
+   register enum rtx_code code = GET_CODE (pat);
+   register int i;
+   register char *fmt;
+ 
+   if (code == LABEL_REF)
+     {
+       register rtx label = XEXP (pat, 0);
+       register rtx ref;
+ 
+       if (GET_CODE (label) != CODE_LABEL)
+         abort ();
+ 
+       /* Don't make a duplicate in the code_label's chain. */
+ 
+       for (ref = LABEL_REFS (label);
+ 	   ref && ref != label;
+ 	   ref = LABEL_NEXTREF (ref))
+         if (CONTAINING_INSN (ref) == insn)
+           return;
+ 
+       CONTAINING_INSN (pat) = insn;
+       LABEL_NEXTREF (pat) = LABEL_REFS (label);
+       LABEL_REFS (label) = pat;
+ 
+       return;
+     }
+ 
+   fmt = GET_RTX_FORMAT (code);
+   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)
+     {
+       if (fmt[i] == 'e')
+         record_label_references (insn, XEXP (pat, i));
+       if (fmt[i] == 'E')
+         {
+           register int j;
+           for (j = 0; j < XVECLEN (pat, i); j++)
+             record_label_references (insn, XVECEXP (pat, i, j));
+         }
+     }
+ }
+ 
+ #if 0   /* Currently unused */
+ /* Return a pointer to the REG expression within PAT.  If PAT is not a
+    REG, possible enclosed by a conversion rtx, return the inner part of
+    PAT that stopped the search. */
+ 
+ rtx *
+ get_true_reg (pat)
+      rtx *pat;
+ {
+   for(;;)
+     switch (GET_CODE (*pat))
+       {
+ /*      case SUBREG:    it might be not a mere conversion! */
+       case SIGN_EXTEND:
+       case ZERO_EXTEND:
+       case FLOAT_EXTEND:
+       case TRUNCATE:
+       case FLOAT_TRUNCATE:
+       case FLOAT:
+       case UNSIGNED_FLOAT:
+       case FIX:
+       case UNSIGNED_FIX:
+         pat = & XEXP (*pat, 0);
+         continue;
+       default:
+         return pat;
+       }
+ }
+ #endif
+ 
+ 
+ 
+ /* Scan the OPERANDS and OPERAND_CONSTRAINTS of an insn, collecting
+    the stack-reg-relevant info in the insn_info structure.
+ 
+    The code supposes matching operands to have the same mode (or rather,
+    to have the modes that occupy the same number of hard registers.)  */
+ 
+ struct operand_data {
+   rtx x;                    /* the operand rtx */
+   int n;                    /* the operand number */
+   enum reg_class class;     /* class derived from STACK_REG_CLASS_OK_FOR_LETTER */
+   char flags;               /* bits from enum operand_flags */
+   char match;               /* if >= 0, the operand matched by this one  */
+   char comm1;               /* this operand has '%' constraint */
+   char comm2;               /* previous operand has '%' constraint */
+   char comm1_win;           /* really can commute this op with the next one */
+   char comm2_win;           /* ditto for the previous one */
+   char *constraint;         /* running pointer to the constraint string */
+ };
+ 
+ static int
+ analyse_constraints (insn, n_operands, operands, operand_constraints, info)
+      rtx insn;
+      int n_operands;
+      rtx *operands;
+      char *const *operand_constraints;
+      struct insn_info *info;
+ {
+   struct operand_data dat[MAX_RECOG_OPERANDS];
+   struct operand_data *this_op;
+   struct operand_data *last_op = &dat[n_operands - 1];
+   int n_alternatives;
+   int this_alternative;
+ 
+ 
+   /* Constraintless pattern would cause problems in the code below. */
+   if (n_operands == 0 || operand_constraints[0] == 0)
+     return 0;
+ 
+   for (this_op = dat; this_op <= last_op; this_op++)
+     {
+       this_op->n = this_op - dat;
+       this_op->x = operands[this_op->n];
+       this_op->constraint = operand_constraints[this_op->n];
+       this_op->match = -1;
+       this_op->comm1 = this_op->comm2 = 0;
+       this_op->flags = INPUT;
+     }
+ 
+   /* Compute the number of alternatives in the operands.  reload has
+      already guaranteed that all operands have the same number of
+      alternatives.  */
+ 
+   n_alternatives = info->is_asm
+     ? n_occurrences (',', operand_constraints[0]) + 1
+     : insn_n_alternatives[INSN_CODE (insn)];
+ 
+   /* ??? Bug: this code will return -1 if the constraints are empty. */
+ 
+   this_alternative = 0;
+   while (this_alternative < n_alternatives)
+     {
+       int lose = 0;
+ 
+       /* No operands match, no narrow class requirements yet.  */
+       for (this_op = dat; this_op <= last_op; this_op++)
+         {
+           /* [=+%] constraint chars affect all the alternatives.
+              Do not reset their respective flags.  */
+           this_op->flags &= (INPUT|OUTPUT|PUSHED);
+           this_op->class = NO_REGS;
+           this_op->comm1_win = 0;
+           this_op->comm2_win = 0;
+         }
+ 
+       for (this_op = dat; this_op <= last_op; this_op++)
+         {
+           char *p = this_op->constraint;
+           int win = 0;
+           int c;
+ 
+           if (*p == 0 || *p == ',')
+             win = this_op->comm1_win = this_op->comm2_win = 1;
+ 
+           while (*p && (c = *p++) != ',')
+             {
+               switch (c)
+                 {
+                 case '?':
+                 case '!':
+                 case '*':
+                   break;
+ 
+                 case '=':
+                   this_op->flags |= PUSHED|OUTPUT;
+                   this_op->flags &= ~INPUT;
+                   break;
+ 
+                 case '+':
+                   this_op->flags |= INPUT|OUTPUT; 
+                   this_op->flags &= ~PUSHED;
+                   break;
+ 
+                 case '%':
+                   this_op->comm1 = (this_op + 1)->comm2 = 1;
+                   break;
+ 
+                 case '&':
+                   this_op->flags |= EARLYCLOBBER; 
+ 		  break;
+ 
+                 case '#':
+                   /* Ignore the rest of this alternative. */
+                   while (*p && *p != ',')
+ 		    p++;
+                   break;
+ 
+                 case '0':
+                 case '1':
+                 case '2':
+                 case '3':
+                 case '4':
+                 case '5':
+                 case '6':
+                 case '7':
+                 case '8':
+                 case '9':
+                   if (operands_match_p (this_op->x, dat[c - '0'].x))
+                     {
+                       this_op->match = c - '0';
+                       this_op->flags &= ~POPPED;
+                       dat[c - '0'].flags &= ~PUSHED;
+                       win = 1;
+                     }
+                   break;
+ 
+ 		  /* 'P' in constraints is the way asms use to indicate
+ 		     the the input opperand is popped by the asm */
+ 
+ 		case 'P':
+                   this_op->flags |= POPPED;
+                   break;
+ 
+                 default:
+                   /* Take shortcut if we know this alternative fails  */
+                   if (lose)
+                     break;
+ 
+                   /* This code offers every letter a chance to
+                      contribute to the class.  However, the real
+                      contributors are (some of) the register letters
+                      and EXTRA_CONSTRAINT letters.  For all the rest,
+                      STACK_REG_CLASS_FROM_LETTER returns NO_REGS, so
+                      this statement does not change this_op->class.  */
+ 
+                   this_op->class = reg_class_subunion[(int) this_op->class]
+                                     [(int) STACK_REG_CLASS_FROM_LETTER (c)];
+ 
+                   win |= letter_wins (c, this_op);
+                   if (this_op->comm1)
+                     this_op->comm1_win |= letter_wins (c, this_op+1);
+                   if (this_op->comm2)
+                     this_op->comm2_win |= letter_wins (c, this_op-1);
+                   break;
+                 }
+ 
+             }
+ 
+           this_op->constraint = p;
+ 
+           /* If this operand did not win somehow,
+              this alternative loses.  */
+           if (! win)
+             lose = 1;
+         }
+ 
+       if (! lose)
+         break;
+       this_alternative++;
+     }
+ 
+   if (this_alternative == n_alternatives)
+     return -1;
+ 
+ 
+   /* Merge the classes for commutative operands and flags for matched ones.
+      ??? If the modes of the matched operands differ so that NREGS are
+      different, we'll crash.  Is this allowed in GCC at all?  Anyway,
+      T800 md does not use this.  */
+ 
+   for (this_op = dat; this_op <= last_op; this_op++)
+     {
+       if (this_op->comm1 && this_op->comm1_win && (this_op+1)->comm2_win)
+         this_op->class = (this_op+1)->class =
+           reg_class_subunion[this_op->class][(this_op+1)->class];
+       if (this_op->match >= 0)
+         dat[this_op->match].flags |= this_op->flags;
+     }
+ 
+   /* Transfer the information from OPERAND_DATA to INFO structure */
+ 
+   CLEAR_HARD_REG_SET (info->out_regs);
+ 
+   for (this_op = dat; this_op <= last_op; this_op++)
+     {
+       rtx op = this_op->x;
+ 
+       if (this_op->match >= 0)
+         continue;
+ 
+       while (GET_CODE (op) == SUBREG
+              || GET_CODE (op) == STRICT_LOW_PART
+              || GET_CODE (op) == ZERO_EXTRACT
+              || GET_CODE (op) == SIGN_EXTRACT)
+         op = XEXP (op, 0);
+ 
+       /* If the operand is not a REG, it may be something containing a
+          stack-reg within.  In this case, this stack-reg is input for
+          the insn.  Note that this approach will not work if more than
+          one stack register is hidden within the object, although
+          there is no check to ensure that the condition holds.  */
+ 
+       if (GET_CODE (op) != REG)
+         {
+           op = stack_reg_mentioned (op);
+           if (!op)
+             /* no stack-reg within */
+             continue;
+           this_op->flags |= INPUT;
+           this_op->flags &= ~OUTPUT;
+         }
+ 
+       if (! STACK_REG_P (op))
+         continue;
+ 
+       /* Take care of operands that appear within a CLOBBER.
+ 
+ 	 One possibility is that the clobbered register does not
+ 	 appear anywhere else in the insn, eg. (clobber (match_scratch)).
+ 	 The purpose of such CLOBBERs is to reserve some room on a
+ 	 reg-stack; register allocators and reload will honor the
+ 	 clobber and reserve an appropriate register.
+ 
+ 	 The register will not be live before the insn, and hence
+ 	 cannot be involved in stack reordering.  We don't need to
+ 	 know about such operands in subst_stack_regs.
+ 
+ 	 Another possibility is that the clobbered register is also an
+ 	 input for the insn.  If this is a POPPED input, it will be
+ 	 popped implicitly; otherwise, it will be popped explicitly
+ 	 since life analysis puts REG_UNUSED note for every clobbered
+ 	 register it sees.  This way, the processing is no different
+ 	 from the case of plain non-clobbered input, so we again don't
+ 	 need to give any info about the clobber.
+ 
+ 	 This way, we need to recognize the clobbered operands, which
+ 	 now look like a plain output, and ignore them.  */
+ 
+       if (this_op->flags & OUTPUT)
+ 	{
+ 	  rtx body = PATTERN (insn);
+ 	  int j;
+ 
+ 	  if (GET_CODE (body) == PARALLEL)
+ 	    {
+ 	      for (j = XVECLEN (body, 0) - 1; j >= 0; j--)
+ 		if (GET_CODE (XVECEXP (body, 0, j)) == CLOBBER)
+ 		  {
+ 		    rtx clobber = XVECEXP (body, 0, j);
+ 		    rtx reg = XEXP (clobber, 0);
+ 
+ 		    if (reg == op)
+ 		      break;
+ 		  }
+ 	      if (j >= 0)
+ 		/* yes, this operand mentioned within a CLOBBER -- skip it */
+ 		continue;
+ 	    }
+ 	}
+ 
+       if (this_op->flags & OUTPUT)
+         set_hard_reg_bits (&info->out_regs, op);
+ 
+       if ((this_op->flags & (PUSHED|OUTPUT)) == (PUSHED|OUTPUT))
+         {
+           info->out_last++;
+           info->out_last->reg = op;
+           info->out_last->flags = this_op->flags;
+           info->out_last->class = this_op->class;
+           continue;
+         }
+ 
+       /* This is non-matching INPUT operand or INPUT|OUTPUT operand */
+ 
+       {
+         struct insn_info_reg *p = ++info->in_last;
+         
+         p->reg = op;
+         p->flags = this_op->flags;
+         p->class = this_op->class;
+ 
+         /* If this is a pure INPUT, find whether it is POPPED */
+         if ((p->flags & (INPUT|OUTPUT)) == INPUT)
+           {
+             if (info->is_asm)
+               {
+ 
+ #if 0 /* Using clobber to indicate which input is implicitly popped by
+ 	 asm is now obsolete; asms should use the 'P' constraint on
+ 	 the operands that are implicitly popped.  Using clobbers for
+ 	 this creates problems with register allocation, and leaves no
+ 	 way to specify that the insn destroys the value in a
+ 	 register, but does not implicitly pop it (well, no need for
+ 	 this now, but...)  */
+ 
+                 rtx body = PATTERN (insn);
+                 int j;
+ 
+                 if (GET_CODE (body) == PARALLEL)
+                   for (j = 0; j < XVECLEN (body, 0); j++)
+                     if (GET_CODE (XVECEXP (body, 0, j)) == CLOBBER)
+                       {
+                         rtx clobber = XVECEXP (body, 0, j);
+                         rtx reg = XEXP (clobber, 0);
+ 
+                         if (operands_match_p (this_op->x, reg))
+                           {
+                             this_op->flags |= POPPED|JUMP_POPPED;
+                             break;
+                           }
+                       }
+ #endif
+               }
+             else
+               {
+                 int this_op_mask = 1 << this_op->n;
+                 if (get_attr_popped_inputs (insn) & this_op_mask)
+ #ifndef HAVE_ATTR_popped_inputs_on_jump
+                   p->flags |= POPPED|JUMP_POPPED;
+ #else
+                   p->flags |= POPPED;
+                 if (GET_CODE (insn) == JUMP_INSN
+                     && get_attr_popped_inputs_on_jump (insn) & this_op_mask)
+                   p->flags |= JUMP_POPPED;
+ #endif
+               }
+           }
+       }
+     }
+ 
+   return this_alternative;
+ }
+ 
+ 
+ 
+ static int
+ letter_wins (c, data)
+   int c;
+   struct operand_data *data;
+ {
+   rtx op = data->x;
+ 
+   switch (c)
+     {
+     case 'p':
+       return strict_memory_address_p (GET_MODE (op), op);
+ 
+     case 'g':
+       /* Anything goes unless it is a REG and really has a hard reg
+          but the hard reg is not in the class GENERAL_REGS.  */
+       return (GENERAL_REGS == ALL_REGS
+               || GET_CODE (op) != REG
+               || reg_fits_class_p (op, GENERAL_REGS, 0, GET_MODE (op)));
+ 
+     case 'r':
+       return (GET_CODE (op) == REG
+               && (GENERAL_REGS == ALL_REGS
+                   || reg_fits_class_p (op, GENERAL_REGS, 0, GET_MODE (op))));
+ 
+     case 'X':
+       /* This is used for a MATCH_SCRATCH in the cases when we
+          don't actually need anything.  So anything goes any time. */
+       return 1;
+ 
+     case 'm':
+       return GET_CODE (op) == MEM;
+ 
+     case '<':
+       return (GET_CODE (op) == MEM
+               && (GET_CODE (XEXP (op, 0)) == PRE_DEC
+                   || GET_CODE (XEXP (op, 0)) == POST_DEC));
+ 
+     case '>':
+       return (GET_CODE (op) == MEM
+               && (GET_CODE (XEXP (op, 0)) == PRE_INC
+                   || GET_CODE (XEXP (op, 0)) == POST_INC));
+ 
+     case 'E':
+       /* Match any CONST_DOUBLE, but only if
+          we can examine the bits of it reliably.  */
+       if ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT
+                                || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)
+           && GET_CODE (op) != VOIDmode && ! flag_pretend_float)
+         return 0;
+       /* FALL THROUGH */
+     case 'F':
+       return (GET_CODE (op) == CONST_DOUBLE);
+ 
+     case 'G':
+     case 'H':
+       return (GET_CODE (op) == CONST_DOUBLE
+               && CONST_DOUBLE_OK_FOR_LETTER_P (op, c));
+ 
+     case 's':
+       if (GET_CODE (op) == CONST_INT
+           || (GET_CODE (op) == CONST_DOUBLE
+               && GET_MODE (op) == VOIDmode))
+         return 0;
+       /* FALL THROUGH */
+     case 'i':
+       return (CONSTANT_P (op));
+ 
+     case 'n':
+       return (GET_CODE (op) == CONST_INT
+               || (GET_CODE (op) == CONST_DOUBLE
+                   && GET_MODE (op) == VOIDmode));
+ 
+     case 'I':
+     case 'J':
+     case 'K':
+     case 'L':
+     case 'M':
+     case 'N':
+     case 'O':
+     case 'P':
+       return (GET_CODE (op) == CONST_INT
+               && CONST_OK_FOR_LETTER_P (INTVAL (op), c));
+ 
+ #ifdef EXTRA_CONSTRAINT
+     case 'Q':
+     case 'R':
+     case 'S':
+     case 'T':
+     case 'U':
+       return (EXTRA_CONSTRAINT (op, c));
+ #endif
+ 
+     case 'V':
+       return (GET_CODE (op) == MEM && ! offsettable_memref_p (op));
+ 
+     case 'o':
+       return (offsettable_memref_p (op));
+ 
+     default:
+       return (GET_CODE (op) == REG
+               && reg_fits_class_p (op, REG_CLASS_FROM_LETTER (c),
+                                    0, GET_MODE (op)));
+     }
+ }
+ 
+ 
+ 
+ /* Rules are now reformulated:
+     1. PUSHED OUTPUTs must be grouped near stack top;
+     2. POPPED INPUTs must be grouped near stack top;
+     3. non-POPPED INPUT with constraint joint with some PUSHED OUTPUT
+        requires this OUTPUT to use '&' earlyclobber. Otherwise, reload may
+        use the same virtual register for these operands, which may cause
+        reg-stack overflow, since the output register is pushed BEFORE the
+        input one is popped as dead in this insn.
+     4. PUSHED OUTPUT must have a single-register constraint; this determines
+        the order of pushing.
+     */
+ 
+ #define CHECK_ERROR(insn, str, arg) \
+     do { if (asm_noperands (PATTERN (insn)) >= 0)    \
+            error_for_asm (insn, str, arg);           \
+          else                                        \
+            abort ();                                 \
+     } while (0)
+ 
+ static int
+ check_rules (insn, regstack, info)
+      rtx insn;
+      stack regstack;
+      struct insn_info *info;
+ {
+   int malformed_asm = 0;
+   int i, j, k;
+   struct insn_info_reg *p, *q;
+   HARD_REG_SET popped_ins;
+   HARD_REG_SET pushed_outs;
+ 
+   CLEAR_HARD_REG_SET (popped_ins);
+   CLEAR_HARD_REG_SET (pushed_outs);
+ 
+   for (p = info->out; p <= info->out_last; p++)
+     {
+       /* Enforce rule #4: PUSHED OUTPUTs must have single-reg constraint */
+       if (reg_class_size[p->class] != 1)
+         {
+           CHECK_ERROR (insn, "Output constraint %d must specify a single register", i);
+           malformed_asm = 1;
+         }
+       IOR_HARD_REG_SET (pushed_outs, reg_class_contents[p->class]);
+     }
+ 
+   for (p = info->in; p <= info->in_last; p++)
+     {
+       if (p->flags & OUTPUT)
+         continue;
+       if (p->flags & POPPED)
+         set_hard_reg_bits_3 (&popped_ins, get_hard_regnum (regstack, p->reg),
+                              GET_MODE (p->reg));
+       else
+         { /* Rule #3 */
+           for (q = info->out; q <= info->out_last; q++)
+             if (! (q->flags & EARLYCLOBBER))
+               {
+                 /* Doing this check properly requires knowing the
+                    operand class required by REG_CLASS_FROM_LETTER, not
+                    STACK_REG_CLASS_FROM_LETTER.  Do this later, since it
+                    is of little use on T800; for now, just abort on any
+                    non-earlyclobbered output in the insn that have at
+                    least one non-popped input.
+ 
+                    Hmm... this requires `dup' insn to have
+                    the earlyclobber. This is unpleasant and quite
+                    unnecessary, since del_stack_reg_move () would remove
+                    this dup as a no-op move if SRC is the same as DEST.
+                    As a quick hack, detect this and (probably) similar
+                    cases with a machine-specific macro.  */
+ #ifdef INSN_OK_FOR_RULE_3
+                 if (! INSN_OK_FOR_RULE_3 (insn))
+ #endif
+ 		  {
+ 		    CHECK_ERROR (insn, "Output operand's constraint must use '&' earlyclobber", 0);
+ 		    malformed_asm = 1;
+ 		    break;
+ 		  }
+               }
+         }
+     }
+ 
+   /* Rules #1, #2: */
+   /* Clear bits for valid (grouped at stack tops) regs */
+   for (k = 0; k < STACK_REG_NSTACKS; ++k)
+     {
+       for (j = STACK_REG_FIRST(k); j <= STACK_REG_LAST(k); ++j)
+         {
+           if (! TEST_HARD_REG_BIT (pushed_outs, j))
+             break;
+           CLEAR_HARD_REG_BIT (pushed_outs, j);
+         }
+       for (j = STACK_REG_FIRST(k); j <= STACK_REG_LAST(k); ++j)
+         {
+           if (! TEST_HARD_REG_BIT (popped_ins, j))
+             break;
+           CLEAR_HARD_REG_BIT (popped_ins, j);
+         }
+     }
+ 
+   /* Enforce rule #1: PUSHED OUTPUTs must be grouped near stack top */
+   GO_IF_HARD_REG_EQUAL (pushed_outs, reg_class_contents[NO_REGS], win1);
+     CHECK_ERROR (insn, "Output regs must be grouped at top of stack", 0);
+     malformed_asm = 1;
+ 
+ win1:
+ 
+   /* Enforce rule #2: POPPED INPUTs must be grouped near stack top */
+   GO_IF_HARD_REG_EQUAL (popped_ins, reg_class_contents[NO_REGS], win2);
+     CHECK_ERROR (insn, 
+      "Implicitly popped input regs must be grouped at top of stack", 0);
+     malformed_asm = 1;
+ 
+ win2:
+ 
+   return (- malformed_asm);
+ }
+ 
+ 
+ /* Reduced version of check-rules for use from PLACE_INPUTS().
+    Only rule #2 is checked */
+ 
+ static int
+ check_rule_2 (regstack, info)
+      stack regstack;
+      struct insn_info *info;
+ {
+   int i, j, k;
+   struct insn_info_reg *p;
+   HARD_REG_SET popped_ins;
+ 
+   CLEAR_HARD_REG_SET (popped_ins);
+ 
+   for (p = info->in; p <= info->in_last; p++)
+     if (p->flags & POPPED)
+       set_hard_reg_bits_3 (&popped_ins, get_hard_regnum (regstack, p->reg),
+                            GET_MODE (p->reg));
+ 
+   /* Rule #2: */
+   /* Clear bits for valid (grouped at stack tops) regs */
+   for (k = 0; k < STACK_REG_NSTACKS; ++k)
+     for (j = STACK_REG_FIRST(k); j <= STACK_REG_LAST(k); ++j)
+       {
+         if (! TEST_HARD_REG_BIT (popped_ins, j))
+           break;
+         CLEAR_HARD_REG_BIT (popped_ins, j);
+       }
+ 
+   /* Check rule #2: POPPED INPUTs must be grouped near stack top */
+   GO_IF_HARD_REG_EQUAL (popped_ins, reg_class_contents[NO_REGS], win2);
+     return 0;
+ win2:
+   return 1;
+ }
+ 
+ 
+ static HARD_REG_SET *ior_set_arg;
+ 
+ static int
+ ior_set (insn, reg)
+      rtx insn;
+      rtx reg;
+ {
+   set_hard_reg_bits (ior_set_arg, reg);
+   return 0;
+ }
+ 
+ /* Scan PAT, which is a part of INSN, and record registers appearing in
+    a SET_DEST in DEST, and other registers in SRC.  For an SRC, store
+    the mode of the value currently living in the SRC in regstack->mode.
+    This information needs not be very accurate, since it is used only
+    to find out what is the correct mode to reload in/out of a reg
+    during the stack shuffling.  */
+ 
+ struct reg_life_data {
+   HARD_REG_SET dest;
+   HARD_REG_SET src;
+   HARD_REG_SET clobbered;
+   stack regstack;
+ };
+ 
+ static void
+ record_reg_life_pat (pat, data)
+      rtx pat;
+      struct reg_life_data *data;
+ {
+   register char *fmt;
+   register int i,j;
+ 
+   switch (GET_CODE (pat))
+     {
+     case REG:
+       if (STACK_REG_P (pat))
+         {
+           int regno = REGNO (pat);
+           int r = regno + HARD_REGNO_NREGS (regno, GET_MODE (pat));
+           while (--r >= regno)
+             {
+               SET_HARD_REG_BIT (data->src, r);
+               data->regstack->mode[r] = GET_MODE (pat);
+             }
+         }
+       return;
+ 
+     case SET:
+         {
+           /* Uncover the real SET_DEST.  Note that we don't expect
+              SUBREGs with SUBREG_REG != 0 here as those are stripped
+              at the start of the reg-stack pass.  */
+ 
+           rtx lhs = SET_DEST (pat);
+           while (GET_CODE (lhs) == SUBREG
+                  || GET_CODE (lhs) == STRICT_LOW_PART
+                  || GET_CODE (lhs) == ZERO_EXTRACT
+                  || GET_CODE (lhs) == SIGN_EXTRACT)
+             lhs = XEXP (lhs, 0);
+ 
+           /* MEM address should count for src rather than dest.  */
+ 
+           if (GET_CODE (lhs) == MEM)
+             record_reg_life_pat (XEXP (lhs, 0), data);
+           else if (STACK_REG_P (lhs))
+             set_hard_reg_bits (&data->dest, lhs);
+ 
+           record_reg_life_pat (SET_SRC (pat), data);
+         }
+       return;
+ 
+     case ASM_OPERANDS:
+       for (j = ASM_OPERANDS_INPUT_LENGTH(pat) - 1; j >= 0; j--)
+ 	record_reg_life_pat (ASM_OPERANDS_INPUT(pat, j), data);
+       return;
+ 
+     case USE:
+       record_reg_life_pat (XEXP (pat, 0), data);
+       return;
+ 
+     case CLOBBER:
+       if (STACK_REG_P (XEXP (pat, 0)))
+         set_hard_reg_bits (&data->clobbered, XEXP (pat, 0));
+       return;
+     }
+ 
+   fmt = GET_RTX_FORMAT (GET_CODE (pat));
+   for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)
+     if (fmt[i] == 'E')
+       for (j = XVECLEN (pat, i) - 1; j >= 0; j--)
+         record_reg_life_pat (XVECEXP (pat, i, j), data);
+     else if (fmt[i] == 'e')
+       record_reg_life_pat (XEXP (pat, i), data);
+ }
+ 
+ 
+ /* Return number of extra stack-reg operands for the INSN (which must be
+    CALL or RETURN). Extra operands are those not enclosed in the
+    insn's pattern, but rather mentioned in one of the USE insns
+    immediately preceding the INSN.  */
+ 
+ static int
+ n_extra_stack_reg_operands (insn)
+     rtx insn;
+ {
+   int n = 0;
+ 
+   while ((insn = PREV_INSN (insn))
+           && GET_CODE (insn) == INSN
+           && GET_CODE (PATTERN (insn)) == USE)
+     if (STACK_REG_P (XEXP (PATTERN (insn), 0)))
+       n++;
+   return(n);
+ }
+ 
+ 
+ /* Extension of n_extra_stack_reg_operands: scan extra operands,
+    recording the encountered stack registers in `reg_set' and their
+    modes in `mode'.  */
+ 
+ static int
+ record_extra_stack_reg_operands (insn, reg_set, mode)
+     rtx insn;
+     HARD_REG_SET *reg_set;
+     enum machine_mode *mode;
+ {
+   rtx body;
+   int n = 0;
+ 
+   if (reg_set)
+     CLEAR_HARD_REG_SET (*reg_set);
+ 
+   while ((insn = PREV_INSN (insn))
+           && GET_CODE (insn) == INSN
+           && GET_CODE (body = PATTERN (insn)) == USE)
+     if (STACK_REG_P (XEXP (body,0)))
+       {
+ 	rtx reg = XEXP (body, 0);
+         n++;
+         if (reg_set)
+           set_hard_reg_bits (reg_set, reg);
+         if (mode)
+ 	  mode[REGNO (reg)] = GET_MODE (reg);
+       }
+   return(n);
+ }
+ 
+ #ifdef CALL_INSN_FUNCTION_USAGE
+ 
+ /* Like record_extra_stack_reg_operands, but scans
+    CALL_INSN_FUNCTION_USAGE list rather than preceding USE insns */
+ 
+ static int
+ record_fusage_stack_reg_operands (insn, reg_set, mode)
+     rtx insn;
+     HARD_REG_SET *reg_set;
+     enum machine_mode *mode;
+ {
+   rtx link;
+   int n = 0;
+ 
+   if (reg_set)
+     CLEAR_HARD_REG_SET (*reg_set);
+ 
+   for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))
+     {
+       rtx body = XEXP (link, 0);
+       if (GET_CODE (body) == USE && STACK_REG_P (XEXP (body,0)))
+ 	{
+ 	  rtx reg = XEXP (body, 0);
+ 	  n++;
+ 	  if (reg_set)
+ 	    set_hard_reg_bits (reg_set, reg);
+ 	  if (mode)
+ 	    mode[REGNO (reg)] = GET_MODE (reg);
+ 	}
+     }
+   return(n);
+ }
+ #endif /* CALL_INSN_FUNCTION_USAGE */
+     
+ 
+ 
+ /* Skip the sequence of USE insns immediately preceding INSN.
+    This is used when we want to emit an insn before INSN
+    to avoid disturbing the neighborhood of USEs and the INSN. */
+ 
+ static rtx
+ skip_uses (insn)
+   rtx insn;
+ {
+   rtx prev;
+   while ((prev = PREV_INSN (insn))
+           && GET_CODE (prev) == INSN
+           && GET_CODE (PATTERN (prev)) == USE)
+     insn = prev;
+   return insn;
+ }
+ 
+ /* If PAT is a tablejump insn's pattern, find and return the table.
+    Otherwise, return 0. */
+ 
+ static rtx
+ find_jump_table (pat)
+   rtx pat;
+ {
+   rtx label, table;
+ 
+   if (GET_CODE (pat) == LABEL_REF)
+     {
+       label = XEXP (pat, 0);
+       if (GET_CODE (label) != CODE_LABEL)
+         abort ();
+       table = NEXT_INSN (label);
+       if (GET_CODE (table) == JUMP_INSN
+           && (GET_CODE (PATTERN (table)) == ADDR_DIFF_VEC
+               || GET_CODE (PATTERN (table)) == ADDR_VEC))
+         return table;
+     }
+   else
+     {
+       int i, j;
+       char *fmt = GET_RTX_FORMAT (GET_CODE (pat));
+ 
+       for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)
+         {
+           if (fmt[i] == 'e')
+             if (table = find_jump_table (XEXP (pat, i)))
+               return table;
+           if (fmt[i] == 'E')
+             for (j = 0; j < XVECLEN (pat, i); j++)
+               if (table = find_jump_table (XVECEXP (pat, i, j)))
+                 return table;
+         }
+     }
+   return 0;
+ }
+ 
+ 
+ 
+ /* Scan INSN, which is in BLOCK, and record the life & death of stack
+    registers in REGSTACK.  This function is called to process insns from
+    the last insn in a block to the first.  The actual scanning is done in
+    record_reg_life_pat.
+ 
+    ??? the comment is outdated...
+    If a register is live after a CALL_INSN, but is not a value return
+    register for that CALL_INSN, then code is emitted to initialize that
+    register.  The block_end[] data is kept accurate.
+ 
+    Existing death and unset notes for stack registers are deleted
+    before processing the insn. */
+ 
+ static void
+ record_reg_life (insn, regstack)
+      rtx insn;
+      stack regstack;
+ {
+   /* Skip non-insns and CLOBBER insns: those do not affect register life.
+      Skip USE insns, since the respective death note must not be attached
+      here, but rather to the real insn (CALL_INSN) that follows.  Such USE
+      will be taken care of when processing the CALL_INSN.  */
+   if (GET_RTX_CLASS (GET_CODE (insn)) != 'i'
+       || GET_CODE (PATTERN (insn)) == USE
+       || GET_CODE (PATTERN (insn)) == CLOBBER)
+     return;
+ 
+   /* Strip old death notes for stack regs from this insn */
+   {
+     rtx note;
+     rtx *note_link = &REG_NOTES(insn);
+     for (note = *note_link; note; note = XEXP (note, 1))
+       if (STACK_REG_P (XEXP (note, 0))
+           && (REG_NOTE_KIND (note) == REG_DEAD
+               || REG_NOTE_KIND (note) == REG_UNUSED))
+         *note_link = XEXP (note, 1);
+       else
+         note_link = &XEXP (note, 1);
+   }
+ 
+   /* Process all patterns in the insn. */
+   {
+     struct reg_life_data data;
+     int regno;
+     int k;
+ 
+     CLEAR_HARD_REG_SET (data.src);
+     CLEAR_HARD_REG_SET (data.dest);
+     CLEAR_HARD_REG_SET (data.clobbered);
+     data.regstack = regstack;
+ 
+     /* CALLs and RETURNs may have extra operands. Those count for SRC. */
+     if (GET_CODE (insn) == CALL_INSN
+         || GET_CODE (PATTERN (insn)) == RETURN)
+       record_extra_stack_reg_operands (insn, &data.src, regstack->mode);
+ 
+     /* GCC >2.6.0 describes extra operands in a special field in the
+        insn, instead of attaching separate USE insns before CALL insn.
+        Count them for SRC as well.  */
+ #ifdef CALL_INSN_FUNCTION_USAGE
+     if (GET_CODE (insn) == CALL_INSN)
+       record_fusage_stack_reg_operands (insn, &data.src, regstack->mode);
+ #endif /* CALL_INSN_FUNCTION_USAGE */
+ 
+     if (GET_CODE (insn) == CALL_INSN)
+       IOR_HARD_REG_SET (data.clobbered, call_used_reg_set);
+ 
+     record_reg_life_pat (PATTERN (insn), &data);
+ 
+     for (k = 0; k < STACK_REG_NSTACKS; ++k)
+       for (regno = STACK_REG_FIRST(k); regno <= STACK_REG_LAST(k); ++regno)
+         if (! TEST_HARD_REG_BIT (regstack->reg_set, regno))
+           {
+             if (TEST_HARD_REG_BIT (data.src, regno)
+                 && ! TEST_HARD_REG_BIT (data.dest, regno))
+               REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD,
+                   /* We want to indicate the death of a *single* hard
+                      register, not a multi-register value. Therefore
+                      we use QImode here, supposing HARD_REGNO_NREGS
+                      (called from find_regno_note) will always return
+                      1 for it. */
+                                           hard_reg[regno][(int) QImode],
+                                           REG_NOTES (insn));
+             else if (TEST_HARD_REG_BIT (data.dest, regno))
+               REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_UNUSED,
+                                           hard_reg[regno][(int) QImode],
+                                           REG_NOTES (insn));
+             if (TEST_HARD_REG_BIT (data.clobbered, regno))
+               REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_UNUSED,
+                                           hard_reg[regno][(int) QImode],
+                                           REG_NOTES (insn));
+           }
+ 
+     AND_COMPL_HARD_REG_SET (regstack->reg_set, data.dest);
+ 
+ 
+     /* There might be a reg that is live after an insn that clobbers
+        it in some way.  Emit zero-initializetion for such regs.
+        Do not bother if no regs live across this insn, though.  */
+ 
+     GO_IF_HARD_REG_EQUAL (regstack->reg_set, reg_class_contents[NO_REGS], m);
+ 
+     {
+       rtx next_insn = NEXT_INSN (insn);
+       HARD_REG_SET init_set;
+ 
+       ior_set_arg = &data.clobbered;
+       note_popped_inputs (insn, ior_set);
+ 
+       COPY_HARD_REG_SET (init_set, regstack->reg_set);
+       AND_HARD_REG_SET (init_set, data.clobbered);
+       emit_zero_init_before (&init_set, regstack, next_insn);
+ 
+       /* If the INSN was the end of a block, move the
+          block_end to point to the new insn. */
+ 
+       if (insn == block_end[BLOCK_NUM (insn)])
+         block_end[BLOCK_NUM (insn)] = PREV_INSN (next_insn);
+     }
+ 
+   m:
+     ;
+     IOR_HARD_REG_SET (regstack->reg_set, data.src);
+   }
+ }
+ 
+ /* Find all basic blocks of the function, which starts with FIRST.
+    For each JUMP_INSN, build the chain of LABEL_REFS on each CODE_LABEL. */
+ 
+ static void
+ find_blocks (first)
+      rtx first;
+ {
+   register rtx insn;
+   register int block;
+   register RTX_CODE prev_code = BARRIER;
+   register RTX_CODE code;
+   rtx label_value_list = 0;
+ 
+   /* Record where all the blocks start and end.
+      Record which basic blocks control can drop in to. */
+ 
+   block = -1;
+   for (insn = first; insn; insn = NEXT_INSN (insn))
+     {
+       /* Note that this loop must select the same block boundaries
+ 	 as code in reg_to_stack, but that these are not the same
+ 	 as those selected in flow.c.  */
+ 
+       code = GET_CODE (insn);
+ 
+       switch (code)
+         {
+           case JUMP_INSN:
+             {
+               /* Treat tablejump insn and the table following it as
+                  a whole; don't allow the table to fall into
+                  a separate block. */
+               rtx insn2 = find_jump_table (PATTERN (insn));
+               if (insn2)
+                 {
+                   insn = insn2;
+                   if (GET_CODE (PREV_INSN (insn)) != CODE_LABEL)
+                     abort ();
+                   /* delete old chain */
+                   LABEL_REFS (PREV_INSN (insn)) = PREV_INSN (insn);
+                 }
+             }
+             /* FALL THROUGH */
+ 
+           case INSN:
+           case CALL_INSN:
+             if (prev_code != JUMP_INSN && prev_code != BARRIER)
+               {
+                 block_end[block] = insn;
+                 break;
+               }
+             /* FALL THROUGH */
+ 
+           case CODE_LABEL:
+             block_begin[++block] = insn;
+             block_end[block] = insn;
+             block_drops_in[block] = prev_code != BARRIER;
+ 	    break;
+         }
+ 
+       if (GET_RTX_CLASS (code) == 'i')
+ 	{
+ 	  rtx note;
+ 
+ 	  /* Make a list of all labels referred to other than by jumps.  */
+ 	  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))
+ 	    if (REG_NOTE_KIND (note) == REG_LABEL)
+ 	      label_value_list = gen_rtx (EXPR_LIST, VOIDmode, XEXP (note, 0),
+ 					  label_value_list);
+ 	}
+ 
+       block_number[INSN_UID (insn)] = block;
+ 
+       if (code != NOTE)
+         prev_code = code;
+     }
+ 
+   if (block + 1 != blocks)
+     abort ();
+ 
+   /* generate all label references to the corresponding jump insn */
+   for (block = 0; block < blocks; block++)
+     {
+       insn = block_end[block];
+ 
+       if (GET_CODE (insn) == JUMP_INSN)
+ 	{
+ 	  rtx pat = PATTERN (insn);
+ 	  int computed_jump = 0;
+ 	  rtx x;
+ 
+ 	  if (GET_CODE (pat) == PARALLEL)
+ 	    {
+ 	      int len = XVECLEN (pat, 0);
+ 	      int has_use_labelref = 0;
+ 	      int i;
+ 
+ 	      for (i = len - 1; i >= 0; i--)
+ 		if (GET_CODE (XVECEXP (pat, 0, i)) == USE
+ 		    && GET_CODE (XEXP (XVECEXP (pat, 0, i), 0)) == LABEL_REF)
+ 		  has_use_labelref = 1;
+ 
+ 	      if (! has_use_labelref)
+ 		for (i = len - 1; i >= 0; i--)
+ 		  if (GET_CODE (XVECEXP (pat, 0, i)) == SET
+ 		      && SET_DEST (XVECEXP (pat, 0, i)) == pc_rtx
+ 		      && uses_reg_or_mem (SET_SRC (XVECEXP (pat, 0, i))))
+ 		    computed_jump = 1;
+ 	    }
+ 	  else if (GET_CODE (pat) == SET
+ 		   && SET_DEST (pat) == pc_rtx
+ 		   && uses_reg_or_mem (SET_SRC (pat)))
+ 	    computed_jump = 1;
+ 		    
+ 	  if (computed_jump)
+ 	    {
+ 	      for (x = label_value_list; x; x = XEXP (x, 1))
+ 		record_label_references (insn,
+ 					 gen_rtx (LABEL_REF, VOIDmode,
+ 						  XEXP (x, 0)));
+ 
+ 	      for (x = forced_labels; x; x = XEXP (x, 1))
+ 		record_label_references (insn,
+ 					 gen_rtx (LABEL_REF, VOIDmode,
+ 						  XEXP (x, 0)));
+ 	    }
+ 
+ 	  record_label_references (insn, pat);
+ 	}
+     }
+ }
+ 
+ /* Return 1 if X contain a REG or MEM that is not in the constant pool.  */
+ 
+ static int
+ uses_reg_or_mem (x)
+      rtx x;
+ {
+   enum rtx_code code = GET_CODE (x);
+   int i, j;
+   char *fmt;
+ 
+   if (code == REG
+       || (code == MEM
+ 	  && ! (GET_CODE (XEXP (x, 0)) == SYMBOL_REF
+ 		&& CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))))
+     return 1;
+ 
+   fmt = GET_RTX_FORMAT (code);
+   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)
+     {
+       if (fmt[i] == 'e'
+ 	  && uses_reg_or_mem (XEXP (x, i)))
+ 	return 1;
+ 
+       if (fmt[i] == 'E')
+ 	for (j = 0; j < XVECLEN (x, i); j++)
+ 	  if (uses_reg_or_mem (XVECEXP (x, i, j)))
+ 	    return 1;
+     }
+ 
+   return 0;
+ }
+ 
+ /* If current function returns its result in a stack register,
+    return the register rtx.  Otherwise return NULL_RTX.  */
+ 
+ static rtx
+ stack_result (decl)
+      tree decl;
+ {
+   rtx result = DECL_RTL (DECL_RESULT (decl));
+ 
+   if (result == 0)
+     return NULL_RTX;
+ 
+   if (!(GET_CODE (result) == REG
+         && REGNO (result) < FIRST_PSEUDO_REGISTER))
+     {
+ #ifdef FUNCTION_OUTGOING_VALUE
+       result
+         = FUNCTION_OUTGOING_VALUE (TREE_TYPE (DECL_RESULT (decl)), decl);
+ #else
+       result = FUNCTION_VALUE (TREE_TYPE (DECL_RESULT (decl)), decl);
+ #endif
+     }
+ 
+   return STACK_REG_P (result) ? result : NULL_RTX;
+ }
+ 
+ 
+ /* Determine which registers are live at the start of each basic
+    block of the function whose first insn is FIRST.
+ 
+    First, if the function returns a real_type, mark the function
+    return type as live at each return point, as the RTL may not give any
+    hint that the register is live.
+ 
+    Then, start with the last block and work back to the first block.
+    Similarly, work backwards within each block, insn by insn, recording
+    which regs are dead and which are used (and therefore live) in the
+    hard reg set of block_stack_in[].
+ 
+    After processing each basic block, if there is a label at the start
+    of the block, propagate the live registers to all jumps to this block.
+ 
+    As a special case, if there are regs live in this block, that are
+    not live in a block containing a jump to this label, and the block
+    containing the jump has already been processed, we must propagate this
+    block's entry register life back to the block containing the jump, and
+    restart life analysis from there.
+ 
+    In the worst case, this function may traverse the insns
+    REG_STACK_SIZE times.  This is necessary, since a jump towards the end
+    of the insns may not know that a reg is live at a target that is early
+    in the insns.  So we back up and start over with the new reg live.
+ 
+    If there are registers that are live at the start of the function,
+    insns are emitted to initialize these registers.  Something similar is
+    done after CALL_INSNs in record_reg_life. */
+ 
+ static void
+ stack_reg_life_analysis (first)
+      rtx first;
+ {
+   int block, i, k;
+   struct stack_def reg_stack;
+   rtx return_rtx = stack_result (current_function_decl);
+ 
+   if (return_rtx)
+     {
+       /* Find all RETURN insns and mark them. */
+ 
+       int value_regno = REGNO (return_rtx);
+       int value_nregs = HARD_REGNO_NREGS (value_regno, GET_MODE (return_rtx));
+ 
+       for (block = blocks - 1; block >= 0; block--)
+         if (GET_CODE (block_end[block]) == JUMP_INSN
+             && GET_CODE (PATTERN (block_end[block])) == RETURN)
+           {
+             /* See if this RETURN insn is preceded by (USE return_rtx).
+                If not, it is a void return from a non-void function, i.e.
+                the function returns a random value (with a warning).
+                For STACK_REG_STRICT machines, it is necessary to assign
+                some value to the return register; it's the best to do
+                this right before the RETURN insn, or else we'll have
+                to do this later, maybe in more than one control path.
+                For non-strict machines, it's OK to return with empty
+                reg-stack, so just don't mark return register live to
+                avoid unecessary bother.  */
+             int voidret = !n_extra_stack_reg_operands (block_end[block]);
+ 
+ #ifndef STACK_REG_STRICT
+             if (!voidret)
+ #endif
+             for (i = value_regno + value_nregs; --i >= value_regno; )
+               {
+                 SET_HARD_REG_BIT (block_out_reg_set[block], i);
+                 block_out_reg_mode[block][i] = GET_MODE (return_rtx);
+               }
+ #ifdef STACK_REG_STRICT
+             if (voidret)
+               emit_zero_init_before (&reg_stack.reg_set, reg_stack,
+                                      block_end[block]);
+ #endif
+           }
+ 
+ #ifdef FUNCTION_EPILOGUE
+       /* Mark of the end of last block if we "fall off" the end of the
+          function into the epilogue.
+          The case of void return is hard to detect here, so do nothing
+          with it but expect to deal with live regs at function start,
+          after calls, etc.  */
+ 
+       if (NEXT_INSN (block_end[blocks-1]) == 0
+           || GET_CODE (NEXT_INSN (block_end[blocks-1])) != BARRIER)
+         for (i = value_regno + value_nregs; --i >= value_regno; )
+           {
+             SET_HARD_REG_BIT (block_out_reg_set[blocks-1], i);
+             block_out_reg_mode[blocks-1][i] = GET_MODE (return_rtx);
+           }
+ #endif
+     }
+ 
+   /* now scan all blocks backward for stack register use */
+ 
+   block = blocks - 1;
+   while (block >= 0)
+     {
+       register rtx insn, prev;
+ 
+       /* current register status at last instruction */
+ 
+       COPY_HARD_REG_SET (reg_stack.reg_set, block_out_reg_set[block]);
+       bcopy (block_out_reg_mode[block], reg_stack.mode, sizeof(reg_stack.mode));
+ 
+       prev = block_end[block];
+       do
+         {
+           insn = prev;
+           prev = PREV_INSN (insn);
+ 
+           /* Bother processing only if the insn can affect the
+              stack-register's life.  Insns that mention stack-regs can
+              affect the life, as are the insns that have a potential of
+              clobbering some stack registers (eg CALL_INSN).
+              ??? To be completely honest, we'd have to additionally consult
+              INSN_CLOBBERS_REGNO_P here, but this macro is relatively
+              costly on T800, and returns true only for insns that mention
+              stack registers.  So it is omitted for now.  */
+ 
+           if (GET_MODE (insn) == QImode || GET_CODE (insn) == CALL_INSN)
+             record_reg_life (insn, &reg_stack);
+ 
+         } while (insn != block_begin[block]);
+ 
+       /* Set the state at the start of the block.  Mark that no
+          register mapping information known yet. */
+ 
+       COPY_HARD_REG_SET (block_stack_in[block].reg_set, reg_stack.reg_set);
+       bcopy (reg_stack.mode, block_stack_in[block].mode, sizeof(reg_stack.mode));
+       block_stack_in[block].top[0] = -2;
+ 
+       /* If there is a label, propagate our register life to all jumps
+          to this label. */
+ 
+       if (GET_CODE (insn) == CODE_LABEL)
+         {
+           register rtx label;
+           int must_restart = 0;
+ 
+           for (label = LABEL_REFS (insn); label != insn;
+                label = LABEL_NEXTREF (label))
+             {
+               int jump_block = BLOCK_NUM (CONTAINING_INSN (label));
+ 
+               if (jump_block < block)
+                 ior_regset_and_mode (&block_out_reg_set[jump_block],
+                                      block_out_reg_mode[jump_block],
+                                      &block_stack_in[block]);
+               else
+                 {
+                   /* The block containing the jump has already been
+                      processed.  If there are registers that were not known
+                      to be live then, but are live now, we must back up
+                      and restart life analysis from that point with the new
+                      life information. */
+ 
+                   GO_IF_HARD_REG_SUBSET (block_stack_in[block].reg_set,
+                                          block_out_reg_set[jump_block],
+                                          win);
+ 
+                   ior_regset_and_mode (&block_out_reg_set[jump_block],
+                                        block_out_reg_mode[jump_block],
+                                        &block_stack_in[block]);
+ 
+                   block = jump_block;
+                   must_restart = 1;
+ 
+                 win:
+                   ;
+                 }
+             }
+           if (must_restart)
+             continue;
+         }
+ 
+       if (block_drops_in[block])
+         ior_regset_and_mode (&block_out_reg_set[block-1],
+                              block_out_reg_mode[block-1],
+                              &block_stack_in[block]);
+       block -= 1;
+     }
+ 
+   /* If any reg is live at the start of the first block of a
+      function, then we must guarantee that the reg holds some value by
+      generating our own "load" of that register.  Otherwise a 387 would
+      fault trying to access an empty register. */
+ 
+   block_begin[0] = emit_zero_init_before (&reg_stack.reg_set, &reg_stack,
+                                           block_begin[0]);
+ }
+ 
+ 
+ /* For all the regs marked live in regstack, set the respective bit
+    in set and set mode from regstack->mode.  */
+ 
+ static void
+ ior_regset_and_mode (set, mode, regstack)
+      HARD_REG_SET *set;
+      enum machine_mode *mode;
+      stack regstack;
+ {
+   int i,k;
+ 
+   IOR_HARD_REG_SET (*set, regstack->reg_set);
+   for (k = 0; k < STACK_REG_NSTACKS; k++)
+     for (i = STACK_REG_FIRST (k); i <= STACK_REG_LAST (k); i++)
+       {
+         if (TEST_HARD_REG_BIT (regstack->reg_set, i))
+           mode[i] = regstack->mode[i];
+       }
+ }
+ 
+ 
+ /* Load zero into the regs in init_set.  This is called when we learn,
+    during the life analysis, that some reg is live after an insn that
+    clobbers it, or at the function start.
+ 
+    (I never came across this on T800, but it seems reasonable to support.)
+    
+    The fact that a register appears live at the function start does
+    not necessarily imply an error in the user program: it merely means
+    that we could not determine that there wasn't such an error, just
+    as -Wunused sometimes gives "incorrect" warnings.  In those cases,
+    these initializations will do no harm.  */
+ 
+ static rtx
+ emit_zero_init_before (init_set, regstack, insn)
+   HARD_REG_SET *init_set;
+   stack regstack;
+   rtx insn;
+ {
+   int k, i;
+ 
+   GO_IF_HARD_REG_EQUAL (*init_set, reg_class_contents[NO_REGS], end);
+   
+   /* Note that we are inserting virtual register references here:
+      these insns must be processed by convert_regs later.  Also, these
+      insns will not be in block_number, so BLOCK_NUM() will fail for them. */
+ 
+   start_sequence ();
+   for (k=0; k < STACK_REG_NSTACKS; k++)
+     for (i = STACK_REG_FIRST (k); i <= STACK_REG_LAST (k); i++)
+       if (TEST_HARD_REG_BIT (*init_set, i))
+         {
+           enum machine_mode mode = regstack->mode[i];
+           rtx insn2;
+ 
+           /* We may not initialize in a multi-register mode, for maybe
+              not all parts of the multi-register are in init_set.  */
+           if (HARD_REGNO_NREGS (i, mode) > 1)
+             mode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (mode));
+           if (HARD_REGNO_NREGS (i, mode) > 1)
+             abort ();
+ 
+           insn2 = emit_move_insn (hard_reg[i][(int) mode], CONST0_RTX (mode));
+           PUT_MODE (insn2, QImode);
+           CLEAR_HARD_REG_BIT (regstack->reg_set, i);
+         }
+   insn = emit_insn_before (gen_sequence (), insn);
+   end_sequence ();
+   
+ end:
+   return insn;
+ }
+ 
+ 
+ /*****************************************************************************
+    This section deals with stack register substitution, and forms the second
+    pass over the RTL.
+  *****************************************************************************/
+ 
+ /* Replace REG, which is a pointer to a stack reg RTX, with an RTX for
+    the desired hard REGNO. */
+ 
+ static void
+ replace_reg (reg, regno)
+      rtx *reg;
+      int regno;
+ {
+   if (! TEST_HARD_REG_BIT (reg_class_contents[STACK_REGS], regno)
+       || ! STACK_REG_P (*reg))
+     abort ();
+ 
+   *reg = hard_reg[regno][(int) GET_MODE (*reg)];
+ }
+ 
+ 
+ /* Find the hard register number of virtual register REG in REGSTACK.
+    The hard register number is relative to the top of the stack.  -1 is
+    returned if the register is not currently on stack, ie is not live. */
+ 
+ static int
+ get_hard_regnum (regstack, reg)
+      stack regstack;
+      rtx reg;
+ {
+   int i, k;
+ 
+   if (! STACK_REG_P (reg))
+     abort ();
+ 
+   k = STACK_REG_STACKNO (REGNO (reg));
+   for (i = regstack->top[k]; i <= STACK_REG_LAST(k); ++i)
+     if (regstack->reg[i] == REGNO (reg))
+       return (STACK_REG_FIRST(k) + (i - regstack->top[k]));
+ 
+   return (-1);
+ }
+ 
+ int
+ stacks_equal (stack1, stack2)
+      stack stack1;
+      stack stack2;
+ {
+   int k;
+   for (k = 0; k < STACK_REG_NSTACKS; ++k)
+     {
+       int r = stack1->top[k];
+       if (r != stack2->top[k])
+         return(0);
+       for (  ; r <= STACK_REG_LAST(k); ++r)
+         if (stack1->reg[r] != stack2->reg[r])
+           return(0);
+     }
+   return(1);
+ }
+ 
+ /* Initialize stack order. REG_SET field should be set up before calling.  */
+ 
+ void
+ init_stack (bstack)
+      stack bstack;
+ {
+   int k,r;
+ 
+   /* First, bring all stacks to empty state */
+   /* Then, push live regs in default order */
+ 
+   for (k=0; k < STACK_REG_NSTACKS; ++k)
+     {
+       bstack->top[k] = STACK_REG_LAST(k) + 1;
+       for (r = STACK_REG_LAST (k); r >= STACK_REG_FIRST (k); --r)
+         if (TEST_HARD_REG_BIT (bstack->reg_set, r))
+           bstack->reg[--bstack->top[k]] = r;
+     }
+ }
+ 
+ print_stack(s)
+      stack s;
+ {
+   int i,k;
+ 
+   printf("%08x\n", s->reg_set);
+   for (k = 0; k < STACK_REG_NSTACKS; ++k)
+     {
+       printf("stack %d: top %02d: [", k, s->top[k]);
+       for (i = s->top[k]; i <= STACK_REG_LAST(k); ++i)
+         {
+           printf("%02d ", s->reg[i]);
+         }
+       printf("]\n");
+     }
+ }
+ 
+ /* Delete INSN from the RTL.  Mark the insn, but don't remove it from
+    the chain of insns.  Doing so could confuse block_begin and block_end
+    if this were the only insn in the block. */
+ 
+ static void
+ delete_insn_for_stacker (insn)
+      rtx insn;
+ {
+   PUT_CODE (insn, NOTE);
+   NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;
+   NOTE_SOURCE_FILE (insn) = 0;
+ }
+ 
+ /* See if the INSN is a redundant stack-reg move that should be
+    deleted to avoid confusing output patterns.
+    If it is, delete it and return 1. Otherwise, return 0.
+    REGSTACK is the current stack, which is modified to reflect
+    the effect of deleting the insn. */
+ 
+ static int
+ del_stack_reg_move (insn, regstack)
+      rtx insn;
+      stack regstack;
+ {
+   rtx pat = PATTERN (insn);
+   rtx src, dest;
+   int i;
+ 
+   switch (GET_CODE (pat))
+     {
+     case SET:
+       src = SET_SRC (pat);
+       dest = SET_DEST (pat);
+       break;
+ 
+     case PARALLEL:
+       src = dest = NULL_RTX;
+       for (i = XVECLEN (pat, 0); --i >= 0; )
+ 	{
+ 	  rtx x = XVECEXP (pat, 0, i);
+ 
+ 	  if (GET_CODE (x) == SET)
+ 	    {
+ 	      if (dest != NULL_RTX)
+ 		return 0;  /* more than one SET -- not a simple move */
+ 	      src = SET_SRC (x);
+ 	      dest = SET_DEST (x);
+ 	    }
+ 	  else if (GET_CODE (x) == USE || GET_CODE (x) == CLOBBER)
+ 	    ;
+ 	  else
+ 	    return 0;  /* Not SET, USE, or CLOBBER -- not a simple move. */
+ 	}
+       break;
+ 
+     default:
+       return 0;
+     }
+       
+   if (STACK_REG_P (src) && STACK_REG_P (dest)
+       && STACK_REG_STACKNO (REGNO (src)) == STACK_REG_STACKNO (REGNO (dest)))
+     {
+       /* Yes; this insn is a write from one stack reg to another reg in the
+ 	 same register stack.  Our actions depend on three conditions:
+            (1) whether SRC dies in this insn
+            (2) whether DEST is unused after this insn
+            (3) whether SRC and DEST are the same reg. */
+ 
+       int i, r;
+       enum { SRC_DIES=1, DEST_UNUSED=2, SAME_REG=4 } cond;
+ 
+       cond = 0;
+       if (find_regno_note (insn, REG_DEAD, REGNO (src)))
+         cond |= SRC_DIES;
+       if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))
+         cond |= DEST_UNUSED;
+       if (REGNO (src) == REGNO (dest))
+         cond |= SAME_REG;
+ 
+       switch (cond)
+         {
+           case 0:
+ 
+             /* SRC and DST are distinct registers, both used later.
+                This is not a regundant move, but true DUP insn */
+ 
+             return 0;
+ 
+           case SRC_DIES:
+ 
+             /* SRC dies here, but DEST is not UNUSED. Just change the
+                register mapping and delete the insn. */
+ 
+ 	    r = get_hard_regnum (regstack, src);
+ 	    if (r < 0)
+ 	      abort ();
+ 	    i = HARD_REGNO_NREGS (REGNO (src), GET_MODE (src));
+ 	    while (--i >= 0)
+ 	      {
+ 		REG_BY_HARD_REGNO (regstack, r+i) = REGNO (dest)+i;
+ 		SET_HARD_REG_BIT (regstack->reg_set, REGNO (dest)+i);
+ 		CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (src)+i);
+ 	      }
+             delete_insn_for_stacker (insn);
+             return (1);
+ 
+             /* Life anlysis never produces first combination, but it
+                can appear as a result of atom_force_single_reg().
+                It's simpler to ignore this here than to bother
+                removing the note there, so treat this as bare
+                SAME_REG.  */
+ 
+           case SAME_REG+SRC_DIES:
+           case DEST_UNUSED:
+           case SAME_REG:
+ 
+             /* Move to unused reg or no-op move. These are to be
+                simply deleted. */
+ 
+             delete_insn_for_stacker (insn);
+             return (1);
+ 
+           case SAME_REG+DEST_UNUSED:
+           case SRC_DIES+DEST_UNUSED:
+           case SAME_REG+SRC_DIES+DEST_UNUSED:
+ 
+             /* Both SRC and DEST are not used after this insn.
+                Delete this move and pop SRC off the stack. */
+ 
+             {
+               HARD_REG_SET drop_set;
+               CLEAR_HARD_REG_SET (drop_set);
+ 	      i = HARD_REGNO_NREGS (REGNO (src), GET_MODE (src));
+ 	      while (--i >= 0)
+ 		SET_HARD_REG_BIT (drop_set, REGNO (src)+i);
+               start_sequence ();
+               STACK_REG_EMIT_DROPS (regstack, drop_set);
+               emit_insn_before (gen_sequence (), insn);
+               end_sequence ();
+               delete_insn_for_stacker (insn);
+               return (1);
+             }
+ 
+ 	  default:
+             abort ();
+         }
+     }
+ 
+   /* This move should not be deleted */
+   return 0;
+ }
+ 
+ 
+ /* Undo the action of place_reg().  */
+ static void
+ displace_reg (regstack, place, reg)
+   stack regstack;
+   int place;
+   rtx reg;
+ {
+   int last = place + HARD_REGNO_NREGS (place, GET_MODE (reg)) - 1;
+   int i;
+ 
+   for (i = place; i <= last; ++i)
+     regstack->reg[i] = -1;
+ }
+ 
+ 
+ /* Place a reg at specified PLACE in REGSTACK.
+    Return 0 if the place is already occupied or is not large enough */
+ int
+ place_reg (regstack, place, reg)
+   stack regstack;
+   int place;
+   rtx reg;
+ {
+   int last = place + HARD_REGNO_NREGS (place, GET_MODE (reg)) - 1;
+   int r = REGNO (reg);
+   int i;
+ 
+   if (last > STACK_REG_LAST (STACK_REG_STACKNO (place)))
+     return 0;
+ 
+   for (i = place; i <= last; ++i)
+     {
+       if (regstack->reg[i] != -1)
+         {
+           while ( --i >= place )
+             regstack->reg[i] = -1;
+           return 0;
+         }
+       regstack->reg[i] = r++;
+     }
+ 
+   return 1;
+ }
+ 
+ 
+ /* Reorder reg-stack if necessary, so as to place input operands
+    where they are required to be by the constraints.
+    It is made by exhaustive testing of all possible placements.
+    This probably needs to be redone for machines with deeper stacks,
+    as the worst case complexity is O(n!/(n-m)!), where m is the number
+    of stack-reg operands and n is the stack depth.
+ 
+    Recursive call is not the best but easiest way to implement
+    the exhaustive testing. There was also a powerful temptation to make
+    all operands_* stuff static, but this implies much corrections
+    elsewhere. */
+ 
+ static int
+ place_inputs (i, oldstack, newstack, info)
+     int i;
+     stack newstack;
+     stack oldstack;
+     struct insn_info *info;
+ {
+   int sz = info->in_last - &info->in[-1];
+   for (  ; i < sz; ++i)
+     {
+       int k = STACK_REG_STACKNO (REGNO (info->in[i].reg));
+       /* PLACE is an index in stack->reg[].
+          REGNO is the hard register number of the operand.
+          Conversions:
+            regno = STACK_REG_FIRST(k) + place - stack->top[k];
+            place = regno - STACK_REG_FIRST(k) + stack->top[k];
+       */
+       int oldregno = get_hard_regnum (oldstack, info->in[i].reg);
+       int oldplace = oldregno - STACK_REG_FIRST(k) + oldstack->top[k];
+       int place;
+ 
+       /* If this reg is in a suitable place, and this place
+          is still vacant in the new stack, try this variant first */
+ 
+       if (TEST_HARD_REG_BIT (reg_class_contents[info->in[i].class], oldregno)
+           && place_reg (newstack, oldplace, info->in[i].reg))
+         {
+           if (place_inputs (i+1, oldstack, newstack, info))
+             return (1);
+           displace_reg (newstack, oldplace, info->in[i].reg);
+         }
+ 
+       /* Try all vacant places in order */
+       for (place = newstack->top[k]; place <= STACK_REG_LAST (k); ++place)
+         if (place != oldplace
+             && TEST_HARD_REG_BIT (reg_class_contents[info->in[i].class],
+                             STACK_REG_FIRST(k) + place - newstack->top[k])
+             && place_reg (newstack, place, info->in[i].reg))
+           {
+             if (place_inputs (i+1, oldstack, newstack, info))
+               return (1);
+             displace_reg (newstack, place, info->in[i].reg);
+           }
+ 
+       /* Cannot find a place for this reg. This means that the 
+          constraints are contradictory. The caller should report
+          an error */
+ 
+       return (0);
+     }
+ 
+   /* No regs left -- the placement is done. The last thing
+      to check is the rule #2: All implicitly popped input regs must be
+      closer to the top of the reg-stack than any input that is
+      not implicitly popped. If this is not satisfied, do not accept
+      this placement */
+ 
+   return check_rule_2 (newstack, info);
+ }
+ 
+ 
+ static int
+ place_regs (oldstack, newstack, info)
+     stack newstack;
+     stack oldstack;
+     struct insn_info *info;
+ {
+   int i,j,k;
+   HARD_REG_SET placed_regs;
+ 
+   for (k = 0; k < STACK_REG_NSTACKS; ++k)
+     for (i = STACK_REG_FIRST (k); i <= STACK_REG_LAST (k); ++i)
+       newstack->reg[i] = -1;
+ 
+   if (!place_inputs (0, oldstack, newstack, info))
+     return 0;
+ 
+   /* OK, newstack->reg contains the input regs in proper places.
+      Now we are to place all other live regs, which need not be
+      in particular places. */
+ 
+   /* Set bits for placed input regs in placed_regs */
+ 
+   CLEAR_HARD_REG_SET (placed_regs);
+   for (k = 0; k < STACK_REG_NSTACKS; ++k)
+     for (i = STACK_REG_FIRST (k); i <= STACK_REG_LAST (k); ++i)
+       if (newstack->reg[i] != -1)
+         SET_HARD_REG_BIT (placed_regs, newstack->reg[i]);
+ 
+   /* A reg can be simply left in its present place, if the place
+      is not occupied by an already-placed reg. Do such regs... */
+ 
+   for (k = 0; k < STACK_REG_NSTACKS; ++k)
+     for (i = oldstack->top[k]; i <= STACK_REG_LAST(k); ++i)
+       if (newstack->reg[i] == -1
+           && !TEST_HARD_REG_BIT (placed_regs, oldstack->reg[i]))
+         {
+           newstack->reg[i] = oldstack->reg[i];
+           SET_HARD_REG_BIT (placed_regs, newstack->reg[i]);
+         }
+ 
+   /* Place all yet nonplaced regs in an arbitrary order */
+ 
+   for (k = 0; k < STACK_REG_NSTACKS; ++k)
+     {
+       j = newstack->top[k];
+       for (i = oldstack->top[k]; i <= STACK_REG_LAST(k); ++i)
+         if (!TEST_HARD_REG_BIT (placed_regs, oldstack->reg[i]))
+           {
+             while (newstack->reg[j] != -1)
+               {
+                 ++j;
+                 if (j > STACK_REG_LAST(k))
+                   abort ();
+               }
+             newstack->reg[j] = oldstack->reg[i];
+             SET_HARD_REG_BIT (placed_regs, newstack->reg[j]);
+           }
+     }
+ 
+   /* All live regs must be in PLACED_REGS by now */
+ 
+   GO_IF_HARD_REG_EQUAL (newstack->reg_set, placed_regs, win);
+     abort ();
+ win:
+   return 1;
+ }
+ 
+ void
+ set_hard_reg_bits (set, reg)
+      HARD_REG_SET *set;
+      rtx reg;
+ {
+   int r = REGNO (reg);
+   int nr = HARD_REGNO_NREGS (r, GET_MODE (reg));
+ 
+   while (nr--)
+     SET_HARD_REG_BIT (*set, r + nr);
+ }
+ 
+ void
+ set_hard_reg_bits_3 (set, r, mode)
+      HARD_REG_SET *set;
+      int r;
+      enum machine_mode mode;
+ {
+   int nr = HARD_REGNO_NREGS (r, mode);
+ 
+   while (nr--)
+     SET_HARD_REG_BIT (*set, r + nr);
+ }
+ 
+ void
+ clear_hard_reg_bits (set, reg)
+      HARD_REG_SET *set;
+      rtx reg;
+ {
+   int r = REGNO (reg);
+   int nr = HARD_REGNO_NREGS (r, GET_MODE (reg));
+ 
+   while (nr--)
+     CLEAR_HARD_REG_BIT (*set, r + nr);
+ }
+ 
+ /* Traverse the insn, changing virtual register numbers into hard reg
+    numbers, which are the offsets from the appropriate reg-stack top.  */
+ 
+ #ifndef STACK_REGS_SUBSTITUTION_UNNECESSARY
+ static void
+ subst_regs_recursively (loc, regstack, busy_regs)
+      rtx *loc;
+      stack regstack;
+      HARD_REG_SET *busy_regs;
+ {
+   rtx x = *loc;
+   int in_clobber = 0;
+ 
+   if (!x) return;
+ 
+   if (GET_CODE (x) == CLOBBER)
+     {
+       in_clobber = 1;
+       loc = &XEXP (x,0);
+       x = *loc;
+     }
+ 
+   if (STACK_REG_P (x))
+     {
+       int regnum = get_hard_regnum (regstack, x);
+       
+       if (regnum < 0)
+         /* The reg is not live before this insn.  This can happen
+            if the reg either is a pushed output or is clobbered
+            in this insn.  */
+         if (in_clobber)
+           {
+             /* It's OK for a CLOBBER to reference a reg that is not
+                live. However, we must make sure it does not conflict
+                with other operands of this insn.  Otherwise,
+                constrain_operands called while final pass will fail.
+                We will select a reg which is dead both before and
+                after this insn. */
+     
+             int k = STACK_REG_STACKNO (REGNO (x));
+     
+             regnum = STACK_REG_FIRST (k);
+             while (TEST_HARD_REG_BIT (*busy_regs, regnum))
+               if (++regnum > STACK_REG_LAST (k))
+                 /* Cannot find a reg? There must be at least one... */
+                 abort ();
+           }
+         else
+           {
+             /* For pushed outputs, do nothing, since pushed outputs
+                (probably) never appear explicitly in the written form
+                of an insn and thus final.c will not use the register
+                numbers anyway.  */
+             set_hard_reg_bits (busy_regs, x);
+             return;
+           }
+ 
+       replace_reg (loc, regnum);
+       set_hard_reg_bits (busy_regs, *loc);
+       return;
+     }
+ 
+   /* Traverse subexpressions in the natural order so as to process
+      CLOBBERS in the end, after BUSY_REGS set is completely formed.  */
+   {
+     register char *fmt = GET_RTX_FORMAT (GET_CODE (x));
+     register int i,j;
+ 
+     /* In EXPR_LISTs, avoid anything but REG_{DEAD,UNUSED}:
+        the things like REG_EQUIV may refer to other insns.  */
+     if (GET_CODE (x) == EXPR_LIST
+         && REG_NOTE_KIND (x) != REG_DEAD
+         && REG_NOTE_KIND (x) != REG_UNUSED)
+         fmt = "xe";
+ 
+     for (i = 0; i < GET_RTX_LENGTH (GET_CODE (x)); i++)
+       if (fmt[i] == 'E')
+         for (j = 0; j < XVECLEN (x, i); j++)
+           subst_regs_recursively (&XVECEXP (x, i, j), regstack, busy_regs);
+       else if (fmt[i] == 'e')
+         subst_regs_recursively (&XEXP (x, i), regstack, busy_regs);
+   }
+ }
+ #endif /* STACK_REGS_SUBSTITUTION_UNNECESSARY */
+ 
+ 
+ void
+ print_insn_info(info)
+     struct insn_info *info;
+ {
+   struct insn_info_reg *p;
+   static char *reg_class_names[] = REG_CLASS_NAMES;
+ 
+   printf("<is_asm = %d\n", info->is_asm);
+ 
+   for (p = info->in; p <= info->in_last; p++)
+     {
+       printf(" in[%d] : ", p - info->in);
+       print_rtl(stdout, p->reg);
+       printf(" flags %02x class %s\n", p->flags, reg_class_names[p->class]);
+     }
+   for (p = info->out; p <= info->out_last; p++)
+     {
+       printf(" out[%d] : ", p - info->out);
+       print_rtl(stdout, p->reg);
+       printf(" flags %02x class %s\n", p->flags, reg_class_names[p->class]);
+     }
+   printf(">\n");
+ }
+ 
+ 
+ static void
+ analyse_insn (insn, info)
+     rtx insn;
+     struct insn_info *info;
+ {
+   int n_operands;
+   int i;
+ 
+ #if 0  /* it is in recog.h -- redundant here. */
+   /* insn_extract() interface */
+   extern rtx recog_operand[];
+   extern rtx *recog_operand_loc[];
+ #endif
+ 
+   rtx *operands = recog_operand;
+   char *const *constraints;
+ 
+   info->is_asm = ((n_operands = asm_noperands (PATTERN (insn))) >= 0);
+   CLEAR_HARD_REG_SET (info->out_regs);
+   info->in_last  = &info->in[-1];
+   info->out_last = &info->out[-1];
+ 
+   if (info->is_asm)
+     {
+       rtx body = PATTERN (insn);
+       constraints = (char **) alloca (n_operands * sizeof (char *));
+       decode_asm_operands (body, operands, recog_operand_loc,
+                            (char **)constraints, NULL_PTR);
+       /* We will decide which operand is input and which is output
+          later in usual way (from constraints). expand_asm_operands()
+          guarantees that '='s are set properly */
+     }
+   else
+     {
+       int insn_code = recog_memoized (insn);
+       if (insn_code < 0)
+         fatal_insn_not_found (insn);
+ 
+       n_operands = insn_n_operands[insn_code];
+       constraints = insn_operand_constraint[insn_code];
+       insn_extract (insn);
+ 
+ #ifdef CALL_INSN_FUNCTION_USAGE
+       if (GET_CODE (insn) == CALL_INSN)
+ 	{
+ 	  rtx link;
+ 	  for (link = CALL_INSN_FUNCTION_USAGE (insn); link;
+ 	       link = XEXP (link, 1))
+ 	    {
+ 	      rtx body = XEXP (link, 0);
+ 	      if (GET_CODE (body) == USE && STACK_REG_P (XEXP (body,0)))
+ 		{
+ 		  rtx reg = XEXP (body, 0);
+ 		  info->in_last++;
+ 		  info->in_last->reg = reg;
+ 
+ 		  /* Extra operands have no constraints; so consult
+ 		     machine-dependent macros to find CLASS and FLAGS */
+ 
+ 		  info->in_last->flags =
+ 		    STACK_REG_EXTRA_OPERAND_FLAGS (insn, info->in_last->reg);
+ 		  info->in_last->class =
+ 		    STACK_REG_EXTRA_OPERAND_CLASS (insn, info->in_last->reg);
+ 		}
+ 	    }
+ 	}
+ #endif /* CALL_INSN_FUNCTION_USAGE */
+ 
+       if (GET_CODE (insn) == CALL_INSN
+ #ifdef FUNCTION_EPILOGUE
+           || GET_CODE (PATTERN (insn)) == CONST_INT     /* nop */
+ #endif
+           || GET_CODE (PATTERN (insn)) == RETURN)
+         {
+           /* Those insns may have extra operands ... */
+           int n = n_extra_stack_reg_operands (insn);
+           if (n > 0)
+             {
+               rtx prev = insn;
+               while (n--)
+                 {
+                   rtx reg = XEXP (PATTERN (prev = PREV_INSN (prev)), 0);
+ 
+                   if (STACK_REG_P (reg))
+                     {
+                       info->in_last++;
+                       info->in_last->reg = reg;
+                       /* Extra operands have no constraints; so,
+                          consult macros to find CLASS and FLAGS... */
+                       info->in_last->flags = STACK_REG_EXTRA_OPERAND_FLAGS (insn, info->in_last->reg);
+                       info->in_last->class = STACK_REG_EXTRA_OPERAND_CLASS (insn, info->in_last->reg);
+                     }
+                 }
+             }
+         }
+     }
+ 
+   /* Most info is provided by constraints; extract it.  If no constraint
+      alternative matches, that is a compiler bug: we should have caught
+      such an insn during reload.  */
+   if (analyse_constraints (insn, n_operands, operands, constraints, info) < 0)
+     abort ();
+ }
+ 
+ 
+ /* Helper function for SORT_INSN_INFO_{IN,OUT} */
+ 
+ static int
+ sort_insn_info_cmp(r1, r2)
+     struct insn_info_reg *r1, *r2;
+ {
+   return STACK_REG_LOAD_ORDER (r1->class) - STACK_REG_LOAD_ORDER (r2->class);
+ }
+ 
+ 
+ /* Sort IN array in an INSN_INFO structure by HARD regno, ie in the   
+    order the virtual regs should be pushed. */
+ 
+ static void
+ sort_insn_info_in(info)
+     register struct insn_info *info;
+ {
+   int sz = info->in_last - &info->in[-1];
+ 
+   if (sz > 1)
+     qsort (info->in, sz, sizeof (struct insn_info_reg), sort_insn_info_cmp);
+ }
+ 
+ /* Likewise for OUT */
+ 
+ static void
+ sort_insn_info_out(info)
+     register struct insn_info *info;
+ {
+   int sz = info->out_last - &info->out[-1];
+ 
+   if (sz > 1)
+     qsort (info->out, sz, sizeof (struct insn_info_reg), sort_insn_info_cmp);
+ }
+ 
+ 
+ /* Remove from REGSTACK any inputs that the asm implicitly popped.
+    This can be called to process either POPPED or JUMP_POPPED inputs */
+ 
+ static void
+ pop_inputs (regstack, info, popped)
+   stack regstack;
+   struct insn_info *info;
+   char popped;              /* either POPPED or JUMP_POPPED */
+ {
+   int i;
+   struct insn_info_reg *p;
+ 
+   for (p = info->in; p <= info->in_last; p++)
+     if ((p->flags & (popped|INPUT)) == (popped|INPUT))
+       {
+         /* p->reg might not be at the top of stack.  But that's OK,
+            because all we need to do is pop the right number of regs
+            off of the top of a reg-stack.  check_rules() guarantees
+            that all implicitly popped regs are grouped at the top of
+            the reg-stack. */
+ 
+         int k = STACK_REG_STACKNO (REGNO (p->reg));
+         int nr = HARD_REGNO_NREGS (REGNO (p->reg), GET_MODE (p->reg));
+         while (nr--)
+           {
+             CLEAR_HARD_REG_BIT (regstack->reg_set,
+                                 regstack->reg[regstack->top[k]]);
+             regstack->top[k]++;
+           }
+       }
+ }
+ 
+ /* Substitute stack hard reg numbers for stack virtual registers in
+    INSN.  Non-stack register numbers are not changed.  REGSTACK is the
+    current stack contents. Insns may be emitted as needed to arrange the
+    register stack based on the contents of the insn. */
+ 
+ static void
+ subst_stack_regs (insn, regstack, jumpstack)
+      rtx insn;
+      stack regstack;
+      stack jumpstack;
+ {
+   register int i,k;
+ 
+   rtx body = PATTERN (insn);
+   rtx prev;
+ 
+   struct stack_def stack_before;  /* reg-stack state just before insn */
+   struct insn_info inf;
+ 
+ 
+   if (GET_MODE (insn) != QImode)
+     return;
+ 
+   if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')
+     abort();
+ 
+   if (GET_CODE (body) == USE)
+     /* Do not substitute hard regs; this may be revisited during
+        the scan for extra operands */
+     return;
+ 
+   if (GET_CODE (body) == CLOBBER)
+ 	/* A special kind of insn that recog doesn't recognize; skip it too */
+     return;
+ 
+   /* See if this is a reg->reg MOVE insn that can (and should) be deleted */
+ 
+   if (del_stack_reg_move (insn, regstack) > 0)
+     return;
+ 
+   analyse_insn (insn, &inf);
+ 
+   /* Reorder stack so as the input regs take the places where
+      the insn expects to see them */
+ 
+   bcopy ((char *) regstack, &stack_before, sizeof (stack_before));
+ 
+   if (! place_regs (&stack_before, regstack, &inf))
+     {
+       CHECK_ERROR (insn,
+        "Wrong constraints; unable to arrange stack before insn", 0);
+       return; 
+     }
+ 
+   /* Now that the regs are placed, we can check rules */
+   if (check_rules (insn, regstack, &inf) < 0)
+     return;
+ 
+   /* emit insns before INSN to make sure the reg-stack is in the right
+      order.  */
+ 
+   change_stack (insn, &stack_before, regstack, emit_insn_before);
+ 
+   /* Now remove from REGSTACK any inputs that the insn implicitly popped.
+      Note that old state of REGSTACK is kept in TEMP_STACK, thus retaining
+      the info necessary for hard reg numbers' substitution */
+ 
+   if (GET_CODE (insn) == JUMP_INSN)
+     {
+       /* Jump insn on some machines pops the stack diffrently when the
+          jump is taken and when it is not. Here we account for popping
+          in the `jump taken' case. */
+       bcopy (regstack, jumpstack, sizeof (*jumpstack));
+       pop_inputs (jumpstack, &inf, JUMP_POPPED);
+     }
+ 
+   pop_inputs (regstack, &inf, POPPED);
+ 
+   /* Add to REGSTACK any outputs that the insn implicitly pushed.
+      We currently suppose jump insns to output identically both
+      when jump is taken and when it is not. */
+ 
+   {
+     struct insn_info_reg *p;
+ 
+     sort_insn_info_out(&inf);
+ 
+     /* Regs with higher regno should be pushed first */
+     for (p = inf.out_last; p >= inf.out; p--)
+       {
+         int vregno = REGNO (p->reg);
+         int k = STACK_REG_STACKNO (vregno);
+         int r = vregno + HARD_REGNO_NREGS (vregno, GET_MODE (p->reg));
+ 
+         while (--r >= vregno)
+           {
+             regstack->reg[--regstack->top[k]] = r;
+             SET_HARD_REG_BIT (regstack->reg_set, r);
+             regstack->mode[r] = GET_MODE (p->reg);
+ 
+             if (GET_CODE (insn) == JUMP_INSN)
+               {
+                 jumpstack->reg[--jumpstack->top[k]] = r;
+                 SET_HARD_REG_BIT (jumpstack->reg_set, r);
+                 jumpstack->mode[r] = GET_MODE (p->reg);
+               }
+           }
+       }
+   }
+ 
+   /* Find what regs are to be dropped due to being REG_UNUSED ouput
+      or REG_DEAD input that the insn didn't implicitly pop.  If the insn
+      didn't implicitly pop an input reg, that reg will still be live. */
+ 
+   /* We will not do any dropping for JUMP_STACK here; this is in the
+      competence of CONVERT_REGS. */
+ 
+   {
+     HARD_REG_SET drop_set;
+     CLEAR_HARD_REG_SET (drop_set);
+     {
+       rtx note;
+       for (note = REG_NOTES (insn); note; note = XEXP (note, 1))
+         {
+           int r;
+ 
+ 	  /* Ignore things like (expr_list:REG_UNUSED (scratch:SI) */
+           if (GET_CODE (XEXP (note, 0)) != REG)
+ 	    continue;
+ 
+ 	  r = REGNO (XEXP (note, 0));
+           if (TEST_HARD_REG_BIT (regstack->reg_set, r)
+               && (REG_NOTE_KIND (note) == REG_UNUSED
+                   || REG_NOTE_KIND (note) == REG_DEAD
+                      && !TEST_HARD_REG_BIT (inf.out_regs, r)))
+             set_hard_reg_bits (&drop_set, XEXP (note, 0));
+         }
+     }
+ 
+     /* Emit insns to drop the regs that we've just found. The place to
+       insert insns is after the INSN except when the insn is a TABLEJUMP, in
+       which case the place is just after the jump table.
+       ??? optimization: skip dropping if the tablejump is followed by a BARRIER  */
+ 
+     {
+       rtx drop_place = 0;       /* the insn to insert the drops after */
+ 
+       if (GET_CODE (insn) != JUMP_INSN
+           || !(drop_place = find_jump_table (PATTERN (insn))))
+         drop_place = insn;
+ 
+       start_sequence ();
+       STACK_REG_EMIT_DROPS (regstack, drop_set);
+       emit_insn_after (gen_sequence (), drop_place);
+       end_sequence ();
+     }
+   }
+ 
+ #ifndef STACK_REGS_SUBSTITUTION_UNNECESSARY
+   /* Now that we aren't going to use find_regno_note() anymore, we can
+      finally substitute hard reg numbers. */
+ 
+   /* ??? subst_regs_recursively this currently does wrong for output
+      registers (it takes registrer numbers from stack_before, which is
+      ok for input regs, but not for output.  Probably fixing it only
+      requires to pass stack_after as an additional parameter, but on
+      t800 substitution is not needed at all, so leave it to the future  */
+ 
+   {
+     HARD_REG_SET busy_regs;
+     CLEAR_HARD_REG_SET (busy_regs);
+ 
+     subst_regs_recursively (&PATTERN (insn), &stack_before, &busy_regs);
+     subst_regs_recursively (&REG_NOTES (insn), &stack_before, &busy_regs);
+   }
+ #endif /* STACK_REGS_SUBSTITUTION_UNNECESSARY */
+ }
+ 
+ 
+ /* Change the organization of the stack so that it fits a new basic
+    block.  Some registers might have to be popped, but there can never be
+    a register live in the new block that is not now live.
+ 
+    Insert any needed insns before or after INSN.  WHEN is emit_insn_before
+    or emit_insn_after. OLD is the original stack layout, and NEW is
+    the desired form.  OLD is updated to reflect the code emitted, ie, it
+    will be the same as NEW upon return.
+ 
+    This function will not preserve block_end[].  But that information
+    is no longer needed once this has executed. */
+ 
+ static void
+ change_stack (insn, old, new, when)
+      rtx insn;
+      stack old;
+      stack new;
+      rtx (*when)();
+ {
+   int reg;
+   HARD_REG_SET drop_set;
+ 
+   start_sequence ();
+ 
+   /* Pop any registers that are not needed in the new block. */
+ 
+   COPY_HARD_REG_SET (drop_set, old->reg_set);
+   AND_COMPL_HARD_REG_SET (drop_set, new->reg_set);
+ 
+   STACK_REG_EMIT_DROPS (old, drop_set);
+ 
+   if (new->top[0] < 0)
+     {
+       /* If the new block has never been processed, then it can inherit
+          the old stack order. */
+ 
+       bcopy (old, new, sizeof (*new));
+     }
+   else
+     {
+       /* This block has been entered before, and we must match the
+          previously selected stack order. */
+ 
+       STACK_REG_EMIT_SWAPS (old, new);
+ 
+       /* At this point there must be no differences. */
+ 
+       if (!stacks_equal (old,new))
+         abort ();
+     }
+ 
+     if (when == emit_insn_before)
+       insn = skip_uses (insn);
+     (*when) (gen_sequence (), insn);
+     end_sequence ();
+ }
+ 
+ /* Check PAT, which points to RTL in INSN, for a LABEL_REF.  If it is
+    found, ensure that a jump from INSN to the code_label to which the
+    label_ref points ends up with the same stack as that at the
+    code_label.  Do this by inserting insns just before the code_label to
+    pop and rotate the stack until it is in the correct order.  REGSTACK
+    is the order of the register stack in INSN.
+ 
+    Any code that is emitted here must not be later processed as part
+    of any block, as it will already contain hard register numbers. */
+ 
+ static void
+ goto_block_pat (insn, regstack, pat)
+      rtx insn;
+      stack regstack;
+      rtx pat;
+ {
+   rtx label;
+   rtx insn_before_label;
+   rtx new_label;
+   int label_block;
+   stack label_stack;
+   struct stack_def temp_stack;
+ 
+   if (GET_CODE (pat) != LABEL_REF)
+     {
+       int i, j;
+       char *fmt = GET_RTX_FORMAT (GET_CODE (pat));
+ 
+       /* When dealing with ADDR_DIFF_VEC, skip XEXP(0), which is
+          the label at the jump table start; it need not be processed
+          since control never gets there. */
+       int lim = (GET_CODE (pat) == ADDR_DIFF_VEC);
+ 
+       for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= lim; i--)
+         {
+           if (fmt[i] == 'e')
+             goto_block_pat (insn, regstack, XEXP (pat, i));
+           if (fmt[i] == 'E')
+             for (j = 0; j < XVECLEN (pat, i); j++)
+               goto_block_pat (insn, regstack, XVECEXP (pat, i, j));
+         }
+       return;
+     }
+ 
+   label = XEXP (pat, 0);
+   if (GET_CODE (label) != CODE_LABEL)
+     abort ();
+ 
+   if (INSN_UID (label) <= 0)
+     return;
+ 
+   insn_before_label = PREV_INSN (label);
+   label_block = BLOCK_NUM (label);
+   label_stack = &block_stack_in[label_block];
+ 
+   /* Emit the agreeing insn sequence.  Note that CHANGE_STACK will
+      initialize LABEL_STACK if it is not yet initialized. */
+ 
+   bcopy (regstack, &temp_stack, sizeof (temp_stack));
+   change_stack (label, &temp_stack, label_stack, emit_insn_before);
+ 
+   /* If no insns were emitted, i.e. the stacks are identical, we are done. */
+ 
+   if (NEXT_INSN (insn_before_label) == label)
+     return;
+ 
+   /* Emit a label for the new code, and point the original insn at
+      this new label. We can't use redirect_jump here, because we're using
+      fld[4] of the code labels as LABEL_REF chains, no NUSES counters. */
+ 
+   new_label = gen_label_rtx ();
+   emit_label_after (new_label, insn_before_label);
+   LABEL_REFS (new_label) = new_label;
+ 
+   /* The old label_ref will no longer point to the code_label it now uses,
+      so strip the label_ref from the code_label's chain of references. */
+   {
+     rtx *ref;
+     for (ref = &LABEL_REFS (label); *ref != pat; ref = &LABEL_NEXTREF (*ref))
+       if (*ref == label)
+         abort ();
+     *ref = LABEL_NEXTREF (*ref);
+   }
+ 
+   XEXP (pat, 0) = new_label;
+   record_label_references (insn, PATTERN (insn));
+ 
+   if (JUMP_LABEL (insn) == label)
+     JUMP_LABEL (insn) = new_label;
+ 
+   /* If this block is entered at top, we need to insert a jump to go
+      round the agreeing sequence just emitted.  */
+   {
+     int this_block_drops_in = block_drops_in[label_block];
+ 
+     /* Indicate that now control drops into the block from the
+        agreeing sequence we have just emitted.  */
+     block_drops_in[label_block] |= 2;
+     if (!this_block_drops_in)
+       return;
+   }
+ 
+ #ifdef JUMP_CLOBBERS_REGS
+   /* On some machines, we cannot use jump to go around the agreeing
+      sequence (e.g. on T800 the jump insn changes reg-stack).  In
+      this case, an alternative technique is used: emit the sequence
+      of insns which makes stack the same as it was just after jump to
+      this block, in order to neutralize the effect of agreeing
+      sequence we're going to emit. */
+   {
+     HARD_REG_SET push_set;
+ 
+     bcopy (label_stack, &temp_stack, sizeof (temp_stack));
+ 
+     /* REGSTACK may have some regs live which are not in LABEL_STACK.
+        Initialize those to zero. */
+     COPY_HARD_REG_SET (push_set, regstack->reg_set);
+     AND_COMPL_HARD_REG_SET (push_set, temp_stack.reg_set);
+     start_sequence ();
+     STACK_REG_EMIT_PUSHES (&temp_stack, push_set);
+     emit_insn_after (gen_sequence (), insn_before_label);
+     end_sequence ();
+     
+     change_stack (new_label, &temp_stack, regstack, emit_insn_before);
+   }
+ #else
+   {
+     rtx new_jump = emit_jump_insn_after (gen_jump (label), insn_before_label);
+     record_label_references (new_jump, PATTERN (new_jump));
+     JUMP_LABEL (new_jump) = label;
+     emit_barrier_after (new_jump);
+   }
+ #endif
+ 
+ }
+ 
+ 
+ /* Perform stack register substitution for insns between INSN and
+    LAST_INSN.  Return LAST_INSN  */
+ 
+ static rtx
+ subst_stack_regs_from_to (insn, last_insn, regstack, jumpstack)
+     rtx insn;
+     rtx last_insn;
+     stack regstack;
+     stack jumpstack;
+ {
+   rtx next_insn = insn;
+   do
+     {
+       /* Remember the NEXT_INSN, because subst_stack_regs emits new
+ 	 insns after INSN */
+       insn = next_insn;
+       next_insn = NEXT_INSN (insn);
+       subst_stack_regs (insn, regstack, jumpstack);
+     }
+   while (insn != last_insn);
+ 
+   return last_insn;
+ }
+ 
+ 
+ /* Do stack register substitution within a *group* of insns. The 
+    purpose of this function is to try reg-stack loading optimization
+    prior to actual stack reg substitution. Example (T800):
+    the expression
+         x - 5
+    might get compiled into
+         ldc 5; ldl x; sub;
+    which would be transformed while reg substitution into
+         ldc 5; ldl x; rev; sub;
+    but is optimized by SUBST_STACK_REGS_IN_GROUP to
+         ldl x; ldc 5; sub;
+ 
+    Insns like ldl,ldc are recognized to be `load atoms'. A load
+    atom makes no side effect and takes no stack register input; its
+    sole action is to load a value at the top of a reg-stack.
+ 
+    Insn group is considered to consist of zero or more load atoms
+    followed by a regular insn.
+ 
+    This function takes a group starting from INSN1 and spanning at
+    most to END_INSN, does register substitution in the group, and
+    returns the last insn processed.  REGSTACK on entry reflect the
+    stack state before INSN1.  Upon return REGSTACK shows the stack
+    state at the last insn in the group processed, and if that insn is
+    a JUMP_INSN, JUMPSTACK shows the stack state at the label this insn
+    jumps to if jump is taken.  */
+ 
+ static rtx
+ subst_stack_regs_in_group (insn1, end_insn, regstack, jumpstack)
+     rtx insn1, end_insn;
+     stack regstack;
+     stack jumpstack;
+ {
+   rtx insn;
+   rtx general_insn = 0;
+   rtx insn0 = PREV_INSN (insn1);
+   rtx insert_before;
+ 
+   struct atom {
+     rtx start;          /* first insn of the atom */
+     rtx end;            /* last insn of the atom */
+     rtx reg;            /* the reg this atom loads */
+     struct atom *next;
+   } *atoms = 0;
+ 
+   /* Find the general insn that ends the group, collecting the load
+      atoms meanwhile */
+ 
+   insn = insn1;
+   do
+     {
+       rtx atom_end;
+ 
+       /* Allow atoms to be interspersed with NOTEs and CLOBBERs.  It
+ 	 seems that it will not harm if we reorder the CLOBBERs
+ 	 occasionally--unlike USEs which must be kept close to the
+ 	 insn they precede, as they may supply extra operands to the
+ 	 insn. */
+ 
+       if (GET_CODE (insn) == NOTE)
+ 	continue;
+       if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == CLOBBER)
+ 	continue;
+ 
+       atom_end = recognize_load_atom (insn, end_insn);
+       if (atom_end)
+         {
+           struct atom *new_atom = (struct atom *) alloca (sizeof (struct atom));
+ 
+           new_atom->start = insn;
+           new_atom->end = atom_end;
+           new_atom->reg = SET_DEST (PATTERN (atom_end));
+           if (GET_CODE (new_atom->reg) != REG) abort();
+           new_atom->next = atoms;
+           atoms = new_atom;
+           if (new_atom->start != new_atom->end)
+             atom_force_single_reg (new_atom->start, new_atom->end, new_atom->reg);
+           insn = atom_end;
+         }
+       else
+ 	{
+ 	  /* INSN is not an atom. */
+ 
+ 	  insert_before = insn;
+ 
+ 	  /* Skep USEs which may precede the real general insn */
+ 
+ 	  do
+ 	    {
+ 	      if (GET_CODE (insn) == INSN
+ 		  && GET_CODE (PATTERN (insn)) == USE)
+ 		continue;
+ 	      general_insn = insn;
+ 	      break;
+ 	    }
+ 	  while (insn != end_insn && (insn = NEXT_INSN (insn)));
+ 
+ 	  break;
+         }
+     }
+   while (insn != end_insn && (insn = NEXT_INSN (insn)));
+ 
+   /* If we hit end_insn before finding the general insn, or the
+      general insn we found is not a real insn, or if is doesn't
+      mention stack registers, it imposes no stack layout requirements.
+      Then we have no reason to reorder preceding atoms; just process
+      this group as it is.  */
+ 
+   if (! general_insn
+       || GET_RTX_CLASS (GET_CODE (general_insn)) != 'i'
+       || GET_MODE (general_insn) != QImode
+       || GET_CODE (PATTERN (general_insn)) == USE)
+     return subst_stack_regs_from_to (insn1, insn, regstack, jumpstack);
+ 
+   /* For now, do the simplest transformation possible: reorder the
+      load atoms so as to save some stack shuffling afterwards. */
+   {
+     struct insn_info inf;
+     struct insn_info_reg *p;
+     struct atom *a;
+ 
+     analyse_insn (general_insn, &inf);
+     sort_insn_info_in(&inf);
+ 
+     for (p = inf.in; p <= inf.in_last; p++)
+       for (a = atoms; a; a = a->next)
+         if (REGNO (a->reg) == REGNO (p->reg))
+           {
+             rtx insert_after = PREV_INSN (insert_before);
+             if (insert_after != a->end)
+               reorder_insns (a->start, a->end, insert_after);
+             insert_before = a->start;
+             break;
+           }
+   }
+ 
+   /* INSN1 might go invalid because of the reordering; use INSN0 instead */
+   return subst_stack_regs_from_to (NEXT_INSN (insn0), general_insn,
+                                    regstack, jumpstack);
+ }
+ 
+ 
+ /* Tell if the INSN is a start of `load atom', which is an insn or insn
+    sequence with a sole effect of loading a value onto a reg stack. If
+    it is, the last insn in the atom is returned.  */
+ 
+ static rtx
+ recognize_load_atom (insn, end_insn)
+     rtx insn;
+     rtx end_insn;
+ {
+   rtx body = PATTERN (insn);
+   rtx last_atom_insn;
+   rtx loaded_reg;
+ 
+   if (GET_CODE (insn) != INSN)
+     return 0;
+ 
+   /* See if the insn has no effect except loading a value onto a
+      reg-stack. CLOBBERs are not allowed. */
+ 
+   if (GET_CODE (body) == SET)
+     {
+       rtx src = SET_SRC (body);
+       rtx dest = SET_DEST (body);
+ 
+       /* Destination must be a plain stack reg.  Source may be
+          anything not mentioning stack regs.  */
+       if (! STACK_REG_P (dest)
+           || stack_reg_mentioned (src))
+         return 0;
+     }
+   else
+     return 0;
+ 
+   /* Yes, INSN is valid for atom start.  Now look if the insn that
+      follows has no effect except taking the value loaded by INSN off
+      the stack and loading another value instead; eg, the first insn
+      loads a memory address and the second replaces it with the
+      contents of the memory cell at this address.  */
+ 
+   last_atom_insn = insn;
+   while (insn != end_insn)
+     {
+       insn = NEXT_INSN (insn);
+       body = PATTERN (insn);
+ 
+       /* Allow NOTEs inside atoms: eg, NOTE_INSN_DELETED */
+ 
+       if (GET_CODE (insn) == NOTE)
+ 	continue;
+ 
+       /* Even CALL_INSN cannot belong to a load atom, since it may clobber
+ 	 certain regs. JUMPs, LABELs and BARRIERs are out too.  */
+ 
+       if (GET_CODE (insn) != INSN)
+         break;
+ 
+       /* Ignore CLOBBERs that precede no-conflict blocks  */
+ 
+       if (GET_CODE (body) == CLOBBER)
+ 	continue;
+ 
+       if (GET_CODE (body) == SET)
+         {
+           rtx src = SET_SRC (body);
+           rtx dest = SET_DEST (body);
+ 	  loaded_reg = SET_DEST (PATTERN (last_atom_insn));
+ 
+           /* Destination must be a stack reg of the same reg-stack as
+              the reg loaded by INSN.  Source may be anything
+              mentioning the only stack reg, namely the one loaded by
+              INSN.  This reg must either be set or die here.  */
+ 
+           if (! STACK_REG_P (dest)
+               || STACK_REG_STACKNO (REGNO (dest))
+                  != STACK_REG_STACKNO (REGNO (loaded_reg))
+               || HARD_REGNO_NREGS (REGNO (loaded_reg), GET_MODE (loaded_reg))
+                  > HARD_REGNO_NREGS (REGNO (dest), GET_MODE (dest))
+               /* This check unnecessarily misses if dest is wider than
+                  loaded_reg and actually covers it, but has a different
+                  regno.  But that probably does not worth the bother... */
+               || !(REGNO (loaded_reg) == REGNO (dest)
+                    || find_regno_note (insn, REG_DEAD, REGNO (loaded_reg)))
+                  /* I think the presense of the death note makes the
+                     check for presense of the reg in SRC redundant; so
+                     check only that no other stack reg is mentioned.  */
+               || stack_reg_but_one_mentioned (src, loaded_reg)
+                  /* But do the check if we haven't seen the death note.  */
+               || (REGNO (loaded_reg) == REGNO (dest)
+                   && !stack_reg_mentioned (src)))
+             break;
+         }
+       else
+         break;
+ 
+       /* INSN2 proved to be a valid continuation for the atom. */
+       last_atom_insn = insn;
+     }
+ 
+   /* Now INSN is the last insn in the atom found.  */
+   return last_atom_insn;
+ }
+ 
+ 
+ /* This procedure fixes up multi-insn atoms to make them use the
+    only stack register, namely the one which is the value of the atom.
+    Otherwise, we may abort during processing reordered atoms because of
+    the atom's internal use of a stack reg which has already been
+    loaded by another atom reinserted ahead of this one.
+    Example:
+         ldl 0; ldnl 0
+    Suppose `ldl' sets the virtual register Areg and `ldnl' sets the
+    virtual register Breg. This procedure will change Areg in both
+    SET_DEST of `ldl' and memory address of `ldnl' to Areg, so that
+    the atom will use the only stack register Breg.
+ 
+    Note that atom_force_single_reg and atom_force_single_reg_1 take
+    shortcuts assuming the insn they operate upon are valid atoms */
+ 
+ static void
+ atom_force_single_reg (start, end, reg)
+     rtx start, end, reg;
+ {
+   rtx insn = PREV_INSN (start);
+   do {
+     insn = NEXT_INSN (insn);
+     if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')
+       {
+ 	rtx note;
+ 
+ 	/* REG_UNUSED notes require special handling when only a part
+ 	   of the loaded value is UNUSED.  */
+ 
+ 	for (note = REG_NOTES (insn); note; note = XEXP (note, 1))
+ 	  switch (REG_NOTE_KIND (note))
+ 	    {
+ 	    case REG_UNUSED:
+ 	      {
+ 		rtx *loc = &XEXP (note, 0);
+ 		rtx dest = SET_DEST (PATTERN (insn));
+ 
+ 		if (STACK_REG_P (*loc))
+ 		  {
+ 		    /* We can assume the notes are for one-word-wide
+ 		       registers -- we know how record_reg_life works.  */
+ 		    int subword = REGNO (*loc) - REGNO (dest);
+ 		    *loc = hard_reg[REGNO (reg) + subword][GET_MODE (*loc)];
+ 		  }
+ 	      }
+ 	      break;
+ 
+ 	    case REG_DEAD:
+ 	      {
+ 		rtx *loc = &XEXP (note, 0);
+ 		if (STACK_REG_P (*loc))
+ 		  *loc = hard_reg[REGNO (reg)][GET_MODE (*loc)];
+ 	      }
+ 	      break;
+ 	    }
+ 
+ 	/* Change all mentions of stack registers within the PATTERN */
+ 
+         atom_force_single_reg_1 (&PATTERN (insn), reg);
+       }
+   } while (insn != end);
+ }
+ 
+ static void
+ atom_force_single_reg_1 (loc, reg)
+     rtx *loc, reg;
+ {
+   if (!*loc)
+     return;
+ 
+   if (STACK_REG_P (*loc))
+     *loc = hard_reg[REGNO (reg)][GET_MODE (*loc)];
+   else
+     {
+       register char *fmt = GET_RTX_FORMAT (GET_CODE (*loc));
+       register int i,j;
+ 
+       for (i = GET_RTX_LENGTH (GET_CODE (*loc)) - 1; i >= 0; i--)
+         if (fmt[i] == 'E')
+           for (j = XVECLEN (*loc, i) - 1; j >= 0; j--)
+             atom_force_single_reg_1 (&XVECEXP (*loc, i, j), reg);
+         else if (fmt[i] == 'e')
+           atom_force_single_reg_1 (&XEXP (*loc, i), reg);
+     }
+ }
+ 
+ 
+ /* Traverse all basic blocks in a function, converting the register
+    references in each insn from the "flat" register file that gcc uses, to
+    the stack-like registers the 387 uses. */
+ 
+ static void
+ convert_regs ()
+ {
+   register int block, reg;
+   register rtx insn, next;
+   struct stack_def reg_stack;
+   struct stack_def jump_stack;
+ 
+   for (block = 0; block < blocks; block++)
+     {
+       stack bstack = &block_stack_in[block];
+ 
+       /* If this block has not been previously encountered, choose a
+          default mapping for any stack regs live on entry */
+ 
+       if (bstack->top[0] < 0)
+         init_stack (bstack);
+ 
+       /* Process all insns in this block.  Keep track of `next' here,
+          so that we don't process any insns emitted while making
+          substitutions in INSN. */
+ 
+       bcopy (&block_stack_in[block], &reg_stack, sizeof (reg_stack));
+       insn = block_begin[block];
+       do
+         {
+           if (GET_MODE (insn) == QImode)
+             insn = subst_stack_regs_in_group (insn, block_end[block],
+ 					      &reg_stack, &jump_stack);
+         }
+       while (insn != block_end[block] && (insn = NEXT_INSN (insn)));
+ 
+       /* Something failed if the stack life doesn't match. */
+ 
+       GO_IF_HARD_REG_EQUAL (reg_stack.reg_set, block_out_reg_set[block], win);
+         abort ();
+ 
+     win:
+       /* If the block ends with a JUMP_INSN, call GOTO_BLOCK_PAT to
+          make the stack at the jump target block agree with JUMP_STACK. */
+ 
+       if (GET_CODE (block_end[block]) == JUMP_INSN)
+         goto_block_pat (block_end[block], &jump_stack,
+                         PATTERN (block_end[block]));
+ 
+       /* Likewise handle the case where we fall into the next block. */
+ 
+       if (block < blocks - 1 && block_drops_in[block+1] & 1)
+         change_stack (insn, &reg_stack, &block_stack_in[block+1],
+                       emit_insn_after);
+     }
+ 
+ #ifdef FUNCTION_EPILOGUE
+   /* There is a couple of things to worry about if the last block
+      "falls off into epilogue."
+      
+      Beware! This code is untested.  */
+ 
+   if (insn == 0 || GET_CODE (insn) != BARRIER)
+     {
+       rtx return_rtx = stack_result (current_function_decl);
+   
+ #if STACK_REG_STRICT
+       /* If the last basic block is the end of a loop, and that loop has
+          regs live at its start, then the last basic block will have
+          regs live at its end that need to be popped before the
+          function returns.  */
+ 
+       HARD_REG_SET drop_set;
+   
+       COPY_HARD_REG_SET (drop_set, regstack->reg_set);
+       if (return_rtx)
+         clear_hard_reg_bits (&drop_set, return_rtx)
+       start_sequence ();
+       STACK_REG_EMIT_DROPS (regstack, drop_set);
+       emit_insn_after (gen_sequence (), insn);
+       end_sequence ();
+ #endif
+   
+       /* In case of a multi-register return value, we may need to reorder
+          regstack for registers to appear in the right order on return.
+          We do this by making a dummy insn sequence that can be processed
+          by the code that knows how to reorder regstack before a RETURN
+          insn.  */
+       if (return_rtx)
+         {
+           insn = emit_insn_after (gen_rtx (USE, VOIDmode, return_rtx), insn);
+           insn = emit_insn_after (gen_nop (), insn);
+           PUT_MODE (insn, QImode);
+           subst_stack_regs (insn, &reg_stack, &jump_stack);
+ 
+           /* OK, now the stack shuffling sequence (if any) is emitted
+              before the nop.  No more need for the nop... */
+           delete_insn_for_stacker (insn);
+         }
+     }
+ #endif
+ }
+ 
+ /* Check expression PAT, which is in INSN, for label references.  if
+    one is found, print the block number of destination to FILE. */
+ 
+ static void
+ print_blocks (file, insn, pat)
+      FILE *file;
+      rtx insn, pat;
+ {
+   register RTX_CODE code = GET_CODE (pat);
+   register int i;
+   register char *fmt;
+ 
+   if (code == LABEL_REF)
+     {
+       register rtx label = XEXP (pat, 0);
+ 
+       if (GET_CODE (label) != CODE_LABEL)
+         abort ();
+ 
+       fprintf (file, " %d", BLOCK_NUM (label));
+ 
+       return;
+     }
+ 
+   fmt = GET_RTX_FORMAT (code);
+   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)
+     {
+       if (fmt[i] == 'e')
+         print_blocks (file, insn, XEXP (pat, i));
+       if (fmt[i] == 'E')
+         {
+           register int j;
+           for (j = 0; j < XVECLEN (pat, i); j++)
+             print_blocks (file, insn, XVECEXP (pat, i, j));
+         }
+     }
+ }
+ 
+ /* Write information about stack registers and stack blocks into FILE.
+    This is part of making a debugging dump.  */
+ static void
+ dump_stack_info (file)
+      FILE *file;
+ {
+   register int block;
+ 
+   fprintf (file, "\n%d stack blocks.\n", blocks);
+   for (block = 0; block < blocks; block++)
+     {
+       register rtx head, jump, end;
+       register int regno;
+ 
+       fprintf (file, "\nStack block %d: first insn %d, last %d.\n",
+                block, INSN_UID (block_begin[block]),
+                INSN_UID (block_end[block]));
+ 
+       head = block_begin[block];
+ 
+       fprintf (file, "Reached from blocks: ");
+       if (GET_CODE (head) == CODE_LABEL)
+         for (jump = LABEL_REFS (head);
+              jump != head;
+              jump = LABEL_NEXTREF (jump))
+           {
+             register int from_block = BLOCK_NUM (CONTAINING_INSN (jump));
+             fprintf (file, " %d", from_block);
+           }
+       if (block_drops_in[block])
+         fprintf (file, " previous");
+ 
+       fprintf (file, "\nlive stack registers on block entry: ");
+       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+         {
+           if (TEST_HARD_REG_BIT (block_stack_in[block].reg_set, regno))
+             fprintf (file, "%d ", regno);
+         }
+ 
+       fprintf (file, "\nlive stack registers on block exit: ");
+       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+         {
+           if (TEST_HARD_REG_BIT (block_out_reg_set[block], regno))
+             fprintf (file, "%d ", regno);
+         }
+ 
+       end = block_end[block];
+ 
+       fprintf (file, "\nJumps to blocks: ");
+       if (GET_CODE (end) == JUMP_INSN)
+         print_blocks (file, end, PATTERN (end));
+ 
+       if (block + 1 < blocks && block_drops_in[block+1])
+         fprintf (file, " next");
+       else if (block + 1 == blocks
+                || (GET_CODE (end) == JUMP_INSN
+                    && GET_CODE (PATTERN (end)) == RETURN))
+         fprintf (file, " return");
+ 
+       fprintf (file, "\n");
+     }
+ }
+ 
+ /* Do alter_subreg on all the SUBREGs contained in X.  Like
+    walk_alter_subreg in final.c, but traverses an arbitrary rtx.  */
+ 
+ static rtx
+ walk_alter_subreg (x)
+      rtx x;
+ {
+   register char *fmt;
+   register int i;
+ 
+   if (GET_CODE (x) == SUBREG)
+     return alter_subreg (x);
+ 
+   fmt = GET_RTX_FORMAT (GET_CODE (x));
+   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)
+     {
+       if (fmt[i] == 'E')
+         {
+           register int j;
+ 
+           for (j = XVECLEN (x, i) - 1; j >= 0; j--)
+             XVECEXP (x, i, j) = walk_alter_subreg (XVECEXP (x, i, j));
+         }
+       else if (fmt[i] == 'e')
+         XEXP (x, i) = walk_alter_subreg (XEXP (x, i));
+     }
+ 
+   return x;
+ }
+ 
+ 
+ /* Call FUN for every reg which is a popped input for INSN.
+    The value returned by NOTE_POPPED_INPUTS is the first non-zero
+    value returned from the call to FUN, or 0 if all FUN invocations
+    returned zero. */
+ 
+ int
+ note_popped_inputs (insn, fun)
+      register rtx insn;
+      int (*fun) ();
+ {
+   int popped_inputs;
+   int i;
+   int result;
+   int n_operands;
+   char *const *constraints;
+   
+   if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')
+     return 0;
+ 
+   switch (GET_CODE (PATTERN (insn)))
+     {
+     case USE:
+     case CLOBBER:
+     case ASM_INPUT:
+     case UNSPEC:
+     case UNSPEC_VOLATILE:
+     case ADDR_VEC:
+     case ADDR_DIFF_VEC:
+       /* These won't recognize -- but they cannot pop anything anyway. */
+       return 0;
+     }
+ 
+   n_operands = asm_noperands (PATTERN (insn));
+   if (n_operands >= 0)
+     {
+       /* This insn is an `asm' with operands.  */
+ 
+       /* expand_asm_operands makes sure there aren't too many operands.  */
+       if (n_operands > MAX_RECOG_OPERANDS)
+ 	abort ();
+ 
+       constraints = (char **) alloca (n_operands * sizeof (char *));
+       decode_asm_operands (PATTERN (insn), recog_operand, recog_operand_loc,
+ 			   (char **)constraints, NULL_PTR);
+ 
+       popped_inputs = 0;
+       
+       i = n_operands;
+       while (--i >= 0)
+ 	{
+ 	  if (index (constraints[i], 'P'))
+ 	    popped_inputs |= 1<<i;
+ 	}
+       
+       if (!popped_inputs)
+ 	return 0;
+     }
+   else
+     {
+       /* Ordinary insn */
+ 
+       int insn_code = recog_memoized (insn);
+       if (insn_code < 0)
+         fatal_insn_not_found (insn);
+ 
+       popped_inputs = get_attr_popped_inputs (insn);
+ 
+ #ifdef HAVE_ATTR_popped_inputs_on_jump
+       popped_inputs |= get_attr_popped_inputs_on_jump (insn);
+ #endif
+       
+       if (!popped_inputs)
+ 	return 0;
+ 
+       insn_extract (insn);
+       n_operands = insn_n_operands [INSN_CODE (insn)];
+     }
+ 
+   i = n_operands;
+   while (--i >= 0)
+     if (popped_inputs & (1<<i))
+       {
+         rtx pat = recog_operand[i];
+ 
+         if (GET_CODE (pat) != REG && GET_CODE (pat) != SUBREG)
+           pat = stack_reg_mentioned (pat);
+ 
+         if (pat && (GET_CODE (pat) == REG || GET_CODE (pat) == SUBREG))
+           if (result = (*fun)(insn, pat))
+             return result;  /* FUN says stop scanning this insn */
+       }
+ 
+   return 0;
+ }
+ 
+ #endif /* STACK_REGS */
+ 
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/regs.h gcc-2.7.2-t800.12/regs.h
*** gcc-2.7.2/regs.h	Thu Jun 15 15:59:57 1995
--- gcc-2.7.2-t800.12/regs.h	Mon Jan 22 11:36:29 1996
***************
*** 102,105 ****
--- 102,110 ----
  extern short *reg_renumber;
  
+ /* Vector indexed by (pseudo) reg number showing whether it is popped
+    by some insn. See comment in local-alloc.c */
+ 
+ extern char *reg_popped_input;
+ 
  /* Vector indexed by hardware reg
     saying whether that reg is ever used.  */
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/reload.c gcc-2.7.2-t800.12/reload.c
*** gcc-2.7.2/reload.c	Sat Nov 11 16:23:35 1995
--- gcc-2.7.2-t800.12/reload.c	Mon Jan 22 11:36:29 1996
***************
*** 5583,5586 ****
--- 5583,5598 ----
      {
        p = PREV_INSN (p);
+ 
+ #ifdef INSN_CLOBBERS_REGNO_P
+       /* We must check WHERE also: think of the case where WHERE is a
+          `store' insn popping its stack-reg source. */
+          
+       if ((valueno >= 0 && valueno < FIRST_PSEUDO_REGISTER
+ 	  && INSN_CLOBBERS_REGNO_P (p, valueno))
+ 	  || (regno >= 0 && regno < FIRST_PSEUDO_REGISTER
+ 	  && INSN_CLOBBERS_REGNO_P (p, regno)))
+ 	return 0;
+ #endif
+ 
        if (p == where)
  	return value;
***************
*** 5602,5613 ****
        if (NON_SAVING_SETJMP && GET_CODE (p) == NOTE
  	  && NOTE_LINE_NUMBER (p) == NOTE_INSN_SETJMP)
- 	return 0;
- #endif
- 
- #ifdef INSN_CLOBBERS_REGNO_P
-       if ((valueno >= 0 && valueno < FIRST_PSEUDO_REGISTER
- 	  && INSN_CLOBBERS_REGNO_P (p, valueno))
- 	  || (regno >= 0 && regno < FIRST_PSEUDO_REGISTER
- 	  && INSN_CLOBBERS_REGNO_P (p, regno)))
  	return 0;
  #endif
--- 5614,5617 ----
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/reload1.c gcc-2.7.2-t800.12/reload1.c
*** gcc-2.7.2/reload1.c	Sun Nov  5 19:22:03 1995
--- gcc-2.7.2-t800.12/reload1.c	Sat May 11 17:47:50 1996
***************
*** 166,169 ****
--- 166,176 ----
  static HARD_REG_SET bad_spill_regs;
  
+ #ifdef SMARTER_RELOAD_PASS
+ /* This reg set indicates registers that has been chosen for reloading by
+    choose_reload_regs_from_free.  If some of these regs are then spilled,
+    we must rescan the insns.  */
+ static HARD_REG_SET used_free_regs;
+ #endif
+ 
  /* Describes order of use of registers for reloading
     of spilled pseudo-registers.  `spills' is the number of
***************
*** 342,346 ****
  static int new_spill_reg		PROTO((int, int, int *, int *, int,
  					       FILE *));
! static void delete_dead_insn		PROTO((rtx));
  static void alter_reg  			PROTO((int, int));
  static void mark_scratch_live		PROTO((rtx));
--- 349,353 ----
  static int new_spill_reg		PROTO((int, int, int *, int *, int,
  					       FILE *));
! static void delete_dead_insn		PROTO((rtx, int));
  static void alter_reg  			PROTO((int, int));
  static void mark_scratch_live		PROTO((rtx));
***************
*** 357,360 ****
--- 364,368 ----
  static void forget_old_reloads_1	PROTO((rtx, rtx));
  static int reload_reg_class_lower	PROTO((short *, short *));
+ static void init_reload_reg_in_use	PROTO(());
  static void mark_reload_reg_in_use	PROTO((int, int, enum reload_type,
  					       enum machine_mode));
***************
*** 373,376 ****
--- 381,391 ----
  static int constraint_accepts_reg_p	PROTO((char *, rtx));
  static int count_occurrences		PROTO((rtx, rtx));
+ static void get_hards_live_at_start	PROTO((int, HARD_REG_SET *));
+ static void get_hards_spilled_in_block	PROTO((int, HARD_REG_SET *));
+ static void note_reg_usage		PROTO((rtx, HARD_REG_SET *,
+ 					       HARD_REG_SET *));
+ static void mark_reg_store		PROTO((rtx, rtx));
+ static void choose_reload_regs_from_free	PROTO((rtx,rtx));
+ static int allocate_reload_reg_from_free	PROTO((int, rtx));
  
  /* Initialize the reload pass once per compilation.  */
***************
*** 774,777 ****
--- 789,804 ----
        int previous_frame_pointer_needed = frame_pointer_needed;
        static char *reg_class_names[] = REG_CLASS_NAMES;
+ #ifdef SMARTER_RELOAD_PASS
+       /* The regs that are live during the current insn  */
+       HARD_REG_SET hard_regs_live;
+ 
+       /* The regs that are spilled in this block; this is a subset of
+          FORBIDDEN_REGS  */
+       HARD_REG_SET this_block_spills;
+ 
+       /* Saveplace for the old value of FORBIDDEN_REGS while satisfying
+          needs.  */
+       HARD_REG_SET prev_forbidden_regs;
+ #endif
  
        something_changed = 0;
***************
*** 789,792 ****
--- 816,828 ----
        this_block = 0;
  
+ #ifdef SMARTER_RELOAD_PASS
+       if (global)
+         {
+           get_hards_live_at_start (this_block, &hard_regs_live);
+           get_hards_spilled_in_block (this_block, &this_block_spills);
+           CLEAR_HARD_REG_SET (used_free_regs);
+         }
+ #endif
+ 
        /* Remember whether any element of basic_block_needs
  	 changes from 0 to 1 in this pass.  */
***************
*** 903,907 ****
--- 939,950 ----
  	  if (global && this_block + 1 < n_basic_blocks
  	      && insn == basic_block_head[this_block+1])
+ #ifndef SMARTER_RELOAD_PASS
  	    ++this_block;
+ #else
+             {
+               get_hards_live_at_start (++this_block, &hard_regs_live);
+               get_hards_spilled_in_block (this_block, &this_block_spills);
+             }
+ #endif
  
  	  /* If this is a label, a JUMP_INSN, or has REG_NOTES (which
***************
*** 1023,1026 ****
--- 1066,1074 ----
  		}
  
+ #ifdef SMARTER_RELOAD_PASS
+               if (global)
+ 		note_reg_usage (insn, &hard_regs_live, &this_block_spills);
+ #endif /* SMARTER_RELOAD_PASS */
+ 
  	      /* If this insn has no reloads, we need not do anything except
  		 in the case of a CALL_INSN when we have caller-saves and
***************
*** 1032,1035 ****
--- 1080,1091 ----
  		continue;
  
+ #ifdef SMARTER_RELOAD_PASS
+               /* When did flow analisys, we are able to find which
+                  hard regs are unused at this insn, and use them for
+                  reloading so as to reduce spilling. */
+               if (global)
+                 choose_reload_regs_from_free (insn, avoid_return_reg);
+ #endif /* SMARTER_RELOAD_PASS */
+ 
  	      something_needs_reloads = 1;
  	      bzero ((char *) &insn_needs, sizeof insn_needs);
***************
*** 1568,1571 ****
--- 1624,1631 ----
  	 can be allocated into these registers, but locals cannot.  */
  
+ #ifdef SMARTER_RELOAD_PASS
+       COPY_HARD_REG_SET (prev_forbidden_regs, forbidden_regs);
+ #endif
+ 
        if (n_spills)
  	{
***************
*** 1890,1893 ****
--- 1950,1968 ----
  	    }
  	}
+ 
+ #ifdef SMARTER_RELOAD_PASS
+       /* See if some of the newly spilled registers were used for
+          reloading as free registers.  If so, we must rescan insns,
+          this time not considering these registers free.  */
+       {
+         HARD_REG_SET temp;
+         COPY_HARD_REG_SET (temp, forbidden_regs);
+         AND_COMPL_HARD_REG_SET (temp, prev_forbidden_regs);
+         AND_HARD_REG_SET (temp, used_free_regs);
+         GO_IF_HARD_REG_EQUAL (temp, reg_class_contents[NO_REGS], m1);
+         something_changed = 1;
+       m1:
+       }
+ #endif
      }
  
***************
*** 1920,1930 ****
        {
  	if (reg_set_p (regno_reg_rtx[i], PATTERN (reg_equiv_init[i])))
! 	  delete_dead_insn (reg_equiv_init[i]);
  	else
! 	  {
! 	    PUT_CODE (reg_equiv_init[i], NOTE);
! 	    NOTE_SOURCE_FILE (reg_equiv_init[i]) = 0;
! 	    NOTE_LINE_NUMBER (reg_equiv_init[i]) = NOTE_INSN_DELETED;
! 	  }
        }
  
--- 1995,2001 ----
        {
  	if (reg_set_p (regno_reg_rtx[i], PATTERN (reg_equiv_init[i])))
! 	  delete_dead_insn (reg_equiv_init[i], 0);
  	else
! 	  delete_dead_insn (reg_equiv_init[i], 1);
        }
  
***************
*** 1990,1993 ****
--- 2061,2072 ----
  	    XEXP (reg_equiv_mem[i], 0) = addr;
  	}
+       else if (reg_equiv_constant[i] && reg_renumber[i] < 0)
+ 	{
+ 	  rtx reg = regno_reg_rtx[i];
+ 	  XEXP (reg, 0) = XEXP (reg_equiv_constant[i], 0);
+ 	  REG_USERVAR_P (reg) = 0;
+ 	  MEM_IN_STRUCT_P (reg) = 0;
+ 	  PUT_CODE (reg, GET_CODE (reg_equiv_constant[i]));
+ 	}
      }
  
***************
*** 2279,2284 ****
  
  static void
! delete_dead_insn (insn)
       rtx insn;
  {
    rtx prev = prev_real_insn (insn);
--- 2358,2364 ----
  
  static void
! delete_dead_insn (insn, this_insn_only)
       rtx insn;
+      int this_insn_only;
  {
    rtx prev = prev_real_insn (insn);
***************
*** 2287,2295 ****
    /* If the previous insn sets a register that dies in our insn, delete it
       too.  */
!   if (prev && GET_CODE (PATTERN (prev)) == SET
        && (prev_dest = SET_DEST (PATTERN (prev)), GET_CODE (prev_dest) == REG)
        && reg_mentioned_p (prev_dest, PATTERN (insn))
        && find_regno_note (insn, REG_DEAD, REGNO (prev_dest)))
!     delete_dead_insn (prev);
  
    PUT_CODE (insn, NOTE);
--- 2367,2381 ----
    /* If the previous insn sets a register that dies in our insn, delete it
       too.  */
!   if (! this_insn_only && prev && GET_CODE (PATTERN (prev)) == SET
        && (prev_dest = SET_DEST (PATTERN (prev)), GET_CODE (prev_dest) == REG)
        && reg_mentioned_p (prev_dest, PATTERN (insn))
        && find_regno_note (insn, REG_DEAD, REGNO (prev_dest)))
!     delete_dead_insn (prev, this_insn_only);
! 
! #ifdef SMARTER_RELOAD_PASS
!   /* Indicate for reload_as_needed that this insn might have a valid
!      death note which needs processing by note_reg_usage */
!   PUT_MODE (insn, CCmode);
! #endif
  
    PUT_CODE (insn, NOTE);
***************
*** 3240,3244 ****
  	       process it since it won't be used unless something changes.  */
  	    if (replace)
! 	      delete_dead_insn (insn);
  	    val = 1;
  	    goto done;
--- 3326,3330 ----
  	       process it since it won't be used unless something changes.  */
  	    if (replace)
! 	      delete_dead_insn (insn, 0);
  	    val = 1;
  	    goto done;
***************
*** 3608,3612 ****
    register int i;
    register int o = 0;
!   int large = 0;
  
    struct hard_reg_n_uses hard_reg_n_uses[FIRST_PSEUDO_REGISTER];
--- 3694,3698 ----
    register int i;
    register int o = 0;
!   int large = 1;
  
    struct hard_reg_n_uses hard_reg_n_uses[FIRST_PSEUDO_REGISTER];
***************
*** 3640,3644 ****
    /* Now fixed registers (which cannot safely be used for reloading)
       get a very high use count so they will be considered least desirable.
!      Registers used explicitly in the rtl code are almost as bad.  */
  
    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
--- 3726,3734 ----
    /* Now fixed registers (which cannot safely be used for reloading)
       get a very high use count so they will be considered least desirable.
!      Registers used explicitly in the rtl code are almost as bad.
!   
!      Registers that can carry function return value, receive an
!      additional penalty to reduce the probability of running out of
!      spills owing to avoid_return_reg. */
  
    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
***************
*** 3646,3655 ****
        if (fixed_regs[i])
  	{
! 	  hard_reg_n_uses[i].uses += 2 * large + 2;
  	  SET_HARD_REG_BIT (bad_spill_regs, i);
  	}
        else if (regs_explicitly_used[i])
  	{
! 	  hard_reg_n_uses[i].uses += large + 1;
  #ifndef SMALL_REGISTER_CLASSES
  	  /* ??? We are doing this here because of the potential that
--- 3736,3745 ----
        if (fixed_regs[i])
  	{
! 	  hard_reg_n_uses[i].uses += 4 * large;
  	  SET_HARD_REG_BIT (bad_spill_regs, i);
  	}
        else if (regs_explicitly_used[i])
  	{
! 	  hard_reg_n_uses[i].uses += large;
  #ifndef SMALL_REGISTER_CLASSES
  	  /* ??? We are doing this here because of the potential that
***************
*** 3661,3666 ****
  #endif
  	}
      }
!   hard_reg_n_uses[HARD_FRAME_POINTER_REGNUM].uses += 2 * large + 2;
    SET_HARD_REG_BIT (bad_spill_regs, HARD_FRAME_POINTER_REGNUM);
  
--- 3751,3764 ----
  #endif
  	}
+       if (FUNCTION_VALUE_REGNO_P (i))
+ 	{
+ 	  hard_reg_n_uses[i].uses += 2 * large;
+ 	  if (i+1 < FIRST_PSEUDO_REGISTER) /* ??? bad on machines not
+ 					      actually using two regs for
+ 					      return value */
+ 	    hard_reg_n_uses[i+1].uses += large;
+ 	}
      }
!   hard_reg_n_uses[HARD_FRAME_POINTER_REGNUM].uses += 4 * large;
    SET_HARD_REG_BIT (bad_spill_regs, HARD_FRAME_POINTER_REGNUM);
  
***************
*** 3670,3674 ****
    for (i = 0; i < NUM_ELIMINABLE_REGS; i++)
      {
!       hard_reg_n_uses[reg_eliminate[i].from].uses += 2 * large + 2;
        SET_HARD_REG_BIT (bad_spill_regs, reg_eliminate[i].from);
      }
--- 3768,3772 ----
    for (i = 0; i < NUM_ELIMINABLE_REGS; i++)
      {
!       hard_reg_n_uses[reg_eliminate[i].from].uses += 4 * large;
        SET_HARD_REG_BIT (bad_spill_regs, reg_eliminate[i].from);
      }
***************
*** 3740,3743 ****
--- 3838,3845 ----
    rtx x;
    rtx after_call = 0;
+ #ifdef SMARTER_RELOAD_PASS
+   HARD_REG_SET hard_regs_live;
+   HARD_REG_SET this_block_spills;
+ #endif
  
    bzero ((char *) spill_reg_rtx, sizeof spill_reg_rtx);
***************
*** 3752,3755 ****
--- 3854,3865 ----
      }
  
+ #ifdef SMARTER_RELOAD_PASS
+   if (live_known)
+     {
+       get_hards_live_at_start (this_block, &hard_regs_live);
+       get_hards_spilled_in_block (this_block, &this_block_spills);
+     }
+ #endif
+ 
    /* Reset all offsets on eliminable registers to their initial values.  */
  #ifdef ELIMINABLE_REGS
***************
*** 3785,3789 ****
--- 3895,3906 ----
        if (live_known && this_block + 1 < n_basic_blocks
  	  && insn == basic_block_head[this_block+1])
+ #ifndef SMARTER_RELOAD_PASS
  	++this_block;
+ #else
+         {
+           get_hards_live_at_start (++this_block, &hard_regs_live);
+           get_hards_spilled_in_block (this_block, &this_block_spills);
+         }
+ #endif
  
        /* If we pass a label, copy the offsets from the label information
***************
*** 3803,3806 ****
--- 3920,3933 ----
  	}
  
+ #ifdef SMARTER_RELOAD_PASS
+       /* If this insn was deleted after we counted it with note_reg_usage
+ 	 in reload(), we should process any death notes it might have anyway */
+       if (live_known && GET_CODE (insn) == NOTE
+           && NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED
+ 	  && GET_MODE (insn) == CCmode)
+         note_reg_usage (insn, &hard_regs_live, &this_block_spills);
+ #endif /* SMARTER_RELOAD_PASS */
+ 
+ 
        else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')
  	{
***************
*** 3868,3871 ****
--- 3995,4010 ----
  	    }
  
+ #ifdef SMARTER_RELOAD_PASS
+           if (live_known)
+             {
+               /* In case we omitted find_reloads note_reg_usage will
+                  use an old value of reload_n_operands.  But this is
+                  OK, since it is guaranteed to be within bounds, and
+                  the results of its use will not matter as this insn
+                  does not need reloads.  */
+               note_reg_usage (insn, &hard_regs_live, &this_block_spills);
+             }
+ #endif /* SMARTER_RELOAD_PASS */
+ 
  	  if (n_reloads > 0)
  	    {
***************
*** 3874,3877 ****
--- 4013,4022 ----
  	      int class;
  
+ #ifdef SMARTER_RELOAD_PASS
+               if (live_known)
+                 choose_reload_regs_from_free (insn, avoid_return_reg);
+ #endif /* SMARTER_RELOAD_PASS */
+ 
+ 
  	      /* If this block has not had spilling done for a
  		 particular clas and we have any non-optionals that need a
***************
*** 3981,3994 ****
  	    }
  
-       /* In case registers overlap, allow certain insns to invalidate
- 	 particular hard registers.  */
- 
  #ifdef INSN_CLOBBERS_REGNO_P
!       for (i = 0 ; i < n_spills ; i++)
! 	if (INSN_CLOBBERS_REGNO_P (insn, spill_regs[i]))
! 	  {
! 	    reg_reloaded_contents[i] = -1;
! 	    reg_reloaded_insn[i] = 0;
! 	  }
  #endif
  
--- 4126,4144 ----
  	    }
  
  #ifdef INSN_CLOBBERS_REGNO_P
!       /* In case registers overlap, allow certain insns to invalidate
! 	 particular hard registers.
!          Check just emitted output reload insns also, to cope with the
!          case where output reload insn clobbers the reload reg. */
!       {
!         rtx p;
!         for (p = insn; p != next; p = NEXT_INSN (p))
!           for (i = 0 ; i < n_spills ; i++)
!             if (INSN_CLOBBERS_REGNO_P (p, spill_regs[i]))
!               {
!                 reg_reloaded_contents[i] = -1;
!                 reg_reloaded_insn[i] = 0;
!               }
!       }
  #endif
  
***************
*** 4132,4135 ****
--- 4282,4309 ----
  static HARD_REG_SET reload_reg_used_for_inherit;
  
+ 
+ #ifdef SMARTER_RELOAD_PASS
+ static void
+ init_reload_reg_in_use ()
+ {
+   int i;
+ 
+   CLEAR_HARD_REG_SET (reload_reg_used);
+   CLEAR_HARD_REG_SET (reload_reg_used_at_all);
+   CLEAR_HARD_REG_SET (reload_reg_used_in_op_addr);
+   CLEAR_HARD_REG_SET (reload_reg_used_in_op_addr_reload);
+   CLEAR_HARD_REG_SET (reload_reg_used_in_insn);
+   CLEAR_HARD_REG_SET (reload_reg_used_in_other_addr);
+ 
+   for (i = 0; i < reload_n_operands; i++)
+     {
+       CLEAR_HARD_REG_SET (reload_reg_used_in_output[i]);
+       CLEAR_HARD_REG_SET (reload_reg_used_in_input[i]);
+       CLEAR_HARD_REG_SET (reload_reg_used_in_input_addr[i]);
+       CLEAR_HARD_REG_SET (reload_reg_used_in_output_addr[i]);
+     }
+ }
+ #endif SMARTER_RELOAD_PASS
+ 
  /* Mark reg REGNO as in use for a reload of the sort spec'd by OPNUM and
     TYPE. MODE is used to indicate how many consecutive regs are
***************
*** 7175,7176 ****
--- 7349,7694 ----
    return count;
  }
+ 
+ #ifdef SMARTER_RELOAD_PASS
+ 
+ /* Static argument for MARK_REG_STORE */
+ static HARD_REG_SET *mark_hard_regs_live;
+ 
+ 
+ /* Record in HARD_REGS_LIVE the hard registers live at the start of basic
+    block B. (Mimic code from global.c) */
+    
+ static void
+ get_hards_live_at_start (b, hard_regs_live)
+     int b;
+     HARD_REG_SET *hard_regs_live;
+ {
+   register int offset, i;
+   REGSET_ELT_TYPE bit;
+   register regset old = basic_block_live_at_start[b];
+ 
+ #ifdef HARD_REG_SET
+   *hard_regs_live = old[0];
+ #else
+   COPY_HARD_REG_SET (*hard_regs_live, old);
+ #endif
+   for (offset = 0, i = 0; offset < regset_size; offset++)
+     if (old[offset] == 0)
+       i += REGSET_ELT_BITS;
+     else
+       for (bit = 1; bit; bit <<= 1, i++)
+ 	{
+ 	  if (i >= max_regno)
+ 	    break;
+ 	  if (old[offset] & bit)
+ 	    {
+ 	      register int regno = reg_renumber[i];
+ 	      if (regno >= 0)
+ 		{
+                   register int last =
+                       regno + HARD_REGNO_NREGS (regno, PSEUDO_REGNO_MODE (i));
+                   while (regno < last)
+                     {
+                       SET_HARD_REG_BIT (*hard_regs_live, regno);
+                       regno++;
+                     }
+ 		}
+ 	    }
+ 	}
+ }
+ 
+ /* Record in SPILLS the hard registers spilled in BLOCK. SPILLS will
+    always be a subset of FORBIDDEN_REGS, but might be narrower than
+    that if SPILL_HARD_REG has chosen not to spill certain regs for
+    this block. */
+ 
+ static void
+ get_hards_spilled_in_block (block, spills)
+     int block;
+     HARD_REG_SET *spills;
+ {
+   int i;
+ 
+   COPY_HARD_REG_SET (*spills, forbidden_regs);
+ 
+   /* If we have the basic block needs computed, see if some forbidden
+      regs are not really spilled for this particular BLOCK  */
+   if (basic_block_needs[0])
+     for (i=0; i < n_spills; i++)
+       {
+         int r = spill_regs[i];
+         enum reg_class class = REGNO_REG_CLASS (r);
+ 
+         if (basic_block_needs[(int) class][block] == 0)
+           {
+             enum reg_class *p;
+ 
+             for (p = reg_class_superclasses[(int) class];
+   	        *p != LIM_REG_CLASSES; p++)
+               if (basic_block_needs[(int) *p][block] > 0)
+   	          break;
+ 
+             if (*p == LIM_REG_CLASSES)
+               CLEAR_HARD_REG_BIT (*spills, r);
+           }
+       }
+ }
+ 
+ 
+ /* Note which pseudos and hard regs are born or die in the INSN; reflect
+    this in HARD_REGS_LIVE.  Collect information as to what regs are free
+    and in which insn parts; record it in reload_reg_used*  */
+ 
+ static void
+ note_reg_usage (insn, phard_regs_live, hard_regs_spilled)
+     rtx insn;
+     HARD_REG_SET *phard_regs_live;
+     HARD_REG_SET *hard_regs_spilled;
+ {
+     register rtx link;
+ 
+     /* We might be called on a NOTE_INSN_DELETED which carries an
+        essential death note.  We do nothing except note processing in
+        this case, as this insn requires not reloads.  */
+ 
+     if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')
+       {
+ 	init_reload_reg_in_use ();
+ 
+ 	/* All regs live before the insn cannot be used for input reloads. */
+ 	IOR_HARD_REG_SET (reload_reg_used_in_input[0], *phard_regs_live);
+ 	IOR_HARD_REG_SET (reload_reg_used_in_input_addr[0], *phard_regs_live);
+ 	IOR_HARD_REG_SET (reload_reg_used_in_other_addr, *phard_regs_live);
+ 	IOR_HARD_REG_SET (reload_reg_used_at_all, *phard_regs_live);
+ 
+ 	/* Spilled regs cannot be used here at all -- they are not free.  */
+ 	IOR_HARD_REG_SET (reload_reg_used, *hard_regs_spilled);
+ 	IOR_HARD_REG_SET (reload_reg_used_in_other_addr, *hard_regs_spilled);
+ 	IOR_HARD_REG_SET (reload_reg_used_at_all, *hard_regs_spilled);
+       }
+ 
+     for (link = REG_NOTES (insn); link; link = XEXP (link, 1))
+       if (REG_NOTE_KIND (link) == REG_DEAD)
+         {
+           unsigned regno = true_regnum (XEXP (link, 0));
+ 
+           /* This check rejects -1 too, as regno is unsigned */
+           if (regno < FIRST_PSEUDO_REGISTER)
+             {
+               int nr = HARD_REGNO_NREGS (regno, GET_MODE (XEXP (link, 0)));
+               while (nr--)
+                 CLEAR_HARD_REG_BIT (*phard_regs_live, regno + nr);
+             }
+         }
+ 
+     if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')
+       return;
+ 
+     mark_hard_regs_live = phard_regs_live;
+     note_stores (PATTERN (insn), mark_reg_store);
+ 
+     /* Any regs live after the insn cannot be used for output reloads.  */
+     IOR_HARD_REG_SET (reload_reg_used_in_output[reload_n_operands - 1],
+                      *phard_regs_live);
+     IOR_HARD_REG_SET (reload_reg_used_at_all, *phard_regs_live);
+ 
+     for (link = REG_NOTES (insn); link; link = XEXP (link, 1))
+       if (REG_NOTE_KIND (link) == REG_UNUSED)
+         {
+           unsigned regno = true_regnum (XEXP (link, 0));
+ 
+           if (regno < FIRST_PSEUDO_REGISTER)
+             {
+               int nr = HARD_REGNO_NREGS (regno, GET_MODE (XEXP (link, 0)));
+               while (nr--)
+                 CLEAR_HARD_REG_BIT (*phard_regs_live, regno + nr);
+             }
+         }
+ }
+ 
+ 
+ /* Called by NOTE_STORES called from NOTE_REG_USAGE. */
+ 
+ static void
+ mark_reg_store (reg, expr)
+     rtx reg, expr;
+ {
+   unsigned regno = true_regnum (reg);
+   int mode = GET_MODE (reg);
+   int nr = HARD_REGNO_NREGS (regno, mode);
+ 
+   if (regno < FIRST_PSEUDO_REGISTER)
+     switch (GET_CODE (expr))
+       {
+       case SET:
+         while (nr--)
+           SET_HARD_REG_BIT (*mark_hard_regs_live, regno + nr);
+         /* Need not to call mark_hard_regs_live here, as NOTE_REG_USAGE
+            will do this while processing the regs live after insn */
+         break;
+       case CLOBBER:
+         mark_reload_reg_in_use (regno, 0, RELOAD_FOR_INSN, mode);
+         break;
+       default:
+         abort ();
+       }
+ }
+ 
+ 
+ /* Try to assign hard reg targets for the pseudo-registers we must reload
+    into hard regs for this insn, choosing from the regs that are free
+    during this insn. The regs chosen are recorded in reload_reg_rtx.
+ 
+    Unlike choose_reload_regs, this routine is allowed to be sloppy, 
+    since its job is a sort of optimization.  */
+ 
+ static void
+ choose_reload_regs_from_free (insn, avoid_return_reg)
+      rtx insn;
+      rtx avoid_return_reg;
+ {
+   register int i, j, r;
+ 
+ #ifdef SMALL_REGISTER_CLASSES
+   /* Don't bother with avoiding the return reg
+      if we have no mandatory reload that could use it.  */
+   if (avoid_return_reg)
+     {
+       int do_avoid = 0;
+       int regno = REGNO (avoid_return_reg);
+       int nregs	= HARD_REGNO_NREGS (regno, GET_MODE (avoid_return_reg));
+       int r;
+ 
+       for (r = regno; r < regno + nregs; r++)
+         if (reload_reg_free_p (r, 0, RELOAD_FOR_INPUT_ADDRESS))
+ 	  for (j = 0; j < n_reloads; j++)
+ 	    if (!reload_optional[j] && reload_reg_rtx[j] == 0
+ 		&& (reload_in[j] != 0 || reload_out[j] != 0
+ 		    || reload_secondary_p[j])
+ 		&&
+ 		TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[j]], r))
+ 	      do_avoid = 1;
+       if (!do_avoid)
+ 	avoid_return_reg = 0;
+     }
+ #endif /* SMALL_REGISTER_CLASSES */
+ 
+ #ifdef SMALL_REGISTER_CLASSES
+   /* Don't use the subroutine call return reg for a reload
+      if we are supposed to avoid it.  */
+   if (avoid_return_reg)
+     {
+       int regno = REGNO (avoid_return_reg);
+       int nregs	= HARD_REGNO_NREGS (regno, GET_MODE (avoid_return_reg));
+       int r;
+ 
+       for (r = regno; r < regno + nregs; r++)
+         {
+           mark_reload_reg_in_use (r, 0, RELOAD_FOR_INPUT, QImode);
+           mark_reload_reg_in_use (r, 0, RELOAD_FOR_INPUT_ADDRESS, QImode);
+         }
+     }
+ #endif /* SMALL_REGISTER_CLASSES */
+ 
+   /* For the first time, do not bother sorting reloads */
+ 
+   for (j = 0; j < n_reloads; j++)
+     {
+       reload_mode[j]
+ 	= (reload_inmode[j] == VOIDmode
+ 	   || (GET_MODE_SIZE (reload_outmode[j])
+ 	       > GET_MODE_SIZE (reload_inmode[j])))
+ 	  ? reload_outmode[j] : reload_inmode[j];
+ 
+       reload_nregs[j] = CLASS_MAX_NREGS (reload_reg_class[j], reload_mode[j]);
+ 
+       /* If we have already decided to use a certain register,
+ 	 don't use it in another way.  */
+       if (reload_reg_rtx[j])
+ 	mark_reload_reg_in_use (REGNO (reload_reg_rtx[j]), reload_opnum[j],
+ 				reload_when_needed[j], reload_mode[j]);
+     }
+ 
+   for (r = 0; r < n_reloads; r++)
+     {
+       /* Ignore reloads that got marked inoperative.  */
+       if (reload_out[r] == 0 && reload_in[r] == 0 && ! reload_secondary_p[r])
+         continue;
+ 
+       /* Skip reloads that already have a register allocated or are
+          optional. */
+       if (reload_reg_rtx[r] != 0 || reload_optional[r])
+         continue;
+ 
+       /* Try allocating for every reload in a dumb fashion, for it's
+          not easy to determine that no chance left */
+       allocate_reload_reg_from_free (r, insn);
+     }
+ }
+ 
+ 
+ /* Find a free register to use as a reload register for reload R.
+    Set reload_reg_rtx[R] to the register allocated.
+ 
+    Although it is not currently used, we return 1 if successful,
+    or 0 if we couldn't find a spill reg and we didn't change anything.  */
+ 
+ static int
+ allocate_reload_reg_from_free (r, insn)
+      int r;
+      rtx insn;
+ {
+   int regno;
+   int class = (int) reload_reg_class[r];
+ 
+   /* Since we do not use round-robin register selection here, I think
+      the two-pass scheme wouldn't yield a considerable benefit in
+      register reuse. */
+   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+     if (reload_reg_free_p (regno, reload_opnum[r], reload_when_needed[r])
+         && TEST_HARD_REG_BIT (reg_class_contents[class], regno)
+         && HARD_REGNO_MODE_OK (regno, reload_mode[r]))
+       {
+         int nr = HARD_REGNO_NREGS (regno, reload_mode[r]);
+ 
+         /* Check that as many consecutive regs as we need
+            are available here. */
+         while (nr > 1)
+           {
+             int i = regno + nr - 1;
+             if (!(TEST_HARD_REG_BIT (reg_class_contents[class], i)
+         	  && reload_reg_free_p (i, reload_opnum[r],
+         				reload_when_needed[r])))
+               break;
+             nr--;
+           }
+ 
+         if (nr == 1)
+           {
+ 	    /* Detect when the reload reg can't hold the reload mode. */
+ 	    enum machine_mode test_mode = VOIDmode;
+ 	    if (reload_in[r])
+ 	      test_mode = GET_MODE (reload_in[r]);
+ 	    if (! (reload_in[r] != 0 && test_mode != VOIDmode
+ 		   && ! HARD_REGNO_MODE_OK (regno, test_mode)))
+ 	      if (! (reload_out[r] != 0
+ 		     && ! HARD_REGNO_MODE_OK (regno, GET_MODE (reload_out[r]))))
+ 		{
+ 		  /* The reg is OK.  */
+ 		  mark_reload_reg_in_use (regno, reload_opnum[r],
+ 					  reload_when_needed[r], reload_mode[r]);
+ 	
+                   nr = HARD_REGNO_NREGS (regno, reload_mode[r]);
+                   while (--nr >= 0)
+                     SET_HARD_REG_BIT (used_free_regs, regno + nr);
+                        
+ 		  reload_reg_rtx[r] = gen_rtx (REG, reload_mode[r], regno);
+ 		  return 1;
+ 		}
+ 	  }
+       }
+     
+   return 0;
+ }
+ #endif /* SMARTER_RELOAD_PASS */
+ 
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/rtl.h gcc-2.7.2-t800.12/rtl.h
*** gcc-2.7.2/rtl.h	Thu Jun 15 16:02:57 1995
--- gcc-2.7.2-t800.12/rtl.h	Fri Feb 16 19:34:40 1996
***************
*** 857,860 ****
--- 857,861 ----
     go through these unique rtx objects.  */
  extern rtx stack_pointer_rtx;
+ extern rtx hard_stack_pointer_rtx;
  extern rtx frame_pointer_rtx;
  extern rtx hard_frame_pointer_rtx;
***************
*** 967,968 ****
--- 968,974 ----
  
  extern int rtx_to_tree_code	PROTO((enum rtx_code));
+ 
+ /* Nonzero after end of exotic pass.
+    Set to 1 or 0 by toplev.c.  */
+ 
+ extern int exotic_completed;
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/stmt.c gcc-2.7.2-t800.12/stmt.c
*** gcc-2.7.2/stmt.c	Wed Sep 13 03:01:35 1995
--- gcc-2.7.2-t800.12/stmt.c	Thu Nov 21 10:47:55 1996
***************
*** 1473,1476 ****
--- 1473,1485 ----
        else
  	{
+ 	  output_rtx[i] = NULL_RTX;
+ 	}
+ 
+       if (allows_reg && (output_rtx[i] == NULL_RTX
+ #ifdef ASM_OPERAND_PREDICATE
+ 			 || ! ASM_OPERAND_PREDICATE (output_rtx[i], VOIDmode)
+ #endif
+ 			 ))
+ 	{
  	  if (TYPE_MODE (type) == BLKmode)
  	    {
***************
*** 1556,1559 ****
--- 1565,1578 ----
        XVECEXP (body, 3, i)      /* argvec */
  	= expand_expr (TREE_VALUE (tail), NULL_RTX, VOIDmode, 0);
+ 
+ #ifdef ASM_OPERAND_PREDICATE
+       if (! ASM_OPERAND_PREDICATE (XVECEXP (body, 3, i),
+ 				   TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))))
+ 	  && allows_reg)
+ 	XVECEXP (body, 3, i)
+ 	      = force_reg (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))),
+ 			   XVECEXP (body, 3, i));
+ #endif
+ 
        if (CONSTANT_P (XVECEXP (body, 3, i))
  	  && ! general_operand (XVECEXP (body, 3, i),
***************
*** 1663,1666 ****
--- 1682,1691 ----
  		}
  
+ #ifdef ASM_SPECIAL_CLOBBER
+ 	      /* Handle machine-specific negative values that might
+ 		 result from ADDITIONAL_REGISTER_NAMES  */
+ 	      ASM_SPECIAL_CLOBBER(j);
+ #endif
+ 
  	      /* Ignore unknown register, error already signalled.  */
  	      continue;
***************
*** 2707,2711 ****
        return;
      }
! #ifdef HAVE_return
    /* This optimization is safe if there are local cleanups
       because expand_null_return takes care of them.
--- 2732,2736 ----
        return;
      }
! #if defined(HAVE_return) && BRANCH_COST < 2
    /* This optimization is safe if there are local cleanups
       because expand_null_return takes care of them.
***************
*** 2744,2748 ****
  	  }
      }
! #endif /* HAVE_return */
  
    /* If the result is an aggregate that is being returned in one (or more)
--- 2769,2773 ----
  	  }
      }
! #endif /* defined(HAVE_return) && BRANCH_COST < 2 */
  
    /* If the result is an aggregate that is being returned in one (or more)
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/stupid.c gcc-2.7.2-t800.12/stupid.c
*** gcc-2.7.2/stupid.c	Sun Oct 29 15:45:03 1995
--- gcc-2.7.2-t800.12/stupid.c	Mon Jan 22 11:36:33 1996
***************
*** 46,49 ****
--- 46,50 ----
  #include "config.h"
  #include "rtl.h"
+ #include "insn-attr.h"
  #include "hard-reg-set.h"
  #include "regs.h"
***************
*** 66,69 ****
--- 67,80 ----
  static int last_call_suid;
  
+ /* Record the suid of the last JUMP_INSN
+    so we can tell whether a pseudo reg crosses any jumps.  */
+ 
+ static int last_jump_suid;
+ 
+ /* Record the suid of the last CODE_LABEL
+    so we can tell whether a pseudo reg crosses any labels.  */
+ 
+ static int last_label_suid;
+ 
  /* Element N is suid of insn where life span of pseudo reg N ends.
     Element is  0 if register N has not been seen yet on backward scan.  */
***************
*** 89,92 ****
--- 100,111 ----
  static char *regs_change_size;
  
+ /* Indexed by reg number, non-zero if reg lives across labels or jumps */
+ 
+ static char *reg_crosses_blocks;
+ 
+ /* Values for reg_crosses_blocks */
+ 
+ enum { CROSSES_LABELS = 1, CROSSES_JUMPS = 2 };
+ 
  /* Indexed by insn's suid, the set of hard regs live after that insn.  */
  
***************
*** 100,105 ****
  static int stupid_reg_compare	PROTO((int *, int *));
  static int stupid_find_reg	PROTO((int, enum reg_class, enum machine_mode,
! 				       int, int, int));
  static void stupid_mark_refs	PROTO((rtx, rtx));
  
  /* Stupid life analysis is for the case where only variables declared
--- 119,125 ----
  static int stupid_reg_compare	PROTO((int *, int *));
  static int stupid_find_reg	PROTO((int, enum reg_class, enum machine_mode,
! 				       int, int, int, int));
  static void stupid_mark_refs	PROTO((rtx, rtx));
+ static int mark_popped_reg	PROTO((rtx, rtx));
  
  /* Stupid life analysis is for the case where only variables declared
***************
*** 161,164 ****
--- 181,189 ----
    bzero ((char *) reg_where_born, nregs * sizeof (int));
  
+ #ifdef HAVE_ATTR_popped_inputs
+   reg_popped_input = (char *) alloca (nregs);
+   bzero (reg_popped_input, nregs);
+ #endif
+ 
    reg_order = (int *) alloca (nregs * sizeof (int));
    bzero ((char *) reg_order, nregs * sizeof (int));
***************
*** 167,170 ****
--- 192,198 ----
    bzero ((char *) regs_change_size, nregs * sizeof (char));
  
+   reg_crosses_blocks = (char *) alloca (nregs * sizeof (char));
+   bzero ((char *) reg_crosses_blocks, nregs * sizeof (char));
+ 
    reg_renumber = (short *) oballoc (nregs * sizeof (short));
    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
***************
*** 214,218 ****
--- 242,253 ----
  
        if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')
+ #ifndef HAVE_ATTR_popped_inputs
  	stupid_mark_refs (PATTERN (insn), insn);
+ #else
+         {
+ 	  stupid_mark_refs (PATTERN (insn), insn);
+ 	  note_popped_inputs (insn, mark_popped_reg);
+         }
+ #endif
  
        /* Mark all call-clobbered regs as live after each call insn
***************
*** 258,261 ****
--- 293,313 ----
  	continue;
  
+ #ifdef HAVE_ATTR_popped_inputs
+ 
+       /* Do not alloc for pseudo which is a popped input and either
+          not dead in the popping insn (ie reused later) or spans
+          across a label (because the label may also imply reuse, as in
+          the following picture):
+ 
+ 	 ----Born======Label=====Dead----Jump.back.to.label-----  */
+ 
+       if (reg_popped_input[r] == 3
+           || reg_popped_input[r] && reg_crosses_blocks[r] & CROSSES_LABELS)
+         {
+ 	  reg_renumber[r] = -1;
+           continue;
+         }
+ #endif
+ 
        /* Now find the best hard-register class for this pseudo register */
        if (N_REG_CLASSES > 1)
***************
*** 265,269 ****
  					   reg_where_born[r],
  					   reg_where_dead[r],
! 					   regs_change_size[r]);
  
        /* If no reg available in that class, try alternate class.  */
--- 317,322 ----
  					   reg_where_born[r],
  					   reg_where_dead[r],
! 					   regs_change_size[r],
! 					   reg_crosses_blocks[r]);
  
        /* If no reg available in that class, try alternate class.  */
***************
*** 274,278 ****
  					   reg_where_born[r],
  					   reg_where_dead[r],
! 					   regs_change_size[r]);
      }
  
--- 327,332 ----
  					   reg_where_born[r],
  					   reg_where_dead[r],
! 					   regs_change_size[r],
! 					   reg_crosses_blocks[r]);
      }
  
***************
*** 322,326 ****
  static int
  stupid_find_reg (call_preserved, class, mode,
! 		 born_insn, dead_insn, changes_size)
       int call_preserved;
       enum reg_class class;
--- 376,380 ----
  static int
  stupid_find_reg (call_preserved, class, mode,
! 		 born_insn, dead_insn, changes_size, crosses_blocks)
       int call_preserved;
       enum reg_class class;
***************
*** 328,331 ****
--- 382,386 ----
       int born_insn, dead_insn;
       int changes_size;
+      int crosses_blocks;
  {
    register int i, ins;
***************
*** 477,480 ****
--- 532,536 ----
  		 insn so that it will conflict with any other outputs of
  		 this insn.  */
+ #if 0
  	      if (reg_where_dead[regno] < where_born + 2)
  		{
***************
*** 482,485 ****
--- 538,564 ----
  		  regs_live[regno] = 1;
  		}
+ #else
+ 	      /* The above code extends register life one insn longer
+ 		 than necessary.  This is not a big problem most of
+ 		 the time, but when where_born+2 is a CALL_INSN which
+ 		 clobbers many regs, it prevents regno from being
+ 		 allocated.  Note that insns before a call insn are
+ 		 probably loading register arguments, so it won't be
+ 		 easy for reload to cope with this (actually, it does
+ 		 the job, but using one of the previously loaded
+ 		 argument registers, yuck -- and I'm not sure it's
+ 		 easy to fix.)
+ 
+ 		 I once submitted this patch to gcc-bug and RMS said
+ 		 it's nearly correct, but it didn't made it to official
+ 		 release.  So here it is again, with RMS's change.
+ 		   --sizif  */
+ 
+ 	      if (reg_where_dead[regno] < INSN_SUID (insn) + 1)
+ 		{
+ 		  reg_where_dead[regno] = INSN_SUID (insn) + 1;
+ 		  regs_live[regno] = 1;
+ 		}
+ #endif
  
  	      /* Count the refs of this reg.  */
***************
*** 488,491 ****
--- 567,574 ----
  	      if (last_call_suid < reg_where_dead[regno])
  		reg_n_calls_crossed[regno] += 1;
+ 	      if (last_jump_suid < reg_where_dead[regno])
+ 		reg_crosses_blocks[regno] |= CROSSES_JUMPS;
+ 	      if (last_label_suid < reg_where_dead[regno])
+ 		reg_crosses_blocks[regno] |= CROSSES_LABELS;
  	    }
  	}
***************
*** 539,542 ****
--- 622,626 ----
  	    }
  	}
+       
        return;
      }
***************
*** 557,558 ****
--- 641,668 ----
      }
  }
+ 
+ 
+ #ifdef HAVE_ATTR_popped_inputs
+ 
+ /* Called from NOTE_POPPED_INPUTS to record the regs popped by INSN. */
+ 
+ static int
+ mark_popped_reg (insn, popped_reg)
+   rtx insn, popped_reg;
+ {
+   register regno;
+ 
+   if (GET_CODE (popped_reg) == SUBREG)
+     regno = REGNO (SUBREG_REG (popped_reg));
+   else
+     regno = REGNO (popped_reg);
+ 
+   if (regno >= FIRST_PSEUDO_REGISTER)
+     {
+       reg_popped_input[regno] |= 1;
+       if (INSN_SUID (insn) != reg_where_dead[regno])
+         reg_popped_input[regno] |= 3;
+     }
+   return 0;
+ }
+ #endif /* HAVE_ATTR_popped_inputs */
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/tm-template.sh gcc-2.7.2-t800.12/tm-template.sh
*** gcc-2.7.2/tm-template.sh	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/tm-template.sh	Mon Jan 22 11:36:33 1996
***************
*** 0 ****
--- 1,27 ----
+ #!/bin/sh 
+ 
+ # Make a template for tm.h file from tm.texi.  This script is simple
+ # and does a sloppy job, but you may find it useful.
+ #
+ # <sizif@botik.ru>
+ 
+ awk '
+ BEGIN { 
+         bar = "*************************************************************"; }
+ /^@section/ { 
+         printf("\n\n/%s\n %s\n%s/\n\n", bar, substr($0,index($0," ")+1), bar);
+         continue; }
+ /^@subsection/ { 
+         name = substr($0,index($0," ")+1);
+         printf("\n/*** %s ", name, 53-length(name), bar);
+         for(i=53-length(name); i>0; i--)
+             printf("*");
+         printf("*/\n\n");
+         continue; }
+ /^@item[a-z]* [A-Z]/ {
+         printf("/* #define %s */\n", substr($0,index($0," ")+1));
+         continue; }
+ /^@item[a-z]*/ && length($2) != 0 {
+         printf("/* %s */\n", substr($0,index($0," ")+1)); }
+ 
+ ' | sed -e 's,@var{\([^}]*\)},\1,g' -e 's, (,(,g'
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/toplev.c gcc-2.7.2-t800.12/toplev.c
*** gcc-2.7.2/toplev.c	Sat Oct 21 00:56:16 1995
--- gcc-2.7.2-t800.12/toplev.c	Fri Feb 16 19:05:27 1996
***************
*** 202,205 ****
--- 202,206 ----
  int loop_dump = 0;
  int cse2_dump = 0;
+ int exotic_dump = 0;
  int flow_dump = 0;
  int combine_dump = 0;
***************
*** 752,755 ****
--- 753,757 ----
  FILE *loop_dump_file;
  FILE *cse2_dump_file;
+ FILE *exotic_dump_file;
  FILE *flow_dump_file;
  FILE *combine_dump_file;
***************
*** 771,774 ****
--- 773,777 ----
  int loop_time;
  int cse2_time;
+ int exotic_time;
  int flow_time;
  int combine_time;
***************
*** 917,920 ****
--- 920,925 ----
    if (cse2_dump_file)
      fflush (cse2_dump_file);
+   if (exotic_dump_file)
+     fflush (exotic_dump_file);
    if (flow_dump_file)
      fflush (flow_dump_file);
***************
*** 1980,1983 ****
--- 1985,1989 ----
    loop_time = 0;
    cse2_time = 0;
+   exotic_time = 0;
    flow_time = 0;
    combine_time = 0;
***************
*** 2061,2064 ****
--- 2067,2074 ----
      cse2_dump_file = open_dump_file (dump_base_name, ".cse2");
  
+   /* If exotic dump desired, open the output file.  */
+   if (exotic_dump)
+     exotic_dump_file = open_dump_file (dump_base_name, ".exotic");
+ 
    /* If flow dump desired, open the output file.  */
    if (flow_dump)
***************
*** 2475,2478 ****
--- 2485,2491 ----
      fclose (cse2_dump_file);
  
+   if (exotic_dump)
+     fclose (exotic_dump_file);
+ 
    if (flow_dump)
      fclose (flow_dump_file);
***************
*** 2529,2532 ****
--- 2542,2546 ----
  	  print_time ("loop", loop_time);
  	  print_time ("cse2", cse2_time);
+ 	  print_time ("exotic", exotic_time);
  	  print_time ("flow", flow_time);
  	  print_time ("combine", combine_time);
***************
*** 2801,2804 ****
--- 2815,2846 ----
  #endif
  
+ #ifdef PSEUDO_STACK_POINTER
+   /* Beleive it or not, there are machines where there is only one
+      register to address stack frame.  We can live with it until it
+      comes to dynamic stack space allocation, where one really needs a
+      separate stack pointer to address outgoing args.  If this is the
+      case, we should allocate a pseudo to act as a stack pointer,
+      substitute it in place of (REG:SI STACK_POINTER_REGNUM) in
+      stack_pointer_rtx (doing so instantly changes all generated insns
+      which refer to stack_pointer_rtx), and pray virtual register
+      instantiation will work.  */
+   if (current_function_calls_alloca)
+     {
+       rtx pseudo = gen_reg_rtx (Pmode);
+ 
+       /* Insert initialization of the pseudo stack pointer from the
+          hard stack pointer at the beginning of the function.  First
+          insn in the chain is always a NOTE_INSN_DELETED, emit our
+          move after that */
+       emit_insn_after (gen_move_insn (stack_pointer_rtx,
+ 				      hard_stack_pointer_rtx),
+ 		       get_insns ());
+ 
+       /* Substitute the pseudo in place of STACK_POINTER_REGNUM */
+       REGNO (stack_pointer_rtx) = REGNO (pseudo);
+       regno_reg_rtx[REGNO (pseudo)] = stack_pointer_rtx;
+     }
+ #endif /* PSEUDO_STACK_POINTER */
+ 
    insns = get_insns ();
  
***************
*** 2955,2958 ****
--- 2997,3019 ----
      obey_regdecls = 0;		/* if optimizations being done.  */
  
+   /* Perform the optional `exotic' pass.  It may generate additional
+      pseudos and so must be run prior to flow analisys.  */
+ 
+   TIMEVAR (exotic_time,
+ 	   {
+ 	     exotic (insns, max_reg_num ());
+ 	   });
+ 
+   if (exotic_dump)
+     TIMEVAR (dump_time,
+ 	     {
+ 	       fprintf (exotic_dump_file, "\n;; Function %s\n\n",
+ 			IDENTIFIER_POINTER (DECL_NAME (decl)));
+ 	       print_rtl (exotic_dump_file, insns);
+ 	       fflush (exotic_dump_file);
+ 	     });
+   
+   exotic_completed = 1;
+ 
    regclass_init ();
  
***************
*** 3138,3145 ****
--- 3199,3211 ----
       and delete no-op move insns.  */
  
+   /* But if jump insn(s) on this machine clobbers some regs, it is
+      unsafe to do jump optimization after the register allocation.  */
+ 
+ #ifndef JUMP_CLOBBERS_REGS
    if (optimize > 0)
      {
        TIMEVAR (jump_time, jump_optimize (insns, 1, 1, 0));
      }
+ #endif
  
    /* Dump rtl code after jump, if we are doing that.  */
***************
*** 3267,3270 ****
--- 3333,3345 ----
  
    reload_completed = 0;
+   exotic_completed = 0;
+ 
+ #ifdef PSEUDO_STACK_POINTER
+   /* If we fooled with stack_pointer_rtx, restore its normal state */
+   if (current_function_calls_alloca) {
+     PUT_CODE (stack_pointer_rtx, REG);
+     REGNO (stack_pointer_rtx) = STACK_POINTER_REGNUM;
+   }
+ #endif /* PSEUDO_STACK_POINTER */
  
    /* Clear out the insn_length contents now that they are no longer valid.  */
***************
*** 3450,3453 ****
--- 3525,3529 ----
   		    combine_dump = 1;
   		    dbr_sched_dump = 1;
+  		    exotic_dump = 1;
   		    flow_dump = 1;
   		    global_reg_dump = 1;
***************
*** 3470,3473 ****
--- 3546,3552 ----
  		  case 'd':
  		    dbr_sched_dump = 1;
+ 		    break;
+ 		  case 'e':
+ 		    exotic_dump = 1;
  		    break;
  		  case 'f':
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/varasm.c gcc-2.7.2-t800.12/varasm.c
*** gcc-2.7.2/varasm.c	Fri Sep  1 03:02:34 1995
--- gcc-2.7.2-t800.12/varasm.c	Thu May 16 18:20:41 1996
***************
*** 3398,3401 ****
--- 3398,3405 ----
  	  break;
  
+ 	case MODE_RANDOM:  /* hack for label_ref constants, which are VOIDmode */
+ 	  assemble_integer (x, UNITS_PER_WORD, 1);
+ 	  break;
+ 
  	default:
  	  abort ();
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/version.c gcc-2.7.2-t800.12/version.c
*** gcc-2.7.2/version.c	Sun Nov 26 19:20:24 1995
--- gcc-2.7.2-t800.12/version.c	Mon Apr 28 17:06:20 1997
***************
*** 1 ****
! char *version_string = "2.7.2";
--- 1 ----
! char *version_string = "2.7.2-t800.12";
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x TAGS-c -x TAGS-h -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* -x cp/parse.c -x cp/parse.h gcc-2.7.2/xx-make gcc-2.7.2-t800.12/xx-make
*** gcc-2.7.2/xx-make	Thu Jan  1 03:00:00 1970
--- gcc-2.7.2-t800.12/xx-make	Mon Jan 22 11:36:33 1996
***************
*** 0 ****
--- 1,3 ----
+ #!/bin/sh
+ name=${1:?'Usage: xx-make <function name>'}
+ ./xgcc -B./ -E -O2 -Dinhibit_libc -DCROSS_COMPILE -DIN_GCC -DPOSIX  -g -I./include -g1 -I. -I. -I../config -c -DL${name} ../libgcc2.c > xx
